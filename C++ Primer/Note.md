## 第1章 开始

1. 一个函数的定义包含**四部分**：返回类型（return type），函数名（function name），一个括号包围的形参列表（parameter list，**允许为空**）,以及函数体（function body）。`mian`**函数的返回值==必须为in==t**。**当return语句包括一个值时**，**此返回值的类型于函数的返回类型相同**。在大多数系统中，`main`的**返回值**都被**用来指示状态**。返回0表示成功，非0的返回值的含义有系统定义，通常用来指出错误类型。**C++程序**，不同的编译器使用不同的后缀命名约定，**最常见的包括**`.cc，.cxx，.cpp，.cp`

2. [MSVC 编译器选项 | Microsoft Learn](https://learn.microsoft.com/zh-cn/cpp/build/reference/compiler-options?view=msvc-170&form=MG0AV3)

3. 初识输入输出

   - `iostream`库包含两个基础类型`istream`和`ostream`分别表示输入流和输出流。

   - 标准库定义了4个IO对象，输入`cin`是`istream`类型对象（**标准输入**）。`cout`为`ostream`类型的对象（**标准输出**）`cerr`和`clog`**标准错误**，`clog`**用来输出程序运行时的一般信息**。

     - 默认情况下，读`cin`会刷新`cout`；程序非正常终止时也会刷新`cout`

     - 默认情况下，写到`cerr`的数据是不缓冲的。`cerr`**通常用于输出错误信息**或其它不属于程序正常逻辑的输出内容

     - 写到`clog`**的数据是被缓冲**的，`clog`通常用于报告程序的执行信息，存入一个日志文件中。

   - `#include`指令和头文件的名字必须写在同一行中。`#include`指令必须出现在所有函数之外。

   - `<<`运算符接收两个运算对象：**左侧的运算对象**必须是一个`ostream`对象，**右侧的运算对象**是要打印的值。

     - `<<`运算符**返回左侧的运算对象**，因此第一个运算符的结果成为了第二个运算符的左侧运算对象。

       ```c++
       //我们的表达式等于
       (std::cout<<"Enter two number:")<<std::endl;
       ```

     - `endl`这是一个被称为操作符的特殊值。写入`endl`的效果是**结束当前行，并将于设备关联的缓冲区中的内容刷到设备中。**

     - 程序员常常在调试时添加打印语句。这类语句应该保证“一直”刷新流。否者，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误推断。

   - `>>`**输入运算符**和输出运算符类似，它接收一个`istream`作为其左侧运算对象，接收一个对象作为其右侧运算对象。

   - 当我们使用一个`istream`**对象作为条件时，其效果是检查流的状态**。如果流是有效的，即流遇未到错误，那么检测成功。当遇到文件结束符，或遇到一个无效输入时，`istream`对象的状态会变得无效。处于无效状态的`istream`对象会使条件变为假。

   - 我们通常使用`.h`组为头文件的后缀，但也有一些程序习惯用`.H`，`.hpp`，`.hxx`。**标准库头文件通常不带后缀**。

## 第一部分

### 变量和基本类型

| 类型          | 含义           | 最小尺寸     |
| ------------- | -------------- | ------------ |
| `bool`        | 布尔类型       | 未定义       |
| `char`        | 字符           | 8位          |
| `wchar_t`     | 宽字符         | 16位         |
| `char16_t`    | Unicode字符    | 16位         |
| `char32_t`    | Unicode字符    | 32位         |
| `short`       | 短整形         | 16位         |
| `int`         | 整形           | 16位         |
| `long`        | 长整形         | 32位         |
| `long long`   | 长整形         | 64位         |
| `float`       | 单精度浮点数   | 6位有效数字  |
| `double`      | 双精度浮点数   | 10位有效数字 |
| `long double` | 扩展精度浮点数 | 10位有效数字 |

1. `wchar_t`类型用于**确保可以存放机器最大扩展字符集**中的任意一个字符，类型`char16_t`和`char32_t`则为`Unicode`字符集服务。
   
   - 字符型被分为了三种：`char`，`signed char`和`unsigned char`，**尽管字符型有三种，但是字符型的表现形式却只有两种**：带符号的和无符号的。类型char实际上会表现为上述两种形式的一种，**具体是哪种由编译器决定**。
   
2. **选着类型的一些经验尊则**
   
   - **数值不可能为负**时，选用无符号类型。
   - 使用`int`执行整数运算，`short`常常显得太小而`long`一般和`int`有一样的尺寸。数值超过了`int`的表示范围，选用`long long`。
   - 在算术表达式种不要用`char`或`bool`，只有在**存放字符**或**布尔值**时才使用它。因为类型`char`在一些机器上是有符号的，而在另一些机器上又是无符号的，所以说如果使用`char`进行运算特别容易出问题。如果**你需要使用一个不大的整数**，那么**明确指定他的类型是**`signed char`或者`unsigned char`。
   
3. 类型转换
   - **非布尔值类型**的算数值**赋值给布尔值类型**时，初始值为**0**则结果为**false**，否则结构为true。
   
   - **赋给无符号类型一个超出它表示范围的值**时，结果是初始值对无符号类型表示数值总数**取模后的余数**。
   
   - 赋给一个带符号类型一个超出它能表示范围的值时，结果是**未定义的**。
   
   - ==**程序应该尽量避免依赖于实现环境的行为**==
   
   - ==**当一个算术表达式中既有无符号数又有`int`值时，`int`值就会转换成无符号的**==
   
     - 把负数转换成无符号数类型类似于直接给无符号数赋一个负值，**结果等于这个负数加上无符号数的模**
     - ==**不要混用带符号类型和无符号类型**==
   
   - 默认情况下，十进制字面值是带符号数，八进制和十六进制值字面值即可能是带符号的也可能是无符号的。
   
   - 泛化的转义序列：形式是`\X`后紧跟1个或多个十六进制数字，或者\后紧**跟1个，2个或3个**八进制数字。
   
     - \115(字符M)\x4d(字符M)
   
   - 指定字面值类型
   
     | 前缀 | 含义                      | 类型     |
     | ---- | ------------------------- | -------- |
     | `u`  | Unicode16字符             | char16_t |
     | `U`  | Unicode32字符             | char32_t |
     | `L`  | 宽字符                    | wchar_t  |
     | `u8` | UTF-8(仅用于字符串字面零) | char     |
   
   - `nullptr`**指针字面值**。

#### 变量

1. 变量的定义

   - 初始化不是赋值，**初始化的含义是创建变量时赋予其一个初始值**，而赋值的含义是把对象的当前值擦除,而以一个新值来替代。

   ```c++
   int units_sold = 0;
   int units_sold ={0};
   int units_sold{0};//C++ 11 列表初始化
   int units_sold(0);
   ```

   - 如果我们使用**列表初始化且初始值存在丢失信息**的风险，则编译器将报错：

     ```c++
     long double ld = 3.1415926536;
     int a{ld},b{ld} //错误：转化未执行，因为存在丢失信息的风险
     int c(ld),d=ld; //正确：转换执行，且确实丢失了部分值
     ```

2. 默认初始化

   - 定义于任何函数体之外的变量被初始化为0
   - 定义于函数体内部的内置类型变量将**不被初始化**。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其它形式访问此类值将引发错误。
   - 每个**类各自决定其初始化对象的方式**。而且，**是否允许不经初始化就定义对象也由类自己决定**。如果类允许这种行为，它将决定对象的初始值到底是什么。**绝大多数类都支持无须显式初始化而定义对象**，这样的类提供了一个合适的默认值。例如，==string类规定如果没有指定初值则生成一个空串==
   - ==**声明一个变量而非定义它**==，就在**变量名前添加关键字extern**,而且不要显式地初始化变量:`extern int i`
     - 我们**能给由extern关键字标记的变量赋一个初始值**，但是这么做也就抵消了extern的作用。**extern语句如果包含初始值就不再是声明，而变成定义了**
     - ==在函数体内部，初始化一个由`extern`关键字标记的变量，将引发错误。==

3. 标识符

   - C++标识符的长度没有限制，但是对大小写字母敏感。

   - C++标准库保留了一些名字，**用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头，定义在函数体外的标识符不能以下划线开头。**

     <img style="width: 800px;height:400px" src="Image\C++关键字.png">

   - **作用域中一旦声明了某个名字**，它所**嵌套着的所有作用域中都能访问该名字**。同时，**允许在内层作用域中重新定义外层作用域已有的名字**。

     ```c++
     int reused = 42;
     int main()
     {
         int unique = 0;
         cout<<reused<<" "<<unique<<endl;//使用全局变量reused
         int reused = 0; //新建局部变量reused，覆盖全局变量reused
         cout<<reused<<" "<<unique<<endl;
         //显示地访问全局变量reused
         cout<<::reused<<" "<<unique<<endl;
     }
     ```

   - 因为**全局作用域本身并没有名字**，所以**当作用域操作符的左侧为空时，向全局作用域发出请求**获取作用域操作符右侧名字对应的变量。

4. 复合类型

   - 定义引用时，程序把引用和它的初始值**绑定**在一起，而不是将初始值拷贝给引用，一旦初始化完成，**引用将和它的初始值和对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象**，==因此引用必须初始化。==

     - ==引用并非对象，他只是为一个已经存在的对象所起的另外一个名字==。
     - 因为引用本身不是一个对象，所以不能定义引用的引用。
     - 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。

   - **指针本身就是一个对象**。

     - ==**因为引用不是对象，没有实际地址，所以不能定义指向引用的指针**==

     - ```c++
       //生成空指针的方法
       int *p1=nullptr;
       int *p2=0;
       //需包含cstdlib
       int *p3=NULL;
       ```

     - ==一个指针指向某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同的情况，即指针相等。==

     - `void*`是一种特殊的指针类型，可用于存放任意对象的地址。因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。

       ```c++
       int i =42;
       int *p;		//p是一个int型的指针
       int *&r=p;	//r是一个对指针p的引用
       
       r=&i;	//r引用了一个指针，因此给r赋值&i就是令p指向i
       *r=0;	//解引用r得到i，也就是p指向的对象，将i的值改为0
       ```

     - **面对一条比较复杂的指针或者引用的声明语句时，==从右往左阅读==有助于弄清楚它的真实含义。**

5. `const `限定符

   - 因为`const`对象一旦创建后就不能改变，所以`const`**对象必须初始化**。
   - **默认情况下，`const`对象被设定为仅在文件内有效，当文件中出现了多个同名的`const`变量时，其实就等同于在不同文件中分别定义了独立的变量。**
   - 某些时候有这样一种`const`变量，它的初始值不是一个常量表达式，但又确实有必要**在文件间共享**。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类`const`对象像其他(非常量)对象一样工作，也就是说，**只在一个文件中定义**`const`,而在**其他多个文件中声明并使用它**。解决的办法是，对于`const`==变量不管是声明还是定义都添加`extern`关键字==，这样只需定义一次就可以了:
     - `extern const int bufSize = fcn();`
     - `extern const int bufSize;`

6. `const`的引用

   - ==**对常量的引用**==

     - 引用的类型必须与其所引用对象的类型一致， 但是有**两个例外**。第一种例外情况就是在**初始化常量引用时允许用任意表达式作为初始值**，**只要该表达式的结果能转换成引用的类型即可**。尤其，==**允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式**==。

       ```c++
       double dval = 3.14;
       const int &ri=dval;
       //ri引用了一个int型的数。对ri的操作因该是整数运算，但dval却是一个双精度浮点数而非整数，因此为了确保让ri绑定到一个整数，编译器把上述代码变成了如下形式：
       const int temp = dval; //由双精度浮点数生成一个临时的整形常量
       const int &ri=temp;//让ri绑定这个临时量
       ```

     - 在这种情况下，`ri`绑定了一个**临时量**(temporary)对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。接下来探讨当`ri`不是常量时，如果执行了类似于上面的初始化过程将带来什么样的后果。**如果`ri`不是常量**，就允许对`ri`赋值，这样就会改变`ri`所引用对象的值。注意，此时绑定的对象是一个临时量而非`dval`。 程序员既然让`ri` 引用`dval`，就肯定想通过`ri`改变`dval`的值，否则干什么要给`ri`赋值呢？如此看来，既然大家基本上不会想着把引用绑定到临时量上，==**C++语言也就把这种行为归为非法**==。

   - 指针和`const`

     - **==指向常量的指针==**  `const double pi = 3.14;`
     - ==**常量指针**==必须初始化，而且一日初始化完成，则它的值(也就是存放在指针中的那个地址)就不能再改变了。

   - ==**顶层const**==**表示指针本身是个常量**，==**底层const**==**表示指针所指的对象是一个常量**

7. `constexpr`和常量表达式

   - **常量表达式**是指值不会改变并且在**编译过程就能得到计算结果的表达式**。用常量表达式初始化的`const`对象也是常量表达式。

   - 声明为`constexpr`的变量一定是一个常量，而且必须用常量表达式初始化。

   - ```c++
     constexpr int mf = 20;
     constexpr int limit = mf+1;
     constexpr int sz - size();
     ```

   - 新标准允许定义一种特殊的`constexpr`函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用`constexpr`函数去初始化`constexpr`变量了。

   - 声明`constexpr`时用到的类型必须有所限制，因为这些类型一般比较简单，值也显而易见，容易得到，就把他们称为**字面值类型**。

   - 尽管指针和引用都能定义成`constexpr`, 但它们的初始值却受到严格限制。一个`constexpr`**指针的初始值必须是`nullptr`或者`0`**，或者是存储于某个固定地址中的对象。

     ```c++
     constexpr int *p=nullptr;//constexpr把它所定义的对象置为了顶层const
     
     constexpr int *np=nullptr;//np是一个指向整数的常量指针，其值为空
     int j = 0;
     constexpr int i =42;
     //i和j都必须定义在函数体之外
     
     constexpr const int *p=&i; //p是常量指针，指向整形常量i
     constexpr int *p1=&j;//p1是常量指针，指向整数j
     ```

8. 处理类型

   - 新标准规定了一种新的方法，使用==**别名声明**==`using SI=Sales_ites SI`是`Sales_item`的同义词

     - ```c++
       typedef char *pstring;
       const pstring cstr = 0; //cstr是指向char的常量指针
       const pstring *ps;		//ps是一个指针，它的对象是指向char的常量指针
       ```

     - ==const是对给定类型的修饰==

   - `auto`类型说明符C++11

     - 它让编译器替我们取分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型。**auto定义的变量必须有初始值**
     - `auto`也能在一条语句中**声明多个变量**，因为一条声明语句只能有一个基本数据类型，所以**该语句中所有变量的初始基本类型都必须一样**。
       - `auto sz = 0,pi=3.14`//错误：sz和pi的类型不一致
     - `auto`一般会**忽略**顶层`const`，同时底层`const`**则会保留**下来。
     - **希望推断出的`auto`类型是一个顶层`const`**，需要明确指出：`const auto f = ci`
     - 设置一个类型为`auto`的引用时，初始值中的**顶层常量属性**仍然保留。

   - `decltype`类型指示符C++11

     - **希望从表达式的类型推断出要定义的类型，但是不想用该表达式的值初始化变量**，`decltype`它的作用是选择并返回操作数的数据类型。

       ```c++
       decltype(f()) sum = x; //sum的类型是函数f的返回类型
       //decltype处理顶层const和引用的方式与auto有些许不同
       //decltype使用的表达式是一个变量，则decltype返回该变量的类型(包括顶层const和引用在内)
       const int ci = 0,&cj=ci;
       decltype(ci) x = 0; //x的类型是const int
       decltype(cj) y = x; //y的类型是const int&，y绑定到变量x
       ```

     - **==引用从来都是作为其所指对象的同义词出现，只有用在`decltype`处是一个例外。==**

     - 如果`decltype`使用的表达式不是一个变量，则`decltype`返回表达式结果对应的类型。

       ```c++
       int i = 42,*p=&i,&r=i;
       decltype(r+0) b;//加法的结果是int，因此b是一个（未初始化的）int
       decltype(*P) c;//c是int&,必须初始化
       ```

     - 如果**表达式的内容是解引用操作**，则`decltype`**将得到引用类型**。正如我们所熟悉的那样，**解引用指针可以得到指针所指的对象，而且还能给这个对象赋值**。因此，`decltype ( *p)`的结果类型就是`int&`，而非`int`.

     - ==`decltype((varialbe))`的结果永远是引用，而`decltype(variable)`结果只有当variable本身就是一个引用时才使引用。==

     - 赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。`decltype(a=b) d=a` 表达式`a=b`的类型是`int&`

9. 自定义数据结构

   - **类体右侧的表示结束的花括号后必须写一个分号**，这是**因为**类体后面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少；
   
   - C++11新标准规定，**可以为数据成员提供一个类内初始值**(in-class initializer)。创建对象时，**类内初始值将用于初始化数据成员**。没有初始值的成员将被默认初始化(参见2.2.1节，第40页)。因此当定义`sales_data`的对象时，`units_sold`和 `revenue `都将初始化为0，`bookNo`将初始化为空字符串。
   
     - ```c++
       struct Sales_data
       {
           std::string bookNo;
           unsigned units_sold = 0;
           double revenue = 0.0;
       }
       ```
   
   - 对类内初始值的限制与之前介绍的类似:或者放在花括号里，或者放在等号右边，==**记住不能使用圆括号**==。
   
   - ==**类所在的头文件的名字应与类的名字一样。**==例如`string`在名为`string`的头文件中定义。

### 字符串，向量和数组

#### 命名空间的using声明

- `using std::cin;`using声明，当我们使用名字`cin`时，从命名空间`std`中获取它
- **用到的每个名字都必须有自己的声明语句，而且每句话都以分号结束。**
- 位于==**头文件的代码一般来说不应该使用using声明**==。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。

#### 标准库类型string

1. `string`类型必须首先包含`string`文件。作为标准库的一部分，`string`定义在命名空间`std`中。

   | `string s1`          | 默认初始化，s1是一个空串                                    |
   | :------------------- | ----------------------------------------------------------- |
   | `string s2(s1)`      | s2是s1的副本                                                |
   | `string s2=s1`       | 等价于s2(s1)，s2是s1的副本                                  |
   | `string s3("value")` | s3是字面值"value"的副本，**除了字面值最后的那个空字符外**。 |
   | `string s3="value"`  | 等价于s3("value")，s3是字面值"value"的副本                  |
   | `string s4(n,'c')`   | 把s4初始化为由连续n个字符c组成的串                          |

   <img style="width: 800px;height:300px" src="Image\string的操作.png">

   - 如果使用**等号初始化**一个变量，实际上执行的是==**拷贝初始化**==( copy initialization), 编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果**不使用等号**，则执行的是==**直接初始化**==( direct initialization )。
   - `string s8=string(10,'c');`
   - `cin>>s` 将`string`对象读入`s`，遇到空白停止。`string`对象会自动忽略开头的空白，并从第一个真正的字符开始读起，直到遇到下一处空白为止。
   - `getline`函数参数是**一个输入流**和一个`string`对象，函数从给定的输入流中读入内容，直到遇到换行符为止（==**读入换行符，并不存放换行符**==）`getline`返回它的流参数。
   - 大多数标准库类型都定义了几种配套的类型。这些配套类型体现了示准库类型与机器无关的特性，类型size_ type即是其中的一种。在具体使用的时候，通过作用域操作符来表明名字size_ type是在类string中定义的。
   - 如果两个string对象在**某些对应的位置上不一致**，则string对象比较的**结果**
     其实是string对象中==**第一对相异字符比较的结果**==。

2. 字面值和`string`对象相加

   - 标准库允许把**字符字面值**和**字符串字面值**转换成`string`对象。当把`string`对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保**每个加**
     **法运算符**的**两侧**的运算对象至少有一个是`string`字符串

   - `cctype`头文件和`ctype.h`头文件的内容是一样的，只不过从命名规范上
     来讲更符合C++语言的要求。特别的，在名为`cname`的头文件中定义的名字从属于命名空间`std`,而定义在名为`.h`的头文件中的则不然。

   - ==范围`for`语句==C++11。这种语句**遍历给定序列中每个元素**并对序列中的每个值执行某种操作

     ```c++
     for(declaration:expression)//expression部分是一个对象，用于表示一个序列，declaration部分负责定义一个变量，该变量用于访问序列中的基础元素。每次迭代declaration部分的变量都会被初始化为expression部分的下一个元素值。
         statement;
     
     string str("some string");
     for(auto c:str)
         cout<<c<<endl;
     //如果想改变string对象中的值，必须把循环变量定义成引用类型
     ```

   - 下标运算符`[]`接收的输入参数是`string::size_type`

#### 标准库类型 vector

1. **模板本身不是类或函数**，相反可以将**模板看作为编译器生成类或函数编写的一份说**
   **明**。编译器根据模板创建类或函数的过程称为==**实例化**==(instantiation)，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

   - 在**早期版本的C++标准中**如果vector的元素还是vector (或者其
     他模板类型),则其**定义的形式与现在的C++11新标准略有不同**。过去，必须在外层vector对象的右尖括号和其元素类型之间==**添加一个空格**==，如应该写成`vector<vector<int> >`而非`vector<vector<int>>`。

2. 初始化`vector`对象

   - <img style="width: 900px;height:200px" src="Image\初始化vector.png">

   - 其二，如果**提供的是一个类内初始值**(参见2.6.1节，第64页)，则**只能使用拷贝初始化**或**使用花括号的形式初始化**。第三种特殊的要求是，如果**提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化**，而不能放在圆括号里

   - ==**值初始化**==：通常情况下，可以只提供`vector`对象容纳的**元素数量**而不用略去初始值。此时库会创建一个**值初始化的**( value-initialized) **元素初值**，并把它赋给容器中的所有元素。==**这个初值由vector对象中元素的类型决定**==。

     - 对这种初始化的方式有==**两个特殊限制**==:其一,**有些类要求必须明确地提供初始值**(参见2.2.1节，第40页),如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始的元素值。对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。

   - ==**列表初始值还是元素数量**==

     - 用一个**整数来初始化**`vector<int>`时，**整数的含义**可能是`vector`对象的**容量**也可能是**元素的值**。类似的，用**两个整数来初始化**`vector<int>`时，这两个整数**可能一个是**`vector`对象的**容量**，**另一个是元素的初值**，也可能它们是容量为2`vector`对象中**两个元素的初值**。通过使用花括号或圆括号可以区分上述这些含义

       - ==**圆括号，可以说提供的值是用来构造`vector`对象的**==
       - ==**花括号，可以表述成我们想列表初始化`vector`对象**==

     - 另一方面，如果**初始化时使用了花括号的形式**但是==**提供的值又不能用来列表初始化**==，就要考虑用这样的值来**构造vector对象**了。例如，要想列表初始化一个含有string对象的vector对象，应该提供能赋给string对象的初值。此时不难区分到底是要**列表初始化vector对象的元素**还是用**给定的容量值来构造vector对象**。

       - 提供的值是用来初始化vector的还是vector的元素

         ```c++
         vector<string> v{10};//10被用来构造vector对象，10个字符串被值初始化。
         vector<int> v2{10};//列表初始化，v2有一个int值为10
         ```

   - 如果循环体内部包含有向`vector`对象添加元素的语句，则不能使用范围for循环。==**范围for语句体内不应该改变其所遍历序列的大小**==。

   - <img style="width: 900px;height:200px" src="Image\vector支持的操作.png">

   - 使用vector的`size_type`，`vector<int>::size_type`

#### 迭代器介绍

==所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。==，如果容器为空，则`begin`和`end`返回的是同一个迭代器，都是**尾后迭代器**。

<img style="width: 900px;height:200px" src="Image\标准容器迭代器的运算符.png">

1. 迭代器类型

   - `vector<int>::iterator it; vector<int>::const_iterator it2`
     - `it`能读写，而`it2`只能读
   - `cbegin`和`cend`C++11返回`const_iterator`
   - **箭头运算符**把解引用和成员访问两个操作结合在一起。
   - ==**限制**==：任何一种可能改变`vector`对象容量的操作，比如`push_back`，都会使该`vector`对象的迭代器失效。

2. 迭代器运算

   <img style="width: 900px;height:300px" src="Image\vector和string迭代器支持的运算.png">

   - 迭代器相减是两个迭代器的距离。类型名为`difference_type`的带符号整形数。

#### 数组

1. 编译的时候维度因该是以知的，维度必须是**一个常量表达式**。定义数组的时候必须指定数组的类型，不允许用`auto`**关键字由初始值的列表推断类型**。

   - ```c++
     int (*Parray)[10]=&arr;
     int (&arrRef)[10]=arr;//引用一个含有10个整数的数组
     					  //类型修饰符从右向左依次绑定
     unsigned scores[11]={};//全部初始化为0
     ```

   - ==**就数组而言**==，由**内向外阅读**助我们更好地理解`Parray`的含义:首先是圆括号括起来的部分，`*Parray` 意味着`Parray`是个指针，接下来观察右边，可知道`Parray`是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是`int`。这样最终的含义就明白无误了。

2. 使用数组下标的时候，通常将其定义为**size_t**类型，`size_t`是一种机器相关的的无符号类型。`cstddef`头文件定义了`size_t`类型。

   - 在很多用到**数组名**字的地方，编译器都会自动地将其替换为一个**指向数组首元素的指针**。
   - `auto p(scores);`p的类型是`int*`
   - `decltype(scores) ia;` 此关键字上述转化不会发生，返回的类型是10个整数构成的数组。

3. 标准库函数begin()和end()

   - begin函数返回指向首元素的指针，end函数返回尾元素下一个位置的指针。**定义在`iterator`头文件中**
   - 两个指针相减的结果的类型是一种名为`ptrdiff_ t`的标准库类型，`ptrdiff_t`也是一种定义在`cstddef`头文件中的机器相关的类型。
   - **标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求**

4. 与旧代码的接口

   - `string`对象的复合赋值运算中允许使用**以空字符结束的字符数组**作为右侧的运算对象。
   - `c_str`函数返回的是一个c风格的字符串，指针的类型是`const char*`
   - 使用数组初始化`vector`对象：`vector<int> ivec(begin(arr),end(arr));`

#### 多维数组

```c++
int ia[3][4] = 
{
    {0,1,2,3},
    {4,5,6,7},
    {8,9,10,11}
};
//没有标识每行的花括号，与之前的初始化语句是等价的
int ia[3][4]={0,1,2,3,4,5,6,7,8,9,10,11};
for(auto row:ia)
{//编译器初始化row时会自动将这些数组形式的元素钻换为指向该数组内首元素的指针
    for(auto col:row)
    {//这样得到的row的类型就是int*,显然内层的循环就不合法了。
        
    }
}
```

1. ==**范围for语句处理多维数组时，除了最内层的循环外，其它所有的循环的控制变量都应该是引用类型。**==

   ```c++
   using int_array = int[4];
   typedef int int_array[4];
   int_array *p = ia;//int_array只是类型，需要用*表述是4个元素的指针
   ```

### 表达式

#### 基础

**同一组内**的运算符**优先级相同**，组的位置越**靠前**组内的运算符**优先级越高**。

<img style="width: 900px;height:600px" src="Image\运算符优先级表1.png">

<img style="width: 900px;height:900px" src="Image\运算符优先级表2.png">

- 函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。

- 一般的二元运算符都要求两个**运算对象相同**，但是很多时候即使运算对象的类型不行同也没有关系，只要他们能被**转换成同一种类型**。

- 使用关键字`decltype`的时候，左值和右值也有所不同。如果==**表达式的求值结果是左值**==，`decltype` **作用于该表达式**(不是变量)得到一个引用类型。
- **优先级**于**结合率**
  - 算术运算符满足左结合率，如果**优先级相同**，将按照从**左向右**的顺序**组合运算对象**
  - 括号无视优先级与结合律
  - **优先级规定了运算对象的组合方式**，**但是没有说明运算对象按照什么顺序求值**。在大多数情况下，==**不会明确指定求值的顺序**==。`int i = f1()*f2();`
  - **求值顺序**、**优先级**、**结合律**
    - **运算对象的求值顺序与优先级和结合律无关**，在一条形如f()+g()*h()+j()的表达.式中:
      - **优先级规定**，g()的返回值和h()的返回值相乘。
      - **结合律规定**，f()的返回值先与g()和h()的乘积相加，所得结果再与j ()的返回值相加。
      - 对于这些函数的调用顺序没有明确规定。
- 括号无视优先级与结合律

#### 算术运算符

1. 布尔类型的==**运算对象**==将被提升为`int`类型

#### 逻辑和关系运算符

1. 逻辑运算符和关系运算符的**返回值都是布尔类型**
2. 逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，**当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值**。

#### 赋值运算符

1. ==**赋值运算的结果是它的左侧运算对象**==，并且是一个左值。
2. **赋值运算优先级较低**
3. 使用复合运算符只求值一次，使用普通的运算符则求值两次。这两次包括:一 次是作 为右边子表达式的一部分求值，另一次是作为赋值运算的左侧运算对象求值。其实在很多地方，**这种区别除了对程序性能有些许影响外几乎可以忽略不计**。

#### 递增和递减运算符

1. 前置版本，这种形式的运算符首先将运算对象加1 (或减1)，然后将改变后的对象作为求值结果。**后置版本**也会将运算对象加1 (或减1)，但是**求值结果是运算对象改变之前那个值的==副本==**。

#### 成员访问运算符

#### 条件运算符

1. 条件运算符`?:`允许我们把简单的if-else逻辑嵌入到单个表达式中
   - 当条件表达符的**==两个表达式都是左值或者能转换成同一种左值类型时==**，**运算的结果是左值**：否则运算的结果是右值。
   - 条件运算符的优先级非常底。

#### 位运算符

- 如果运算对象是**带符号**的且**它的值为负**，那么位运算符如何处理运算符对象的**符号位**依赖于机器。而且此时的左移操作可能会改变符号位的值，因此是一种未定义的行为。

- 这两种运算符的内置含义是对其**运算对象执行基于二进制位的移动操作**，首先令左侧运算对象的内容**按照右侧运算对象的要求移动指定位数**，然后将经过移动的(可能还进行了提升)左侧运算对象的==**拷贝作为求值结果**==。其中，==**右侧的运算对象一定不能为负**==，而且值必须严格小于结果的位数，否则就会产生未定义的行为。二进制位或者向左移(<<)或者向右移(>>)，移出边界之外的位就被舍弃掉了。

- `>>`如果该运算对象是**带符号类型**，在左侧插入带符号位的副本或者值位0的二进制位，==**如何选择要视具体环境而定。**==
- `char`为运算对象时，`char`会提升为`int`
- `^`**位异或**运算符**有且只有一个1**结果为1，否则为0。

#### `sizeof`运算符

- `sizeof`右结合律，**所得的值是一个size_t**类型。`sizeof(type)`或`sizeof expr`，`sizeof`==**并不实际计算其运算对象的值**==
- 对`char`或者类型为`char`的表达式执行`sizeof`运算，结果得1。
- 对**引用类型执行**`sizeof`运算得到**被引用对象**所占空间的大小。
- 对**指针执行**`sizeof`运算得到**指针本身所占空间**的大小。
- 对**解引用指针执行**`sizeof`运算得到**指针指向的对象所占空间的大小**，==指针不需有
  效==。
- **对数组执行**`sizeof`运算**得到整个数组所占空间的大小**，等价于对数组中所有的元素各执行一次`sizeof`运算并将所得结果求和。注意，`sizeof`==**运算不会把数组转换成指针来处理。**==
- 对`string`对象或`vector`对象执行`sizeof`运算**只返回该类型固定部分的大小**，不会计算对象中的元素占用了多少空间。

#### 逗号运算符

- 对于逗号运算符来说，**首先对左侧的表达式求值，然后将求值结果丢弃掉**。**逗号运算符==真正的结果==是右侧表达式的值**。如果右侧运算对象是左值，那么最终的求值结果也是左值。
  - `somevalue?++x,++y:--x,--y`实际上等于`(somevalue?++x,++y:--x),--y`首先判断`someValue`是否为真，如果为真，依次执行++x和++y，==**最后执行--y**==; 如果为假，执行--x和--y。

#### 类型转换

- 算术钻换

  - **运算符**的**运算对象**将转换成**最宽的类型**。当表达式中**既有浮点类型**也**有整数类型**时，整形值将转**换成相应的浮点类型**。
  - **整形提升**负责把小整数类型钻换成较大的整数类型，`bool,char,signed char,unsigned char,short,unsigned short`只要**他们所有可能的值都能存在`int`里**，他们就会**提升为**`int`类型。**否则提升为**`unsigned int`**类型**。
  - 较大的`char`类型(`wchar_ t.char16_ t.char32_ t `)提升成`int、unsigned int、long、unsigned long、long long和unsigned long long`中**最小的一种类型**，前提是**转换后的类型要能容纳原类型所有可能的值**。

- 无符号类型的运算对象

  - 类型不一致，这些运算对象将转换成同一种类型。相对大小了。但是如果**某个运算对象的类型是无符号类型**，那么**转换的结果**就要**依赖于**机器中各个整数类型的**相对大小**了
  - 如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且其中的**无符号类型不小于带符号类型**，那么**带符号的运算对象转换成无符号**的。例如，假设两个类型分别是`unsigned int`和`int`，则`int`类型的运算对象转换成`unsigned int`类型。需要注意的是，如果`int`型的**值恰好为负值**，其结果将以2.1.2节(第32页)介绍的方法转换，并带来该节描述的所有副作用。
  - 剩下的一种情况是**带符号类型大于无符号类型**，此时转换的结果依赖于机器。如果**无符号类型的所有值**都**能存在该带符号类型中**，则**无符号类型的运算对象转换成带符号类型**。如果不能，那么带符号类型的运算对象转换成无符号类型。例如，如果两个运算对象的类型分别是`long`和`unsigned int`,并且`int`和`long`的大小相同，则`long`类型的运算对象转换成`unsigned int` 类型;如果`long`类型占用的空间比`int`更多，则`unsigned int`类型的运算对象转换成`long`类型。

- 其它隐式类型钻换

  - 当数组被用作`decltype`关键字的参数，或者作为取地址符(&)、`sizeof` 及`typeid`(第19.2.2 节，732页将介绍)等运算符的运算对象时，**数组不会自动转换成指向数组首元素的指针**。
  - ==**类类型定义的转换**==:类类型能定义由编译器自动执行的转换，不过**编译器每次只能执行一种类类型的转换**。在7.5.4节(第263页)中我们将看到一个例子，如果同时提出多个转换请求，这些请求将被拒绝。

- 显示转换

  - `cast-name<type>(expression)` type是转换的目标类型，expression是要转换的值，cast-name是`static_cast，dynamic_cast，const_cast，reinterpret_cast`中的一种，cast-name指定了**执行的是哪种转换**

  - `static_cast`

    - 任何具有明确定义的类型转换，只要==**不包含底层**==`const`,都可以使用static_ cast.
      - “**有明确定义的类型转换**”指的是那些在语言规范中明确规定可以进行的类型转换。这意味着这些类型转换是安全的、合法的，并且编译器知道如何正确地执行它们。
    - 当需要把**一个较大的算术类型赋值给较小的类型时**，static_ cast非常有用。此时，强制类型转换告诉程序的读者和编译器:我们知道并且不在乎潜在的精度损失。一般来说，如果**编译器发现一个较大的算术类型试图赋值给较小的类型，就会给出警告信息**;但是当我们执行了显式的类型转换后，警告信息就会被关闭了。

  - `const_cast`

    - `const_cast`==**只能改变运算对象的底层const**==

    - ```c++
      const char *pc;
      char *p = const_cast<char*>(pc);
      //正确：但是通过p写值是未定义的行为。
      ```

    - ==**只有`const_cast`能改变表达式的常量属性**==，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。同样的，也不能用`const_ cast`改变表达式的类型。

  - `reinterpret_cast`

    - ==**通常为运算对象的位模式提供较低层次上的重新解释**==。

  - ==**避免强制类型转换**==

    - 强制类型转换干扰了正常的类型检查(参见2.2.2节，第42页)，因此我们强烈建议程序员避免使用强制类型转换。这个建议对于reinterpret cast尤其适用，因为此类类型转换总是充满了风险。在有重载函数的上下文中使用const cast无可厚非，关于这一点将在6.4节(第208页)中详细介绍;但是在其他情况下使用const cast也就意味着程序存在某种设计缺陷。其他强制类型转换，比如static cast和dynamic_ cast,都不应该频繁使用。 每次书写了一条强制类型转换语句，都应该反复斟酌能否以其他方式实现相同的目标。就算实在无法避免，也应该尽量限制类型转换值的作用域，并且记录对相关类型的所有假定，这样可以减少错误发生的机会。

  - 旧式的强制类型钻换

    - type(expr) 函数式的强制类型转换
    - (type) expr C语言风格的强制类型转换

### 语句

#### 简单语句

- 如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使==**用空语句**==。`;`

#### 语句作用域

- 定义在**控制结构当中的变量只在相应语句的内部可见**。

#### 条件语句

- `else`于**离他最近的尚未匹配**的`if`匹配，从而消除了程序的二义性。

- `case`标签==**必须是整形常量表达式**==，任何两个`case`标签的值不能相同

- ```c++
  switch(ch)
  {//写在一行里，强调这些case代表的是某个范围内的值
      case 'a': case'e': case'i': case'o': case'u':
         	++vowelcnt;
          break;
  }
  ```

- `switch`内部的变量定义

  - ==**不允许跨过变量的初始化语句直接跳到转到该变量作用域的另一个位置。**==
  - 如果某个`case`分支定义并初始化一个变量，我们因该把变量定义在块内。

#### 迭代语句

- `for`语句省略`condition`的效果等价于在条件部分写了一个`true`。

- 范围`for`语句每次迭代都会重新定义循坏控制变量，并将其初始化成序列中的下一个值。

- ```c++
  //范围for语句与之等价的传统for语句
  for(auto beg = v.begin(),end = v.end();beg!=end;++beg)
  {
      auto &r = *beg;
      r*=2;
  }
  //范围for中预存了begin和end的值，一旦在序列中添加(删除)元素，预存的值可能失效。
  ```

- `do while`语句

  - ==**`condition`使用的变量必须定义在循环体之外**==。
  - 先执行语句或块，后判断条件，所以不允许在条件部分定义变量。

#### 跳转语句

- `continue`对于`while`或者`do while`来说**继续判断条件的值**，对于`for`循环来说，==**继续执行`for`语句头的`expression`**==
- **标签标示符独立于变量或其他标示符的名字**，因此，标签标示符可以和程序中其他实体的标示符使用同一个名字而不会相互干扰。`goto`==**语句和控制权转向的那条带标签的语句必须位于同一个函数之内**==。

#### try语句块和异常处理

- 当程序的**某部分检测到一个它无法处理的问题**时，需要用到异常处理。此时，**检测出问题的部分应该发出某种信号以表明程序遇到了故障**，无法继续下去了，而且**信号的发出方无须知道故障将在何处得到解决**。一旦发出异常信号，检测出问题的部分也就完成了任务。如果程序中**含有可能引发异常的代码**，那么**通常也会有专门的代码处理问题**。例如，如果程序的问题是输入无效，则异常处理部分可能会要求用户重新输入正确的数据;如果丢失了数据库连接，会发出报警信息。

- ==**抛出异常将终止当前的函数**==，并把控制权转移给能处理该异常的代码。

  ```c++
  if(item1.isbn()!=item2.isbn())
  {
      throw runtime_error("Data must refer to same ISBN");
  }
  cout<<item1+item2<<endl;
  ```

  - `runtime_error`是标准异常类型的一种，==定义在==`stdexcept`==头文件==中，我们必须初始化`runtime_ error`的对象，方式是**给它提供一个string对象或者一个C风格的字符串**。
  - `throw`后紧跟一个表达式，==**表达式的类型就要抛出异常的类型**==。

  ```c++
  while (cin>>item1>>item2)
  {
      try{
          //执行两个Sales_item对象的代码
          //如果添加失败，代码抛出一个runtime_error异常
      }catch(runtime_error err){
          cout<<err.what()<<endl;
      }
  }
  ```

  - 跟在`try`块之后的**是一个或多个`catch`子句**。`catch`子句包括三部分:关键字`catch`、**括号内一个(可能未命名的)对象的声明**(称作异常声明，exception declaration)以及一个块。当选中了某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch**子句之后的那条语句继续执行**。
  - try**语句块中的program-statements 组成程序的正常逻辑**，像其他任何块一样，program-statements可以有包括声明在内的任意C++语句。一如往常， ==**try语句块内声明的变量在块外部无法访问，特别是在catch子句内也无法访问。**==
  - 寻找处理代码的过程与函数调用链刚好**相反**。当**异常被抛出时**，**首先搜索抛出该异常的函数。如果没找到匹配的`catch`子句，终止该函数**，**并在调用该函数的函数中继续寻找。如果还是没有找到匹配的`catch`子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推**，沿着程序的执行路径逐层回退，直到找到适当类型的`catch`子句为止。如果**最终还是没能找到任何匹配的`catch`子句，程序转到名为`terminate`的标准库函数**。该函数的行为与系统有关，一般情况下， **执行该函数将导致程序非正常退出**。
  - <img style="width: 1000px;height:250px" src="Image\stdexcept.png">
  - `exception`**头文件**定义了最通用的异常类`exception`，它只报告异常的发送，不提供任何额外信息。
  - `new`**头文件**定义了`bad_alloc`异常类型，这种类型将在12.1.2节(第407页)详
    细介绍。
  - `type_ info`**头文件**定义了`bad_cast`异常类型，这种类型将在19.2节(第731
    而)详细介绍
    - 我们只能以==**默认初始化(**==参见2.2.1节，第40页)的方式初始化`exception`.
      `bad_alloc` 和`bad_ cast` 对象，**不允许为这些对象提供初始值**。

### 函数

#### 函数基础

- ==**实参是形参的初始值**==，第一个实参初始化第一个形参**。尽管实参于形参存在对应关系，但是并没有规定实参的求值顺序。**
  - 为了于`C`兼容，也可使用关键字`void`表示函数没有形参。
  - ==**函数的返回值不能是数组类型或函数类型**==。

- 函数的名字也必须在使用之前声明，**如果一个函数永远不会被我们用到，那么它可以只有声明没有定义**。
  - 因为函数的声明不包含函数体，所以也就无须形参的名字。事实上，在函数的声明中经常省略形参的名字。尽管如此，写上形参的名字还是有用处的，它可以帮助使用者更好地理解函数的功能
  - 定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。

#### 参数传递

- 当用**实参初始化形参**时==**会忽略掉顶层**==`const`，当形参有顶层`const`时，传给它常量对象或者非常量对象都是可以的。

  - 使用**非常量引用会极大地限制函数所能接受的实参类型**，例如：我们不能把`const`对象，字面值或者需要类型转换的对象传递给普通的引用形参。

- 数组形参

  - ```c++
    //尽管形式不同，但这三个print函数是等价的
    void print(const int *);
    void print(const int []);
    void print(const int [10]);//这里的维度表示我们期望数组含有多少元素，实际不一定。
    ```

- 含有可变形参的函数

  - 如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用
    `initializer_ list` 类型的形参。

    <img style="width: 1000px;height:250px" src="Image\initializer_list.png">

    ```c++
    //expected和actual是string对象
    if(expected !=actual)
    {
        error_msg({"functionX",expected,actual});
    }
    else
    {
        error_msg({"functionX","okey"});
    }
    ```

  - 如果想向`initializer list`形参中传递一个值的序列，则==**必须把序列放在一对花括号内**==

- 省略符形参

  - `stdarg.h`可变参数宏

#### 返回类型和return语句

- 返回void的函数不要求非得有return语句，因为在这类函数的**最后一句后面会隐式地执行return**。

- 有返回值函数

  - return语句返回值的类型**必须与函数的返回类型**相同，或者**能隐式地转换**成函数的返回型。
  - 函数的返回类型决定函数调用是否是左值。调用**一个返回引用的函数**得到**左值**，其他返回类型得到右值。**返回常量引用**不能给调用结果赋值。

- ==**列表初始化返回值**==

  - **C++11新标准规定**，函数可以**返回花括号包围的值的列表**。此处的列表也用来对表示**函数返回的临时量进行初始化**。如果**列表为空**，临时**执行值初始化**否则，返回的值由函数的返回类型决定。
  - 如果函数返回的是内置类型，则**花括号包围的列表**最多包含**一个值**，而且该值所占空间不应该大于目标类型的空间(参见2.2.1 节，第39页)。如果函数返回的是类类型，由类本身定义初始值如何使用。
  - ==**main函数没有返回值，编译器将隐式地插入一条返回0地return语句。**==

- ==**返回数组指针**==

  - **因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用**。

  - 声明一个返回数组指针的函数

    - 如果我们想定义一个返回数组指针的函数，则==**数组的维度必须跟在函数名字之后**==。然而，==**函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度**==。
      - `Type (*function(parameter_list))[dimention]`

  - **==使用尾置返回类型==**

    - C++11，**任何函数的定义都能使用尾置返回**，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。
      - `auto func(int i)->int(*)[10];`

  - 使用`decltype`

    - 如果我们知道函数返回的指针将指向哪个数组，就可以使用`decltype`关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数`i`的不同指向两个已知数组中的某一个

      ```c++
      int add[]={1,3,5,7,9};
      int even[]={,2,4,6,8};
      decltype(odd)* arrPtr(int i)
      {
          return (i%2)?&odd:&even;
      }
      //decltype并不把数组类型转换成对应的指针。
      ```

      

#### 函数重载

- 不允许两个函数除了返回类型外其它所有的要素都相同。

  - 一个拥有**顶层`const`的形参无法和另一个没有顶层`const`的形参区分**开来。

    ```c++
    Record loopup(Phone*);
    Record loopup(Phone*const);
    ```

  - 如果形参是某种类型的指针或引用，则通过**区分其指向的是常量对象还是非常量对象可以实现函数重载**，此时的`const`是底层的。

    ```c++
    Record loopuo(Account*);
    Record loopup(const Account*);
    ```

    - 传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数。

  - 有多个函数可以匹配，但是每一个都不是明显的最佳选择，此时将发送错误称为**二义性调用**。

    

- 如果在内层作用域中声明名字，他将隐藏外层作用域中声明的同名实体。==**在不同的作用域中无法重载函数名**。==

  - **在局部作用于中声明函数不是一个好的选择。**
  - ==**C++中，名字查找发生在类型检查之前**==

#### 特殊用途语言特性

- 默认实参

  - 一旦某个形参被赋予了默认值，他后面的所有形参都必须有默认值。

  - 函数调用时实参按位置解析。

  - **尽量让不怎么使用默认值得形参出现在前面，而让那些经常使用默认值得形参出现在后面。**

  - **==在给定得作用域中一个形参只能被赋予一次默认实参==**

    ```c++
    string screen(sz,sz,char = ' ');
    string screen(sz,sz,char = '*');//错误：重复声明
    ```

  - **==局部变量不能作为默认实参，除此之外，只要表达式得类型能转换成形参所需得类型，该表达式就能作为默认实参。==**

    ```c++
    //wd,def和ht得声明必须出现在函数之外
    sz wd = 80;
    char def = ' ';
    sz ht();
    string screen(sz = ht(),sz = wd,char = def);
    //用作默认实参得名字在函数声明所在得作用域内解析
    //而这些名字得求值过程发生在函数调用时。
    ```

- 内联函数和`constexpr`函数

  - 内联机制用于优化规模较小，流程直接，频繁调用得函数。很多编译器都不支持内联递归函数。
  - `constexpr`函数：函数得**==返回类型==及所有==形参的类型==都得是字面值类型**，且**函数体中必须==有且只有==一条`return`语句**。
    - `constexpr`函数被隐式地定义为内联函数。
    - `constexpr`函数体内也可以包含其它语句，只要这些语句在==**运行时**==不执行任何操作就行。
    - `constexpr`函数不一定返回常量表达式。
  - 内联函数或者`constexpr`函数通常定义在头文件中。
  - 调试帮助`cassert`
    - `CC -D NDEBUT main.c` 这条命令的作用等价于在`main.c`的文件的一开始写`#define NDEBUG`

#### 函数匹配

- 实参类型转换
  1. 精确匹配
     - 实参类型和形参类型相同。
     - 实参从数组类型或函数类型转换成对应的指针类型
     - 向实参**添加项层**`const`或者从实参中删除顶层`const`.
  2. 通过`const`==**转换**==实现的匹配(参见4.11.2 节，第143页)。
  3. 通过**类型提**升实现的匹配(参见4.11.1 节，第142页)。
  4. 通过算术类型转换或指针转换实现的匹配。
     - **所有算术类型转换的级别都一样**。
       - `int`向`unsigned int`的转换并不比从`int`向`double`的转换级别高。
  5. .通过类类型转换实现的匹配(参见14.9节，第514页，将详细介绍这种转换)。

#### 函数指针

- 把函数名作为一个值使用时，函数自动地转换成指针。

  - `pf = lengthCompare或pf=&lengthCompare`
  - `pf("hello","goodbye")或(*pf)("hello","goodbye")`等价的方式。
  - 函数指针类型必须与重载函数中的某一个精确匹配

- 函数指针形参

  ```c++
  void useBigger(const string&s1,const string&s2
                 ,bool pf(const string&,const string&));//自动地转换成指向函数的指针
  void useBigger(const string&s1,const string&s2
                 ,bool (*pf)(const string&,const string&));//显示地将形参定义成指向函数的指针
  typedef bool Func(const string&,const string*);
  typedef decltype(lengthCompare) Func2;//Func和Func2是函数类型
  typedef bool (*FuncP)(const string&const string&);
  typedef decltype(lengthCompare)*FuncP2//指向函数的指针
  ```

- 返回**指向函数的指针**

  - ==**必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。**==

    ```c++
    using F = int(int*,int);//F是函数类型，不是指针
    using PF = int(*)(int*,int);//PF是指针类型
    
    auto f1(int)->int(*)(int*,int);
    ```


### 类

#### 定义抽象数据类型

- 定义在类内的函数是隐式的`inline`函数
- `this指针`
  - 成员函数通过一个名为`this`的额外的隐式参数来访问调用它的那个对象。当我们**调用一个成员函数**时，**用请求该函数的对象地址初始化this**。
  - 任何对类成员的直接访问都被看做`this`的隐式引用
  - **尽管`this`是隐式的，但它仍然需要遵循初始化规则。**
- ==**const成员函数**==
  - 成员函数的参数列表之后的`const`的关键字是==**修改隐式**`this`**指针**==的类型。
  - 默认情况下，`this`的类型是**指向类类型非常量版本**的常量指针。
    - 不能把`this`绑定到一个常量对象上，这使我们==**不能在一个常量对象上调用普通的成员函数**==。
  - 允许把`const`关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的`const`表示`this`**是一个指向常量的指针**。像这样使用`const`的成员函数被称作**常量成员函数**(const member function)。
  - **常量对象，以及常量对象的引用或指针都只能调用常量成员函数。**
- 类作用域和成员函数
  - **编译器分两步处理类**:首先编译成员的声明，然后才轮到成员函数体(如果有的话)。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。
  - **如果成员被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定`const`属性**。同时，类外部定义的成员的名字**必须包含它所属的类名**

#### 访问控制于封装

#### 类的其它特性

#### 类的作用域

#### 构造函数再探

#### 类的静态成员





