## 第1章 开始

1. 一个函数的定义包含**四部分**：返回类型（return type），函数名（function name），一个括号包围的形参列表（parameter list，**允许为空**）,以及函数体（function body）。`mian`**函数的返回值==必须为in==t**。**当return语句包括一个值时**，**此返回值的类型于函数的返回类型相同**。在大多数系统中，`main`的**返回值**都被**用来指示状态**。返回0表示成功，非0的返回值的含义有系统定义，通常用来指出错误类型。**C++程序**，不同的编译器使用不同的后缀命名约定，**最常见的包括**`.cc，.cxx，.cpp，.cp`

2. [MSVC 编译器选项 | Microsoft Learn](https://learn.microsoft.com/zh-cn/cpp/build/reference/compiler-options?view=msvc-170&form=MG0AV3)

3. 初识输入输出

   - `iostream`库包含两个基础类型`istream`和`ostream`分别表示输入流和输出流。

   - 标准库定义了4个IO对象，输入`cin`是`istream`类型对象（**标准输入**）。`cout`为`ostream`类型的对象（**标准输出**）`cerr`和`clog`**标准错误**，`clog`**用来输出程序运行时的一般信息**。

     - 默认情况下，读`cin`会刷新`cout`；程序**非正常终止时**也会刷新`cout`

     - 默认情况下，写到`cerr`的数据是不缓冲的。`cerr`**通常用于输出错误信息**或其它不属于程序正常逻辑的输出内容

     - 写到`clog`**的数据是被缓冲**的，`clog`通常用于报告程序的执行信息，存入一个日志文件中。

   - `#include`指令和头文件的名字必须写在同一行中。`#include`指令必须出现在所有函数之外。

   - `<<`运算符接收两个运算对象：**左侧的运算对象**必须是一个`ostream`对象，**右侧的运算对象**是要打印的值。

     - `<<`运算符**返回左侧的运算对象**，因此第一个运算符的结果成为了第二个运算符的左侧运算对象。

       ```c++
       //我们的表达式等于
       (std::cout<<"Enter two number:")<<std::endl;
       ```

     - `endl`这是一个被称为操作符的特殊值。写入`endl`的效果是**结束当前行，并将于设备关联的缓冲区中的内容刷到设备中。**

     - 程序员常常在调试时添加打印语句。这类语句应该保证“一直”刷新流。否者，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误推断。

   - `>>`**输入运算符**和输出运算符类似，它接收一个`istream`作为其左侧运算对象，接收一个对象作为其右侧运算对象。

   - 当我们使用一个`istream`**对象作为条件时，其效果是检查流的状态**。如果流是有效的，即流遇未到错误，那么检测成功。当遇到文件结束符，或遇到一个无效输入时，`istream`对象的状态会变得无效。处于无效状态的`istream`对象会使条件变为假。

   - 我们通常使用`.h`组为头文件的后缀，但也有一些程序习惯用`.H`，`.hpp`，`.hxx`。**标准库头文件通常不带后缀**。

## 第一部分

### 变量和基本类型

| 类型          | 含义           | 最小尺寸     |
| ------------- | -------------- | ------------ |
| `bool`        | 布尔类型       | 未定义       |
| `char`        | 字符           | 8位          |
| `wchar_t`     | 宽字符         | 16位         |
| `char16_t`    | Unicode字符    | 16位         |
| `char32_t`    | Unicode字符    | 32位         |
| `short`       | 短整形         | 16位         |
| `int`         | 整形           | 16位         |
| `long`        | 长整形         | 32位         |
| `long long`   | 长整形         | 64位         |
| `float`       | 单精度浮点数   | 6位有效数字  |
| `double`      | 双精度浮点数   | 10位有效数字 |
| `long double` | 扩展精度浮点数 | 10位有效数字 |

1. `wchar_t`类型用于**确保可以存放机器最大扩展字符集**中的任意一个字符，类型`char16_t`和`char32_t`则为`Unicode`字符集服务。
   
   - 字符型被分为了三种：`char`，`signed char`和`unsigned char`，**尽管字符型有三种，但是字符型的表现形式却只有两种**：带符号的和无符号的。类型char实际上会表现为上述两种形式的一种，**具体是哪种由编译器决定**。
   
2. **选择类型的一些经验准则**
   
   - **数值不可能为负**时，选用无符号类型。
   - 使用`int`执行整数运算，`short`常常显得太小而`long`一般和`int`有一样的尺寸。数值超过了`int`的表示范围，选用`long long`。
   - 在算术表达式种不要用`char`或`bool`，只有在**存放字符**或**布尔值**时才使用它。因为类型`char`在一些机器上是有符号的，而在另一些机器上又是无符号的，所以说如果使用`char`进行运算特别容易出问题。如果**你需要使用一个不大的整数**，那么==**明确指定他的类型是**==`signed char`或者`unsigned char`。
   
3. 类型转换
   - **非布尔值类型**的算数值**赋值给布尔值类型**时，初始值为**0**则结果为**false**，否则结构为true。
   
   - **赋给无符号类型一个超出它表示范围的值**时，结果是初始值对无符号类型表示数值总数**取模后的余数**。
   
   - 赋给一个带符号类型一个超出它能表示范围的值时，结果是**未定义的**。
   
   - ==**程序应该尽量避免依赖于实现环境的行为**==
   
   - ==**当一个算术表达式中既有无符号数又有`int`值时，`int`值就会转换成无符号的**==
   
     - 把负数转换成无符号数类型类似于直接给无符号数赋一个负值，**结果等于这个负数加上无符号数的模**
     - ==**不要混用带符号类型和无符号类型**==
   
   - 默认情况下，**十进制==字面值==是带符号数**，八进制和十六进制值字面值即可能是带符号的也可能是无符号的。
   
   - **泛化的转义序列**：形式是`\X`后紧跟1个或多个十六进制数字，或者\后紧**跟1个，2个或3个**八进制数字。
   
     - \115(字符M)\x4d(字符M)
   
   - 指定字面值类型
   
     | 前缀 | 含义                      | 类型       |
     | ---- | ------------------------- | ---------- |
     | `u`  | Unicode16字符             | `char16_t` |
     | `U`  | Unicode32字符             | `char32_t` |
     | `L`  | 宽字符                    | `wchar_t`  |
     | `u8` | UTF-8(仅用于字符串字面零) | `char`     |
   
   - `nullptr`**指针字面值**。

#### 变量

1. 变量的定义

   - 初始化不是赋值，**初始化的含义是创建变量时赋予其一个初始值**，而赋值的含义是把对象的当前值擦除,而以一个新值来替代。

   ```c++
   int units_sold = 0;
   int units_sold ={0};
   int units_sold{0};//C++ 11 列表初始化
   int units_sold(0);
   ```

   - 如果我们使用**列表初始化且初始值存在丢失信息**的风险，则编译器将报错：

     ```c++
     long double ld = 3.1415926536;
     int a{ld},b{ld} //错误：转化未执行，因为存在丢失信息的风险
     int c(ld),d=ld; //正确：转换执行，且确实丢失了部分值
     ```

2. ==**默认初始化**==

   - 定义于任何函数体之外的变量被初始化为0
   - 定义于函数体内部的内置类型变量将**不被初始化**。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其它形式访问此类值将引发错误。
   - 每个**类各自决定其初始化对象的方式**。而且，**是否允许不经初始化就定义对象也由类自己决定**。如果类允许这种行为，它将决定对象的初始值到底是什么。**绝大多数类都支持无须显式初始化而定义对象**，这样的类提供了一个合适的默认值。例如，==string类规定如果没有指定初值则生成一个空串==
   - ==**声明一个变量而非定义它**==，就在**变量名前添加关键字extern**,而且不要显式地初始化变量:`extern int i`
     - 我们**能给由extern关键字标记的变量赋一个初始值**，但是这么做也就抵消了extern的作用。**extern语句如果包含初始值就不再是声明，而变成定义了**
     - ==在函数体内部，初始化一个由`extern`关键字标记的变量，将引发错误。==

3. 标识符

   - C++标识符的长度没有限制，但是对大小写字母敏感。

   - C++标准库保留了一些名字，**用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头，定义在函数体外的标识符不能以下划线开头。**

     <img style="width: 1200px;height:600px" src="Image\C++关键字.png">

   - **作用域中一旦声明了某个名字**，它所**嵌套着的所有作用域中都能访问该名字**。同时，**允许在==内层作用域中重新定义==外层作用域已有的名字**。

     ```c++
     int reused = 42;
     int main()
     {
         int unique = 0;
         cout<<reused<<" "<<unique<<endl;//使用全局变量reused
         int reused = 0; //新建局部变量reused，覆盖全局变量reused
         cout<<reused<<" "<<unique<<endl;
         //显示地访问全局变量reused
         cout<<::reused<<" "<<unique<<endl;
     }
     ```

   - 因为**全局作用域本身并没有名字**，所以**当作用域操作符的左侧为空时，向全局作用域发出请求**获取作用域操作符右侧名字对应的变量。

4. 复合类型

   - 定义引用时，程序把引用和它的初始值**绑定**在一起，而不是将初始值拷贝给引用，一旦初始化完成，**引用将和它的初始值和对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象**，==因此引用必须初始化。==

     - ==引用并非对象，他只是为一个已经存在的对象所起的另外一个名字==。
     - 因为引用本身不是一个对象，所以不能定义引用的引用。
     - 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。

   - **指针本身就是一个对象**。

     - ==**因为引用不是对象，没有实际地址，所以不能定义指向引用的指针**==

     - ```c++
       //生成空指针的方法
       int *p1=nullptr;
       int *p2=0;
       //需包含cstdlib
       int *p3=NULL;
       ```

     - ==一个指针指向某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同的情况，即指针相等。==

     - `void*`是一种特殊的指针类型，**可用于存放任意对象的地址**。因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。

       ```c++
       int i =42;
       int *p;		//p是一个int型的指针
       int *&r=p;	//r是一个对指针p的引用
       
       r=&i;	//r引用了一个指针，因此给r赋值&i就是令p指向i
       *r=0;	//解引用r得到i，也就是p指向的对象，将i的值改为0
       ```

     - **面对一条比较复杂的指针或者引用的声明语句时，==从右往左阅读==有助于弄清楚它的真实含义。**

5. `const`限定符

   - 因为`const`对象一旦创建后就不能改变，所以`const`**对象必须初始化**。
   - **==默认情况下，`const`对象被设定为仅在文件内有效==，当文件中出现了多个同名的`const`变量时，其实就等同于在不同文件中分别定义了独立的变量。**
   - 某些时候有这样一种`const`变量，它的初始值不是一个常量表达式，但又确实有必要**在文件间共享**。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类`const`对象像其他(非常量)对象一样工作，也就是说，**只在一个文件中定义**`const`,而在**其他多个文件中声明并使用它**。解决的办法是，对于`const`==变量不管是声明还是定义都添加`extern`关键字==，这样只需定义一次就可以了:
     - `extern const int bufSize = fcn();`
     - `extern const int bufSize;`

6. `const`的引用

   - ==**对常量的引用**==

     - 引用的类型必须与其所引用对象的类型一致， 但是有**两个例外**。第一种例外情况就是在**==初始化常量引用==时允许用任意表达式作为初始值**，**只要该表达式的结果能转换成引用的类型即可**。尤其，==**允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式**==。

       ```c++
       double dval = 3.14;
       const int &ri=dval;
       //ri引用了一个int型的数。对ri的操作因该是整数运算，但dval却是一个双精度浮点数而非整数，因此为了确保让ri绑定到一个整数，编译器把上述代码变成了如下形式：
       const int temp = dval; //由双精度浮点数生成一个临时的整形常量
       const int &ri=temp;//让ri绑定这个临时量
       ```

     - 在这种情况下，`ri`绑定了一个**临时量**(temporary)对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。接下来探讨当`ri`不是常量时，如果执行了类似于上面的初始化过程将带来什么样的后果。**如果`ri`不是常量**，就允许对`ri`赋值，这样就会改变`ri`所引用对象的值。注意，此时绑定的对象是一个临时量而非`dval`。 程序员既然让`ri` 引用`dval`，就肯定想通过`ri`改变`dval`的值，否则干什么要给`ri`赋值呢？如此看来，既然大家基本上不会想着把引用绑定到临时量上，==**C++语言也就把这种行为归为非法**==。

   - 指针和`const`

     - **==指向常量的指针==**  `const double pi = 3.14;`
     - ==**常量指针**==必须初始化，而且一旦初始化完成，则它的值(也就是存放在指针中的那个地址)就不能再改变了。

   - ==**顶层const**==**表示指针本身是个常量**，==**底层const**==**表示指针所指的对象是一个常量**

7. `constexpr`和常量表达式

   - **常量表达式**是指值不会改变并且在***==编译过程==*就能得到计算结果的表达式**。用常量表达式初始化的`const`对象也是常量表达式。

   - 声明为`constexpr`的变量一定是一个常量，而且必须用常量表达式初始化。

   - ```c++
     constexpr int mf = 20;
     constexpr int limit = mf+1;
     constexpr int sz - size();
     ```

   - 新标准允许定义一种特殊的`constexpr`函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用`constexpr`函数去初始化`constexpr`变量了。

   - **声明`constexpr`时==用到的类型==必须有所限制**，因为这些类型一般比较简单，值也显而易见，容易得到，就把他们称为**字面值类型**。

   - 尽管指针和引用都能定义成`constexpr`, 但它们的初始值却受到严格限制。一个`constexpr`**指针的初始值必须是`nullptr`或者`0`**，或者是存储于某个固定地址中的对象。

     ```c++
     constexpr int *p=nullptr;//constexpr把它所定义的对象置为了顶层const
     
     constexpr int *np=nullptr;//np是一个指向整数的常量指针，其值为空
     int j = 0;
     constexpr int i =42;
     //i和j都必须定义在函数体之外
     
     constexpr const int *p=&i; //p是常量指针，指向整形常量i
     constexpr int *p1=&j;//p1是常量指针，指向整数j
     ```

8. 处理类型

   - 新标准规定了一种新的方法，使用==**别名声明**==`using SI = Sales_ites SI`是`Sales_item`的同义词

     - ```c++
       typedef char *pstring;
       const pstring cstr = 0; //cstr是指向char的常量指针
       const pstring *ps;		//ps是一个指针，它的对象是指向char的常量指针
       ```

     - ==const是对给定类型的修饰==

   - `auto`类型说明符C++11

     - 它让编译器替我们取分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型。**auto定义的变量必须有初始值**
     - `auto`也能在一条语句中**声明多个变量**，因为一条声明语句只能有一个基本数据类型，所以**该语句中所有变量的初始基本类型都必须一样**。
       - `auto sz = 0,pi=3.14`//错误：sz和pi的类型不一致
     - `auto`一般会**忽略**顶层`const`，同时底层`const`**则会保留**下来。
     - **希望推断出的`auto`类型是一个顶层`const`**，需要明确指出：`const auto f = ci`
     - **设置一个类型为`auto`的==引用时==**，初始值中的**顶层常量属性**仍然保留。

   - `decltype`类型指示符C++11

     - **希望从表达式的类型推断出要定义的类型，但是不想用该表达式的值初始化变量**，`decltype`它的作用是选择并返回操作数的数据类型。

       ```c++
       decltype(f()) sum = x; //sum的类型是函数f的返回类型
       //decltype处理顶层const和引用的方式与auto有些许不同
       //decltype使用的表达式是一个变量，则decltype返回该变量的类型(包括顶层const和引用在内)
       const int ci = 0,&cj=ci;
       decltype(ci) x = 0; //x的类型是const int
       decltype(cj) y = x; //y的类型是const int&，y绑定到变量x
       ```

     - **==引用从来都是作为其所指对象的同义词出现，只有用在`decltype`处是一个例外。==**

     - 如果`decltype`使用的表达式不是一个变量，则`decltype`返回表达式结果对应的类型。

       ```c++
       int i = 42,*p=&i,&r=i;
       decltype(r+0) b;//加法的结果是int，因此b是一个（未初始化的）int
       decltype(*P) c;//c是int&,必须初始化
       ```

     - 如果**表达式的内容是解引用操作**，则`decltype`**将得到引用类型**。正如我们所熟悉的那样，**解引用指针可以得到指针所指的对象，而且还能给这个对象赋值**。因此，`decltype ( *p)`的结果类型就是`int&`，而非`int`.

     - ==`decltype((varialbe))`的结果永远是引用，而`decltype(variable)`结果只有当variable本身就是一个引用时才使引用。==

     - **赋值是会产生引用的一类典型表达式**，引用的类型就是左值的类型。`decltype(a=b) d=a` 表达式`a=b`的类型是`int&`

9. 自定义数据结构

   - **类体右侧的表示结束的花括号后必须写一个分号**，这是**因为**类体后面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少；
   
   - C++11新标准规定，**可以为数据成员提供一个类内初始值**(in-class initializer)。创建对象时，**类内初始值将用于初始化数据成员**。没有**初始值的成员将被默认初始化**(参见2.2.1节，第40页)。因此当定义`sales_data`的对象时，`units_sold`和 `revenue `都将初始化为0，`bookNo`将初始化为空字符串。
   
     - ```c++
       struct Sales_data
       {
           std::string bookNo;
           unsigned units_sold = 0;
           double revenue = 0.0;
       }
       ```
   
   - 对类内初始值的限制与之前介绍的类似:或者放在花括号里，或者放在等号右边，==**记住不能使用圆括号**==。
   
   - ==**类所在的头文件的名字应与类的名字一样。**==例如`string`在名为`string`的头文件中定义。

### 字符串，向量和数组

#### 命名空间的using声明

- `using std::cin;` `using`声明，当我们使用名字`cin`时，从命名空间`std`中获取它
- **用到的每个名字都必须有自己的声明语句，而且每句话都以分号结束。**
- 位于==**头文件的代码一般来说不应该使用using声明**==。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。

#### 标准库类型string

1. `string`类型必须首先包含`string`文件。作为标准库的一部分，`string`定义在命名空间`std`中。

   | `string s1`          | 默认初始化，s1是一个空串                                    |
   | :------------------- | ----------------------------------------------------------- |
   | `string s2(s1)`      | s2是s1的副本                                                |
   | `string s2=s1`       | 等价于s2(s1)，s2是s1的副本                                  |
   | `string s3("value")` | s3是字面值"value"的副本，**除了字面值最后的那个空字符外**。 |
   | `string s3="value"`  | 等价于s3("value")，s3是字面值"value"的副本                  |
   | `string s4(n,'c')`   | 把s4初始化为由连续n个字符c组成的串                          |

   <img style="width: 1200px;height:500px" src="Image\string的操作.png">

   - 如果使用**等号初始化**一个变量，实际上执行的是==**拷贝初始化**==( copy initialization), 编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果**不使用等号**，则执行的是==**直接初始化**==( direct initialization )。
   - `string s8=string(10,'c');`
   - `cin>>s` 将`string`对象读入`s`，==**遇到空白停止**==。`string`对象会自动忽略开头的空白，并从第一个真正的字符开始读起，直到遇到下一处空白为止。
   - `getline`函数参数是**一个输入流**和一个`string`对象，函数从给定的输入流中读入内容，直到遇到换行符为止（==**读入换行符，并不存放换行符**==）`getline`返回它的流参数。
   - 大多数标准库类型都定义了几种配套的类型。这些配套类型体现了示准库类型与机器无关的特性，类型`size_type`即是其中的一种。在具体使用的时候，通过作用域操作符来表明名字`size_type`是在类`string`中定义的。
   - 如果两个`string`对象在**某些对应的位置上不一致**，则`string`对象比较的**结果**。其实是`string`对象中==**第一对相异字符比较的结果**==。
   
2. 字面值和`string`对象相加

   - 标准库允许把**字符字面值**和**字符串字面值**转换成`string`对象。当把`string`对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保**每个加法运算符**的**两侧**的运算对象至少有一个是`string`字符串。
     
   - `cctype`头文件和`ctype.h`头文件的内容是一样的，只不过从命名规范上来讲更符合C++语言的要求。特别的，在名为`cname`的头文件中定义的名字从属于命名空间`std`,而定义在名为`.h`的头文件中的则不然。
     
   - ==范围`for`语句==C++11。这种语句**遍历给定序列中每个元素**并对序列中的每个值执行某种操作

     ```c++
     for(declaration:expression)//expression部分是一个对象，用于表示一个序列，declaration部分负责定义一个变量，该变量用于访问序列中的基础元素。每次迭代declaration部分的变量都会被初始化为expression部分的下一个元素值。
         statement;
     
     string str("some string");
     for(auto c:str)
         cout<<c<<endl;
     //如果想改变string对象中的值，必须把循环变量定义成引用类型
     ```
   
   - 下标运算符`[]`接收的输入参数是`string::size_type`

#### 标准库类型 vector

1. **模板本身不是类或函数**，相反可以将**模板看作为编译器生成类或函数编写的一份说明**。编译器根据模板创建类或函数的过程称为==**实例化**==(instantiation)，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。
   
   - 在**早期版本的C++标准中**如果`vector`的元素还是`vector` (或者其他模板类型),则其**定义的形式与现在的C++11新标准略有不同**。过去，必须在外层vector对象的右尖括号和其元素类型之间==**添加一个空格**==，如应该写成`vector<vector<int> >`而非`vector<vector<int>>`。
   
2. 初始化`vector`对象

   <img style="width: 900px;height:300px" src="Image\初始化vector.png">

   - 其二，如果**提供的是一个类内初始值**(参见2.6.1节，第64页)，则**只能使用拷贝初始化**或**使用花括号的形式初始化**。第三种特殊的要求是，如果**提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化**，而不能放在圆括号里。

   - ==**值初始化**==：通常情况下，可以只提供`vector`对象容纳的**元素数量**而不用略去初始值。此时库会创建一个**值初始化的**( value-initialized) **元素初值**，并把它赋给容器中的所有元素。==**这个初值由vector对象中元素的类型决定**==。内置类型设置为0，类类型执行默认初始化。

     - 对这种初始化的方式有==**两个特殊限制**==:其一,**有些类要求必须明确地提供初始值**(参见2.2.1节，第40页),如果`vector`对象中元素的类型不支持默认初始化，我们就必须提供初始的元素值。对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。

   - ==**列表初始值还是元素数量**==

     - 用一个**整数来初始化**`vector<int>`时，**整数的含义**可能是`vector`对象的**容量**也可能是**元素的值**。类似的，用**两个整数来初始化**`vector<int>`时，这两个整数**可能一个是**`vector`对象的**容量**，**另一个是元素的初值**，也可能它们是容量为2`vector`对象中**两个元素的初值**。通过使用花括号或圆括号可以区分上述这些含义

       - ==**圆括号，可以说提供的值是用来构造`vector`对象的**==
       - ==**花括号，可以表述成我们想列表初始化`vector`对象**==

     - 另一方面，如果**初始化时使用了花括号的形式**但是==**提供的值又不能用来列表初始化**==，就要考虑用这样的值来**构造vector对象**了。例如，要想列表初始化一个含有string对象的vector对象，应该提供能赋给string对象的初值。此时不难区分到底是要**列表初始化vector对象的元素**还是用**给定的容量值来构造vector对象**。

       - 提供的值是用来初始化vector的还是vector的元素

         ```c++
         vector<string> v{10};//10被用来构造vector对象，10个字符串被值初始化。
         vector<int> v2{10};//列表初始化，v2有一个int值为10
         ```

   - 如果循环体内部包含有向`vector`对象添加元素的语句，则不能使用范围for循环。==**范围for语句体内不应该改变其所遍历序列的大小**==。

   - <img style="width: 900px;height:300px" src="Image\vector支持的操作.png">

   - 使用vector的`size_type`，`vector<int>::size_type`

#### 迭代器介绍

==所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。==，如果容器为空，则`begin`和`end`返回的是同一个迭代器，都是**尾后迭代器**。

<img style="width: 900px;height:200px" src="Image\标准容器迭代器的运算符.png">

1. 迭代器类型

   - `vector<int>::iterator it; vector<int>::const_iterator it2`
     - `it`能读写，而`it2`只能读
   - `cbegin`和`cend`C++11返回`const_iterator`
   - ==**限制**==：任何一种可能改变`vector`对象容量的操作，比如`push_back`，都会使该`vector`对象的迭代器失效。
   
2. 迭代器运算

   <img style="width: 900px;height:400px" src="Image\vector和string迭代器支持的运算.png">

   - 迭代器相减是两个迭代器的距离。==**类型名为`difference_type`的带符号整形数**==。

#### 数组

1. 编译的时候维度因该是以知的，维度必须是**一个常量表达式**。定义数组的时候必须指定数组的类型，不允许用`auto`**关键字由初始值的列表推断类型**。

   - ```c++
     int (*Parray)[10]=&arr;
     int (&arrRef)[10]=arr;//引用一个含有10个整数的数组
     					  //类型修饰符从右向左依次绑定
     unsigned scores[11]={};//全部初始化为0
     ```

   - ==**就数组而言**==，由**内向外阅读**助我们更好地理解`Parray`的含义:首先是圆括号括起来的部分，`*Parray` 意味着`Parray`是个指针，接下来观察右边，可知道`Parray`是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是`int`。这样最终的含义就明白无误了。

2. 使用数组下标的时候，通常将其定义为**size_t**类型，`size_t`是一种机器相关的的无符号类型。==**`cstddef`头文件**==定义了`size_t`类型。

   - 在很多用到**数组名**字的地方，编译器都会自动地将其替换为一个**指向数组首元素的指针**。
   - `auto p(scores);`p的类型是`int*`
   - `decltype(scores) ia;` **此关键字上述转化不会发生**，返回的类型是10个整数构成的数组。

3. 标准库函数`begin()`和`end()`

   - `begin`函数返回指向首元素的指针，`end`函数返回尾元素下一个位置的指针。**定义在`iterator`头文件中**
   - 两个指针相减的结果的类型是一种名为`ptrdiff_ t`的标准库类型，`ptrdiff_t`也是一种==**定义在`cstddef`头文件中**==的机器相关的类型。
   - **==标准库类型限定使用的下标必须是无符号类型==，而内置的下标运算无此要求**

4. 与旧代码的接口

   - `string`对象的复合**赋值**运算中允许使用**以空字符结束的字符数组**作为右侧的运算对象。
   - `c_str`函数返回的是一个c风格的字符串，**指针的类型是**`const char*`
   - 使用数组初始化`vector`对象：`vector<int> ivec(begin(arr),end(arr));`

#### 多维数组

```c++
int ia[3][4] = 
{
    {0,1,2,3},
    {4,5,6,7},
    {8,9,10,11}
};
//没有标识每行的花括号，与之前的初始化语句是等价的
int ia[3][4]={0,1,2,3,4,5,6,7,8,9,10,11};
for(auto row:ia)
{//编译器初始化row时会自动将这些数组形式的元素转换为指向该数组内首元素的指针
    for(auto col:row)
    {//这样得到的row的类型就是int*,显然内层的循环就不合法了。
        
    }
}
```

1. ==**范围for语句处理多维数组时，除了最内层的循环外，其它所有的循环的控制变量都应该是引用类型。**==

   ```c++
   using int_array = int[4];
   typedef int int_array[4];
   int_array *p = ia;//int_array只是类型，需要用*表述是4个元素的指针
   ```

### 表达式

#### 基础

**同一组内**的运算符**优先级相同**，组的位置越**靠前**组内的运算符**优先级越高**。

<img style="width: 1200px;height:700px" src="Image\运算符优先级表1.png">

<img style="width: 1200px;height:1000px" src="Image\运算符优先级表2.png">

- 函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。
- 一般的二元运算符都要求两个**运算对象相同**，但是很多时候即使运算对象的类型不行同也没有关系，只要他们能被**转换成同一种类型**。
- 使用关键字`decltype`的时候，左值和右值也有所不同。如果==**表达式的求值结果是左值**==，`decltype` **作用于该表达式**(不是变量)得到一个引用类型。
- **优先级**于**结合率**
  - 算术运算符满足左结合率，如果**优先级相同**，将按照从**左向右**的顺序**组合运算对象**
  - **优先级规定了运算对象的组合方式**，**但是没有说明运算对象按照什么顺序求值**。在大多数情况下，==**不会明确指定求值的顺序**==。`int i = f1()*f2();`
  - **求值顺序**、**优先级**、**结合律**
    - **运算对象的求值顺序与优先级和结合律无关**，在一条形如f()+g()*h()+j()的表达式中:
      - **优先级规定**，g()的返回值和h()的返回值相乘。
      - **结合律规定**，f()的返回值先与g()和h()的乘积相加，所得结果再与j ()的返回值相加。
      - 对于这些函数的调用顺序没有明确规定。
- 括号无视优先级与结合律

#### 算术运算符

1. 布尔类型的==**运算对象**==将被提升为`int`类型

#### 逻辑和关系运算符

1. 逻辑运算符和关系运算符的**返回值都是布尔类型**
2. 逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，**当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值**。

#### 赋值运算符

1. ==**赋值运算的结果是它的左侧运算对象**==，并且是一个左值。
2. **赋值运算优先级较低**
3. 使用复合运算符只求值一次，使用普通的运算符则求值两次。这两次包括:一 次是作为右边子表达式的一部分求值，另一次是作为赋值运算的左侧运算对象求值。其实在很多地方，**这种区别除了对程序性能有些许影响外几乎可以忽略不计**。

#### 递增和递减运算符

1. 前置版本，这种形式的运算符首先将运算对象加1 (或减1)，然后将改变后的对象作为求值结果。**后置版本**也会将运算对象加1 (或减1)，但是**求值结果是运算对象改变之前那个值的==副本==**。

#### 成员访问运算符

#### 条件运算符

1. 条件运算符`?:`允许我们把简单的if-else逻辑嵌入到单个表达式中
   - 当条件表达符的**==两个表达式都是左值或者能转换成同一种左值类型时==**，**运算的结果是左值**：否则运算的结果是右值。
   - 条件运算符的优先级非常底。

#### 位运算符

- 如果运算对象是**带符号**的且**它的值为负**，那么位运算符如何处理运算符对象的==**符号位依赖于机器**==。而且此时的左移操作可能会改变符号位的值，因此是一种未定义的行为。

- 这两种运算符的内置含义是对其**运算对象执行基于二进制位的移动操作**，首先令左侧运算对象的内容**按照右侧运算对象的要求移动指定位数**，然后将经过移动的(可能还进行了提升)左侧运算对象的==**拷贝作为求值结果**==。其中，==**右侧的运算对象一定不能为负**==，而且值必须严格小于结果的位数，否则就会产生未定义的行为。二进制位或者向左移(<<)或者向右移(>>)，移出边界之外的位就被舍弃掉了。

- `>>`如果该运算对象是**带符号类型**，在左侧插入带符号位的副本或者值位0的二进制位，==**如何选择要视具体环境而定。**==
- `char`为运算对象时，`char`会提升为`int`
- `^`**位异或**运算符**有且只有一个1**结果为1，否则为0。

#### `sizeof`运算符

- `sizeof`右结合律，**所得的值是一个==size_t==**类型。`sizeof(type)`或`sizeof expr`，`sizeof`==**并不实际计算其运算对象的值**==
- 对`char`或者类型为`char`的表达式执行`sizeof`运算，结果得1。
- 对**引用类型执行**`sizeof`运算得到**被引用对象**所占空间的大小。
- 对**指针执行**`sizeof`运算得到**指针本身所占空间**的大小。
- 对**解引用指针执行**`sizeof`运算得到**指针指向的对象所占空间的大小**，**==指针不需有效==**。
- **对数组执行**`sizeof`运算**得到整个数组所占空间的大小**，等价于对数组中所有的元素各执行一次`sizeof`运算并将所得结果求和。注意，`sizeof`==**运算不会把数组转换成指针来处理。**==
- 对`string`对象或`vector`对象执行`sizeof`运算**只返回该类型固定部分的大小**，不会计算对象中的元素占用了多少空间。

#### 逗号运算符

- 对于逗号运算符来说，**首先对左侧的表达式求值，然后将求值结果丢弃掉**。**逗号运算符==真正的结果==是右侧表达式的值**。如果右侧运算对象是左值，那么最终的求值结果也是左值。
  - `somevalue?++x,++y:--x,--y`实际上等于`(somevalue?++x,++y:--x),--y`首先判断`someValue`是否为真，如果为真，依次执行++x和++y，==**最后执行--y**==; 如果为假，执行--x和--y。

#### 类型转换

- 算术转换

  - **运算符**的**运算对象**将转换成**最宽的类型**。当表达式中**既有浮点类型**也**有整数类型**时，整形值将转**换成相应的浮点类型**。
  - **整形提升**负责把小整数类型转换成较大的整数类型，`bool,char,signed char,unsigned char,short,unsigned short`只要**他们所有可能的值都能存在`int`里**，他们就会**提升为**`int`类型。**否则提升为**`unsigned int`**类型**。
  - 较大的`char`类型(`wchar_ t.char16_ t.char32_ t `)提升成`int、unsigned int、long、unsigned long、long long和unsigned long long`中**最小的一种类型**，前提是**转换后的类型要能容纳原类型所有可能的值**。

- 无符号类型的运算对象

  - 类型不一致，这些运算对象将转换成同一种类型。但是如果**某个运算对象的类型是无符号类型**，那么**转换的结果**就要**依赖于**机器中各个整数类型的**相对大小**了
  - 如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且其中的**无符号类型不小于带符号类型**，那么**带符号的运算对象转换成无符号**的。例如，假设两个类型分别是`unsigned int`和`int`，则`int`类型的运算对象转换成`unsigned int`类型。需要注意的是，如果`int`型的==**值恰好为负值**==，其结果将以2.1.2节(第32页)介绍的方法转换，并带来该节描述的所有副作用。
  - 剩下的一种情况是**带符号类型大于无符号类型**，此时转换的结果依赖于机器。如果**无符号类型的所有值**都**能存在该带符号类型中**，则**无符号类型的运算对象转换成带符号类型**。如果不能，那么带符号类型的运算对象转换成无符号类型。例如，如果两个运算对象的类型分别是`long`和`unsigned int`,并且`int`和`long`的大小相同，则`long`类型的运算对象转换成`unsigned int` 类型;如果`long`类型占用的空间比`int`更多，则`unsigned int`类型的运算对象转换成`long`类型。

- 其它隐式类型钻换

  - 当==**数组**==被用作`decltype`关键字的参数，或==**者作为取地址符(&)**==、`sizeof` 及`typeid`(第19.2.2 节，732页将介绍)等运算符的运算对象时，**数组不会自动转换成指向数组首元素的指针**。
  - ==**类类型定义的转换**==：类类型能定义由编译器自动执行的转换，不过**编译器每次只能执行一种类类型的转换**。在7.5.4节(第263页)中我们将看到一个例子，如果同时提出多个转换请求，这些请求将被拒绝。

- 显示转换

  - `cast-name<type>(expression)` type是转换的目标类型，expression是要转换的值，cast-name是`static_cast，dynamic_cast，const_cast，reinterpret_cast`中的一种，cast-name指定了**执行的是哪种转换**

  - `static_cast`

    - 任何具有明确定义的类型转换，只要==**不包含底层**==`const`,都可以使用static_ cast.
      - “**有明确定义的类型转换**”指的是那些在语言规范中明确规定可以进行的类型转换。这意味着这些类型转换是安全的、合法的，并且编译器知道如何正确地执行它们。
    - 当需要把**一个较大的算术类型赋值给较小的类型时**，static_ cast非常有用。此时，强制类型转换告诉程序的读者和编译器:我们知道并且不在乎潜在的精度损失。一般来说，如果**编译器发现一个较大的算术类型试图赋值给较小的类型，就会给出警告信息**;但是当我们执行了显式的类型转换后，警告信息就会被关闭了。

  - `const_cast`

    - `const_cast`==**只能改变运算对象的底层const**==

    - ```c++
      const char *pc;
      char *p = const_cast<char*>(pc);
      //正确：但是通过p写值是未定义的行为。
      ```

    - ==**只有`const_cast`能改变表达式的常量属性**==，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。同样的，也不能用`const_ cast`改变表达式的类型。

  - `reinterpret_cast`

    - ==**通常为运算对象的位模式提供较低层次上的重新解释**==。

  - ==**避免强制类型转换**==

    - 强制类型转换干扰了正常的类型检查(参见2.2.2节，第42页)，因此我们强烈建议程序员避免使用强制类型转换。这个建议对于`reinterpret_cast`尤其适用，因为此类类型转换总是充满了风险。在有重载函数的上下文中使用`const_cast`无可厚非，关于这一点将在6.4节(第208页)中详细介绍;但是在其他情况下使用`const_cast`也就意味着程序存在某种设计缺陷。其他强制类型转换，比如`static_cast`和`dynamic_ cast`,都不应该频繁使用。 每次书写了一条强制类型转换语句，都应该反复斟酌能否以其他方式实现相同的目标。就算实在无法避免，也应该尽量限制类型转换值的作用域，并且记录对相关类型的所有假定，这样可以减少错误发生的机会。

  - 旧式的强制类型钻换

    - type(expr) 函数式的强制类型转换
    - (type) expr C语言风格的强制类型转换

### 语句

#### 简单语句

- 如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使==**用空语句**==。`;`

#### 语句作用域

- 定义在**控制结构当中的变量只在相应语句的内部可见**。

#### 条件语句

- `else`于**离他最近的尚未匹配**的`if`匹配，从而消除了程序的二义性。

- `case`标签==**必须是整形常量表达式**==，任何两个`case`标签的值不能相同

- ```c++
  switch(ch)
  {//写在一行里，强调这些case代表的是某个范围内的值
      case 'a': case'e': case'i': case'o': case'u':
         	++vowelcnt;
          break;
  }
  ```

- `switch`内部的变量定义

  - ==**不允许跨过变量的初始化语句直接跳到转到该变量作用域的另一个位置。**==
  - 如果某个`case`分支定义并初始化一个变量，我们因该把变量定义在块内。

#### 迭代语句

- `for`语句省略`condition`的效果等价于在条件部分写了一个`true`。

- 范围`for`语句每次迭代都会重新定义循坏控制变量，并将其初始化成序列中的下一个值。

- ```c++
  //范围for语句与之等价的传统for语句
  for(auto beg = v.begin(),end = v.end();beg!=end;++beg)
  {
      auto &r = *beg;
      r*=2;
  }
  //范围for中预存了begin和end的值，一旦在序列中添加(删除)元素，预存的值可能失效。
  ```

- `do while`语句

  - ==**`condition`使用的变量必须定义在循环体之外**==。
  - 先执行语句或块，后判断条件，所以不允许在条件部分定义变量。

#### 跳转语句

- `continue`对于`while`或者`do while`来说**继续判断条件的值**，对于`for`循环来说，==**继续执行`for`语句头的`expression`**==`for(;;expression)`
- ==**标签标示符独立于变量或其他标示符的名字**==，因此，标签标示符可以和程序中其他实体的标示符使用同一个名字而不会相互干扰。`goto`==**语句和控制权转向的那条带标签的语句必须位于同一个函数之内**==。

#### try语句块和异常处理

- 当程序的**某部分检测到一个它无法处理的问题**时，需要用到异常处理。此时，**检测出问题的部分应该发出某种信号以表明程序遇到了故障**，无法继续下去了，而且**信号的发出方无须知道故障将在何处得到解决**。一旦发出异常信号，检测出问题的部分也就完成了任务。如果程序中**含有可能引发异常的代码**，那么**通常也会有专门的代码处理问题**。例如，如果程序的问题是输入无效，则异常处理部分可能会要求用户重新输入正确的数据;如果丢失了数据库连接，会发出报警信息。

- ==**抛出异常将终止当前的函数**==，并把控制权转移给能处理该异常的代码。

  ```c++
  if(item1.isbn()!=item2.isbn())
  {
      throw runtime_error("Data must refer to same ISBN");
  }
  cout<<item1+item2<<endl;
  ```

  - `runtime_error`是标准异常类型的一种，==定义在==`stdexcept`==头文件==中，我们必须初始化`runtime_ error`的对象，方式是**给它提供一个string对象或者一个C风格的字符串**。
  - `throw`后紧跟一个表达式，==**表达式的类型就要抛出异常的类型**==。

  ```c++
  while (cin>>item1>>item2)
  {
      try{
          //执行两个Sales_item对象的代码
          //如果添加失败，代码抛出一个runtime_error异常
      }catch(runtime_error err){
          cout<<err.what()<<endl;
      }
  }
  ```

  - 跟在`try`块之后的**是一个或多个`catch`子句**。`catch`子句包括三部分:关键字`catch`、**括号内一个(可能未命名的)对象的声明**(称作异常声明，exception declaration)以及一个块。当选中了某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch**子句之后的那条语句继续执行**。
  - try**语句块中的program-statements 组成程序的正常逻辑**，像其他任何块一样，program-statements可以有包括声明在内的任意C++语句。一如往常， ==**try语句块内声明的变量在块外部无法访问，特别是在catch子句内也无法访问。**==
  - 寻找处理代码的过程与函数调用链刚好**相反**。当**异常被抛出时**，**首先搜索抛出该异常的函数。如果没找到匹配的`catch`子句，终止该函数**，**并在调用该函数的函数中继续寻找。如果还是没有找到匹配的`catch`子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推**，沿着程序的执行路径逐层回退，直到找到适当类型的`catch`子句为止。如果**最终还是没能找到任何匹配的`catch`子句，程序转到名为`terminate`的标准库函数**。该函数的行为与系统有关，一般情况下， **执行该函数将导致程序非正常退出**。
  - <img style="width: 1000px;height:400px" src="Image\stdexcept.png">
  - `exception`**头文件**定义了最通用的异常类`exception`，它只报告异常的发送，不提供任何额外信息。
  - `new`**头文件**定义了`bad_alloc`异常类型，这种类型将在12.1.2节(第407页)详细介绍。
  - `type_info`**头文件**定义了`bad_cast`异常类型，这种类型将在19.2节(第731而)详细介绍
    - 我们只能以==**默认初始化(**==参见2.2.1节，第40页)的方式初始化`exception`.`bad_alloc` 和`bad_cast` 对象，**不允许为这些对象提供初始值**。

### 函数

#### 函数基础

- ==**实参是形参的初始值**==，第一个实参初始化第一个形参**。尽管实参于形参存在对应关系，但是并没有规定==实参的*求值*顺序==。**
  - 为了于`C`兼容，也可使用关键字`void`表示函数没有形参。
  - ==**函数的返回值不能是数组类型或函数类型**==。

- 函数的名字也必须在使用之前声明，**如果一个函数永远不会被我们用到，那么它可以只有声明没有定义**。
  - 因为函数的声明不包含函数体，所以也就无须形参的名字。事实上，在函数的声明中经常省略形参的名字。尽管如此，写上形参的名字还是有用处的，它可以帮助使用者更好地理解函数的功能
  - 定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。

#### 参数传递

- 当用**实参初始化形参**时==**会忽略掉顶层**==`const`，当形参有顶层`const`时，传给它常量对象或者非常量对象都是可以的。

  - 使用**非常量引用会极大地限制函数所能接受的实参类型**，例如：我们不能把`const`对象，字面值或者需要类型转换的对象传递给普通的引用形参。

- 数组形参

  - ```c++
    //尽管形式不同，但这三个print函数是等价的
    void print(const int *);
    void print(const int []);
    void print(const int [10]);//这里的维度表示我们期望数组含有多少元素，实际不一定。
    ```

- 含有可变形参的函数

  - 如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用`initializer_ list` 类型的形参。
    
    <img style="width: 1000px;height:400px" src="Image\initializer_list.png">
    
    ```c++
    //expected和actual是string对象
    if(expected !=actual)
    {
        error_msg({"functionX",expected,actual});
    }
    else
    {
        error_msg({"functionX","okey"});
    }
    ```
    
  - 如果想向`initializer list`形参中传递一个值的序列，则==**必须把序列放在一对花括号内**==
  
- 省略符形参

  - `stdarg.h`可变参数宏

#### 返回类型和return语句

- 返回`void`的函数不要求非得有`return`语句，因为在这类函数的**最后一句后面会隐式地执行return**。

- 有返回值函数

  - `return`语句返回值的类型**必须与函数的返回类型**相同，或者**能隐式地转换**成函数的返回型。
  - 函数的返回类型决定函数调用是否是左值。调用**一个返回引用的函数**得到**左值**，其他返回类型得到右值。**返回常量引用**不能给调用**结果**赋值。

- ==**列表初始化返回值**==

  - **C++11新标准规定**，函数可以**返回花括号包围的值的列表**。此处的列表也用来对表示**函数返回的临时量进行初始化**。如果**列表为空**，临时**执行值初始化**否则，返回的值由函数的返回类型决定。
  - 如果函数返回的是内置类型，则**花括号包围的列表**最多包含**一个值**，而且该值所占空间不应该大于目标类型的空间(参见2.2.1 节，第39页)。如果函数返回的是类类型，由类本身定义初始值如何使用。
  - ==**main函数没有返回值，编译器将隐式地插入一条返回0地return语句。**==

- ==**返回数组指针**==

  - **因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用**。

  - 声明一个返回数组指针的函数

    - 如果我们想定义一个返回数组指针的函数，则==**数组的维度必须跟在函数名字之后**==。然而，==**函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度**==。
      - `Type (*function(parameter_list))[dimention]`

  - **==使用尾置返回类型==**

    - C++11，**任何函数的定义都能使用尾置返回**，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。
      - `auto func(int i)->int(*)[10];`

  - 使用`decltype`

    - 如果我们知道函数返回的指针将指向哪个数组，就可以使用`decltype`关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数`i`的不同指向两个已知数组中的某一个

      ```c++
      int add[]={1,3,5,7,9};
      int even[]={2,4,6,8};
      decltype(odd)* arrPtr(int i)
      {
          return (i%2)?&odd:&even;
      }
      //decltype并不把数组类型转换成对应的指针。
      ```

      

#### 函数重载

- 不允许两个函数除了返回类型外其它所有的要素都相同。

  - 一个拥有**顶层`const`的形参无法和另一个没有顶层`const`的形参区分**开来。

    ```c++
    Record loopup(Phone*);
    Record loopup(Phone*const);
    ```

  - 如果形参是某种类型的**指针**或**引用**，则通过**区分其指向的是==常量对象还是非常量对象==可以实现函数重载**，此时的`const`是底层的。

    ```c++
    Record loopuo(Account*);
    Record loopup(const Account*);
    ```

    - 传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数。

  - 有多个函数可以匹配，但是每一个都不是明显的最佳选择，此时将发送错误称为**二义性调用**。

- 如果在内层作用域中声明名字，他将隐藏外层作用域中声明的同名实体。==**在不同的作用域中无法重载函数名**。==

  - **在局部作用于中声明函数不是一个好的选择。**
  - ==**C++中，名字查找发生在类型检查之前**==

#### 特殊用途语言特性

- 默认实参

  - 一旦某个形参被赋予了默认值，他后面的所有形参都必须有默认值。

  - 函数调用时实参按位置解析。

  - **尽量让不怎么使用默认值得形参出现在前面，而让那些经常使用默认值得形参出现在后面。**

  - **==在给定得作用域中一个形参只能被赋予一次默认实参==**

    ```c++
    string screen(sz,sz,char = ' ');
    string screen(sz,sz,char = '*');//错误：重复声明
    ```

  - **==局部变量不能作为默认实参，除此之外，只要表达式得类型能转换成形参所需得类型，该表达式就能作为默认实参。==**

    ```c++
    //wd,def和ht得声明必须出现在函数之外
    sz wd = 80;	//sz是关键字别名
    char def = ' ';
    sz ht();
    string screen(sz = ht(),sz = wd,char = def);
    //用作默认实参的名字在函数声明所在得作用域内解析
    //而这些名字得求值过程发生在函数调用时。
    ```

- 内联函数和`constexpr`函数

  - 内联机制用于优化规模较小，流程直接，频繁调用得函数。很多编译器都不支持内联递归函数。
  - `constexpr`函数：函数得**==返回类型==及所有==形参的类型==都得是字面值类型**，且**函数体中必须==有且只有==一条`return`语句**。
    - `constexpr`函数被隐式地定义为内联函数。
    - `constexpr`函数体内也可以包含其它语句，只要这些语句在==**运行时**==不执行任何操作就行。
    - `constexpr`函数不一定返回常量表达式。
  - 内联函数或者`constexpr`函数通常定义在头文件中。
  - 调试帮助`cassert`
    - `CC -D NDEBUT main.c` 这条命令的作用等价于在`main.c`的文件的一开始写`#define NDEBUG`

#### 函数匹配

- 实参类型转换
  1. 精确匹配
     - 实参类型和形参类型相同。
     - 实参从数组类型或函数类型转换成对应的指针类型
     - 向实参**添加项层**`const`或者从实参中**删除**顶层`const`.
  2. 通过`const`==**转换**==实现的匹配(参见4.11.2 节，第143页)。
  3. 通过**类型提**升实现的匹配(参见4.11.1 节，第142页)。
  4. 通过算术类型转换或指针转换实现的匹配。
     - **所有算术类型转换的级别都一样**。
       - `int`向`unsigned int`的转换并不比从`int`向`double`的转换级别高。
  5. 通过类类型转换实现的匹配(参见14.9节，第514页，将详细介绍这种转换)。

#### 函数指针

- 把函数名作为一个值使用时，函数自动地转换成指针。

  - `pf = lengthCompare或pf=&lengthCompare`
  - `pf("hello","goodbye")或(*pf)("hello","goodbye")`等价的方式。
  - 函数指针类型必须与重载函数中的某一个精确匹配

- 函数指针形参

  ```c++
  void useBigger(const string&s1,const string&s2
                 ,bool pf(const string&,const string&));//自动地转换成指向函数的指针
  
  void useBigger(const string&s1,const string&s2
                 ,bool (*pf)(const string&,const string&));//显示地将形参定义成指向函数的指针
  
  typedef bool Func(const string&,const string*);
  typedef decltype(lengthCompare) Func2;//Func和Func2是函数类型
  
  typedef bool (*FuncP)(const string&,const string&);
  typedef decltype(lengthCompare)*FuncP2//指向函数的指针
  ```

- 返回**指向函数的指针**

  - ==**必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。**==

    ```c++
    using F = int(int*,int);//F是函数类型，不是指针
    using PF = int(*)(int*,int);//PF是指针类型
    
    auto f1(int)->int(*)(int*,int);
    ```


### 类

#### 定义抽象数据类型

- 定义在类内的函数是隐式的`inline`函数

- `this指针`
  - 成员函数通过一个名为`this`的额外的隐式参数来访问调用它的那个对象。当我们**调用一个成员函数**时，**用请求该函数的对象地址初始化this**。
  - 任何对类成员的直接访问都被看做`this`的隐式引用
  - **尽管`this`是隐式的，但它仍然需要遵循初始化规则。**
  
- ==**const成员函数**==
  - 成员函数的参数列表之后的`const`的关键字是==**修改隐式**`this`**指针**==的类型。
  - 默认情况下，`this`的类型是**指向类类型非常量版本**的常量指针。
    - 不能把`this`绑定到一个常量对象上，这使我们==**不能在一个常量对象上调用普通的成员函数**==。
  - 允许把`const`关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的`const`表示`this`**是一个指向常量的指针**。像这样使用`const`的成员函数被称作**常量成员函数**(const member function)。
  - **常量对象，以及常量对象的引用或指针都只能调用常量成员函数。**
  - **==一个const成员函数如果以引用的形式返回`*this`，那么它的返回类型将是常量引用。==**
  
- 类作用域和成员函数
  - **编译器分两步处理类**:首先==**编译成员的声明**==，==然后才轮到成员函数体==(如果有的话)。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。
  - **如果成员被声明成常量成员函数，那么它的==定义也必须==在参数列表后明确指定`const`属性**。同时，类外部定义的成员的名字**必须包含它所属的类名**
  
  - **因为I0类属于不能被拷贝的类型**，因此我们只能通过引用来传递它们(参见6.2.2节，第188页)。而且，因为读取和写入的操作会改变流的内容，所以两个函数接受的都是普通引用，而非对常量的引用。
  
- 构造函数

  - ==**构造函数不能被声明成`const`的**==(参见7.1.2节，第231页)。当我们创建类的一个`const`对象时，**直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。**因此，构造函数在`const`对象的构造过程中可以向其写值。
  - 如果我们的==**类没有显示地定义构造函数**==，那么**编译器就会为我们隐式地定义一默认构造函数**。编译器创建的构造函数又被称为**合成的默认构造函数**。对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员:
    - 如果**存在类内的初始值**(参见2.6.1节，第64页)，**用它来初始化成员**。
    - **否则，默认初始化(参见2.2.1节，第40页)该成员。**
  - ==**编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数**==。一但我们定义了一些其他的构造函数，那么除非我们再定义个默认的构造函数，否则类将没有默认构造函数
  - 有时候编译器不能为某些类合成默认的构造函数。例如，如果类中**包含一个其他类类型的成员且这个成员的类型没有默认构造函数**，那么编译器将无法初始化该成员。
  - 在`C++11`新标准中，如果**我们需要默认的行为，那么可以通过在参数列表后面写上= default来要求编译器生成构造函数**。其中，= default既可以和声明一起出现在类的内部。也可作为定义出现在类的外部。
  - **构造函数初始值列表**
    - 构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来（**或在花括号内的**）成员初始值。
    - **当某个数据成员被构造函数初始值列表忽略时，它将以于==合成默认构造函数相同的方式隐式初始化。==**
  
- 拷贝，赋值和析构

  - 不主动定义这些操作，编译器将替我们合成他们，一般来说，编译器生成的版本将对对象的每个成员拷贝，赋值和销毁。


#### 访问控制于封装

- 我们可以使用`class`和`struct`这两个关键字中的任何一个定义类，唯一的一点区别是，`struct`和`class`的默认访问权限不太一样。
- 友元
  - 把一个函数作为它的友元，只需要添加一条以`friend`**关键字开始的函数声明**语句即可。
  - ==**友元的声明仅仅指明了访问的权限，而非一个通常意义上的函数声明**==
    - ==**如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外专门对函数进行一次声明（这个声明是函数的定义，在类的外部）。**==
  - 我们可以在类的内部把`inline`作为声明的一部分显式地声明成员函数，同样的，也能在类的外部用`inline`关键字修饰函数的定义。
  - 虽然我们无须在声明和定义的地方同时说明`1inline`,但这么做其实是合法的。不过，**最好只在类外部定义的地方说明inline**。
  - 和我们在头文件中定义`inline`函数的原因一样**inline成员函数也应该与相应的类定义在同一个头文件中**。

#### 类的其它特性

- ==**可变数据成员**==
  
  - 我们希望能够修改类的某个数据成员，即使在一个`const`**成员函数==内==**。
    - `mutable`关键字
    - `mutable size_t access_ctr`即使在一个`const`对象内也能被修改
    - ==**当一个成员调用另一个成员时，this指针在其中隐式地传递。**==
  
- ==**类类型**==
  
  - `struct ClassName myClass`继承C语言，在C++中合法
  - 我们也能**仅仅声明类而暂时不定义它**
    - `class Screen;`
    - 这种声明有时被称作**前向声明**( forward declaration)， ==**它向程序中引入了名字Screen并且指明Screen是一种类类型**==。
    - 对于类型Screen来说，在==**它声明之后定义之前**==是一个不完全类型( incomplete type)，也就是说，此时我们已知Screen是一个类类型，但是不清楚它到底包含哪些成员。
    - ==**不完全类型只能在非常有限的情景下使用**:==
      - 可以定义指向这种类型的指针或引用，
      - 也可以声明(*==**但是不能定义**==*)以不完全类型作为参数或者返回类型的函数。
    - 在7.6节(第268页)中我们将描述一种例外的情况：直到**类被定义之后**数据成员才能被声明成这种类类型。换句话说，我们必须首先完成类的定义，然后编译器才能知道存储该数据成员需要多少空间。因为**只有当类全部完成后类才算被定义**，所以一个类的成员类型不能是该类自己。然而，**一旦一个类的名字出现后，它就被认为是声明过了(但尚未定义)，因此类允许句含指向它自身类型的引用或指针。**
  
- 友元再探
  - 类还可以把其**他的类定义成友元**，也可以把**其他类(之前已定义过的)的成员函数定义成友元**。此外，**==友元函数能定义在类的内部==，这样的函数是隐式内联的**。
  
  - 令成员函数作为友元
    - `friend void Window_mgr::clear(ScreenIndex);`
    
  - 如果一个类想把一组重载函数声明成它的友元，它**需要对这组函数中的==每一个分==别声明**。
  
  - ==**友元声明和作用域**==
  
    - **类**和**非成员函数**的**声明**不是必须在它们的**友元声明之前**。当**一个名字第一次出现在一个友元声明中**时，我们**隐式地假定该名字在==当前作用域中==是可见的**。然而，友元本身不一定真的声明在当前作用域中(参见7.2.1节，第241页)。甚至就算在类的内部定义该函数，我们也必须在==**类的外部提供相应的声明**==从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的。
  
      ```c++
      struct X
      {
          friend void f(){}
          X(){f();}			//错误：f还没有被声明
          void g();
          void h();
      };
      void X::g(){return f();}//错误：f还没有被声明
      void f();				//声明那个定义在X中的函数
      void X::h(){return f();}//正确：现在f的声明在作用域中了
      ```

#### 类的作用域

- **在类的外部，成员的名字被隐藏起来了。**

  - **函数的返回类型通常出现在函数名之前**。因此当**成员函数定义在类的外部时**，**返回类型中使用的名字都位于类的作用域之外**。这时，返回类型必须指明它是哪个类的成员

    ```c++
    Window_mgr::ScreenIndex
    Window_mgr::addScreen(const Screen&s)	{}
    ```

- ==**用于类成员声明的名字查**==找

  ```c++
  typedef double Money;
  std::string bal;
  class Account
  {
  public:
     	
  	Money balance()const { return bal; }
  private:
  	Money bal;
  };
  ```

  - 当编译器看到`balance`函数的声明语句时，它将在`Account`类的**范围内**寻找对`Money`的声明。==**编译器只考虑Account中在使用Money前出现的声明**==，因为没找到匹配的成员，所以编译器会接着到`Account`的外层作用域中查找。在这个例子中,编译器会找到`Money`的t`ypedef`语句，该类型被用作`balance`函数的返回类型以及数据成员`bal`的类型。另一方面，`balance`函数体在整个类可见后才被处理，因此，该函数的`return`语句返回名为`bal`的成员，而非外层作用域的`string`对象。
  - 类中，如果==**成员使用了外层作用域中的某个名字**==，而该名字**代表一种类型**，则类不能在之后重新定义该名字。
    - 尽管重新定义类型名字是一种错误的行为，但是编译器并不为此负责。一些编译器仍将顺利通过这样的代码，而忽略代码有错的事实。

- **==成员定义中的普通块作用域的名字查找==**

  - 首先，在**成员函数内**查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。
  - 如果在**成员函数内没有找到**，则在**类内**继续查找，这时类的所有成员都可以被考虑。
  - 如果**类内也没找**到该名字的声明，在==**成员函数定义之前的作用域**==内继续查找。
    - 当==**成员定义在类的外部**==时，**名字查找**考虑名字查找的第三步不仅要考虑**类定义之前的全局作用域中声明**，还需要考虑在**成员函数定义==之前==的全局作用域中的声明**。

#### 构造函数再探

- 构造函数初始值列表

  - 如果**没有在构造函数的初始值列表中**显示地初始化成员，则该==**成员将在构造函数体之前**==执行**默认初始化**。
  - 在构造函数初始值中的每个成员只能出现一次。
  - ==**成员的初始化顺序与它们在类定义中的出现顺序一致**==：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。
  - 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。

- ==委托构造函数==

  - `Sales_data():Sales_data("",0,0){};`

- 默认构造函数

  - 默认构造函数的使用方法：`Sales_data obj`，而不是`Sales_data obj()`这将是一个函数声明
  - ==**一个类没有默认构造函数，则当编译器确实需要隐式地使用默认构造函数时，该类无法使用。所以一般情况下，都应该为类构建一个默认构造函数。**==

- 隐式的类类型转化

  - **如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的==隐式转换机制==，有时我们把这种构造函数称作转换构造函数**

  - **==只允许一步类类型转换==**

    ```c++
    Sales_data item;
    string null_book = "9-999-99999-9";
    //构造一个临时的Sales_data对象
    //该对象的units_sold和revenue等于0，bookNo等于null_book
    item.combine(null_bool);
    
    //错误:需要用户定义的两种转换:
    // (1)把“9-999-99999-9” 转换成string
    // (2)再把这个(临时的)string转换成Sales data 
    item.combine("9-999-99999-9");
    ```

  - ==**印制构造函数定义的隐式钻换**==

    - `explicit`只对一个参数的构造函数有效且**只能在类内声明**构造函数时使用`explicit`关键字。
    - **发生隐式转换的一种情况是当我们执行拷贝形式的初始化时**`=`
      - `Sales_data item2 = null_book;`

  - **==接收一个容量参数的vector构造函数是explicit的==**

- **聚合类**：C语言的struct

  - 所有成员都是`public`的
  - 没有定义任何构造函数
  - 没有类内初始值
  - 没有基类，也没有`virtual`函数

- 字面值常量类

  - 数据成员都是**==字面值==类型的聚合类**是字面值常量类。
  - 如果**一个类不是聚合类，但它复合下述要求**
    - 数据成员都必须是字面值类型。
    - 类必须至少含有一个`constexpr`构造函数。
    - 如果一个**数据成员含有类内初始值**，则**内置类型成员的初始值必须是一条常量表达**式或者如果成员**属于某种类类型**，则初始值**必须使用成员自己的constexpr构造函数**。
    - 类必须使用析构函数的默认定义，该成员负责销毁类的对象。
  - **字面值常量类**的==**构造函数**==可以是`constexpr`函数，事实上，一个字面值常量类必须至少提供一个`constexpr`构造函数。
    - `constexpr`构造函数可以声明成`=default`或删除形式。
    - `constexpr`构造函数**必须初始化所有数据成员**，初始值**或者使用`constexpr`构造函数**，**或者是一条常量表达式**。
    - `constexpr`构造函数用于**生成`constexpr`对象**以及**`constexpr`函数的参数或返回类型**:

#### 类的静态成员

- 对象中不包含任何与静态数据成员有关的数据，静态成员函数也不和任何对象绑定在一起，他们不包含`this`指针。

- 可以使用作用域运算符直接访问静态成员

- 静态成员不属于类的某个对象，但是**我们仍然可以使用类的对象，引用或者指针来访问静态成员**。

- 我们既可以在类的内部也可以在类的外部定义静态成员函数，**在类的外部定义静态成员时，==不能重复`static`关键字==**。

- 因为**静态数据成员不属于类的任何一个对象**，所以**他们并不是在创建类的对象时被定义的，这意味着他们不是由类的构造函数初始化的**。

  - **==必须在类的外部定义和初始化每个静态成员==**

    ```c++
    double Account::interestRate = initRate();
    ```

  - 类型是`double`。从==**类名开始，这条定义语句的剩余部分就都位于类的作用域之内了**==。因此,我们可以直接使用`initRate`函数。注意，虽然`initRate`是私有的，我们也能用它初始化`interestRate`。和其他成员的定义一样，`interestRate`的定义也可以访问类的私有成员。

- 我们可以为静态成员提供**`const`整数类型的==类内初始值==**。要求**静态数据成员**必须==**是字面值类型的`constexpr`，初始值必须是常量表达式。**==

- **==即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。==**

- 静态数据成员可以是不完全类型，静态数据成员的类型可以就是它所属的类类型。

- 静态成员和普通成员的另外一个区别是**我们可以使用静态成员作为默认实参**。

- ==**静态成员函数，只能访问静态成员**==

## 第二部分

### IO库

#### IO类

<img style="width: 1000px;height:400px" src="Image\IO库类型和头文件.png">

- 为了**支持使用宽字符的语言**，标准库定义了一组类型和对象来操纵`wchar_t`类型数据。宽字符版本的类型和函数的名字以一个w开始。例如`wcin`、`wcou`t和 `wcerr`是分别对应`cin`、`cout`和` cerr`的宽字符版对象。==**宽字符版**==
  - ==**`ifstream`和`istringstream`继承自`istream`。`ostream`和`ostringstream`都继承自`ostream`**==
    - 在要求使用基类型对象的地方，我们可以用继承类型的对象来代替

  - **==不能拷贝或对IO对象赋值==**

<img style="width: 1400px;height:250px" src="Image\IO库条件状态.png">

<img style="width: 1400px;height:640px" src="Image\IO库条件状态2.png">

- **由于流可能处于错误状态，因此代码通常因该在使用一个流之前检查它是否处于良好状态。**

  - ```c++
    auto old_state = cin.rdstate();//记住cin的当前状态.
    cin.clear();					//使cin有效
    process_input(cin);				//使用cin
    cin.setstate(old_state);		//将cin置为原有状态
    ```

  - `badbit`系统级错误，通常情况下，一旦`badbit`被置位，流就无法使用了。

  - `failbit`：可恢复错误，如期望读取数值却读到一个字符。

    - `is.clear(is.rdstate() & ~std::istream::failbit);`==**恢复上次io错误**==

  - **到达文件结束位置**：`eofbit`和`failbit`都会被置位。

  - 如果`badbit`、`failbit` 和`eofbit`任一个被置位，则检测流状态的条件会失败。

  - 4个`iostate`类型的`constexpr`值**表示特定的位模式**。这些值用来表示特定类型的I0条件，**可以与位运算符一起使用来一次性检测或设置多个标志位**。

- 管理输出缓冲

  - ```c++
    //flush刷新缓冲区，但不输出任何额外的字符: ends 向缓冲区插入一个空字符，然后刷新缓冲区。
    cout<<"hi!"<<flush;
    
    //unitbuf告诉流接下来的每次写操作之后都要进行flush，nounitbuf使其恢复使用正常的系统管理的缓冲区刷新机制:
    cout<<unitbuf;
    //任何输出都立刻刷新
    cout<<nounitbuf;
    ```

  - 当**一个输入流被关联到一个输出流**时，任何试图从**输入流**读取数据的操作都会先**刷新关联的输出流**。

    - 标准库将`cout`和`cin`关联在一起
    - ==`tie()`==：
      - 不带参数，返回指向输出流的指针，没有返回空指针
      - 带参数：`ostream`指针，将自己关联到`ostream`
      - `cin.tie(&cout);`
    - **==每个流同时最多关联到一个流，但多个流可以同时关联到同一个`ostream`==**

#### 文件输入输出

<img style="width: 1400px;height:500px" src="Image\fstream.png">

- 头文件`fstream`

  - `ifstream`从一个给定的文件读取数据
  - `ofstream`向一个给定的文件写入数据
  - `fstream`读写给定文件
  - 一旦一个文件流已经打开，它就保持与对应文件的关联。实际上，对一个已经打开的文件流调用`open`会失败，并会导致`failbit`被置位。随后的试图使用文件流的操作都会失败。为了将文件流关联到另外一个文件，必须首先关闭已经关联的文件。一旦文件成功关闭，我们可以打开新的文件
  - ==**当一个`fstream`对象被销毁时，`close`会自动被调用**==

- 文件模式

  <img style="width: 1400px;height:350px" src="Image\文件模式.png">

  - 只要当`out`也被设定时才可设定`trunc`模式

  -  只要`trunc`没被设定，就可以设定`app`模式。在`app`模式下，即使没有显式指定`out`模式，文件也总是以输出方式被打开。

  - 默认情况下，即使我们没有指定`trunc,` **以out模式打开的文件也会被截断**。为了==**保留以`out`模式打开的文件的内容，我们必须同时指定app模式**==，这样只会将数据追加写到文件末尾。或**者同时指定in模式，即打开文件同时进行读写操作**

  - **`fstream`关联的文件默认以`in`和`out`模式打开。**

    ```c++
    ofstream app("file2",ofstream::app);
    ofstream app2("file2",ofstream::out|ofstream::app);
    //保留被`ofstream`打开的文件中已用数据的唯一方法是显示指定app或in模式
    ```

#### string流

<img style="width: 1400px;height:300px" src="Image\stringstream.png">

- ==`sstream`头文件==：内存IO
  - `sstream`头文件中定义的类型都==**继承**==自我们已经使用过的`iostream`头文件中定义的类型。
  
  - `istringstream`从`string`读取数据，`ostringstream`向`string`写入数据，`stringstream`即可从`string`读数据也可向`string`写数据
  
    ```c++
    struct PersonInfo
    {
    	std::string name;
    	std::vector<std::string> phones;
    };	
    std::string line, word;
    std::vector<PersonInfo> people;
    std::istringstream record;
    PersonInfo info;
    while (std::getline(std::cin, line))
    	{
    		record.str(line);
    		record>>info.name;
    		while (record >> word)
    		{
    			info.phones.push_back(word);
    		}
    		people.push_back(info);
    		info.name.clear();
    		info.phones.clear();
    		record.clear();//重复使用字符串流时每次都要调用clear
    	}
    for (const auto& person : people)
    	{
    		std::cout << person.name << " ";
    		for (const auto& phone : person.phones)
    		{
    			std::cout << phone << " ";
    		}
    		std::cout << std::endl;
    	}
    ```
  
    

### 顺序容器

#### 顺序容器概述

<img style="width: 1400px;height:400px" src="Image\顺序容器.png">

<img style="width: 1200px;height:1000px" src="Image\容器操作.png">

<img style="width: 1200px;height:200px" src="Image\容器操作2.png">

#### 容器库概览

- `list<string>::vale_type，::reference，::const_reference`
  - `list`中放的元素类型

- 为了**创建一个容器为另一个容器的拷贝**，**两个容器的类型及其元素类型必须匹配**。不过，==**当传递迭代器参数来拷贝一个范围时**==，就**不要求容器类型是相同的了**。而且，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的==**元素转换**==为要初始化的容器的元素类型即可。

- `array`

  - **定义一个`array`时，除了指定元素类型，还要指定容器大小。**
  - `array<int,42> ia;`
  - 支持数组赋值

- 赋值和`swap`

  <img style="width: 1200px;height:300px" src="Image\顺序容器赋值操作.png">

  - 两个容器的交换操作：`swap`元素本事并未交换，`swap`只是交换了两个容器的内部结构。
    - 除`array`外,`swap`不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。
    - **元素不会被移动的事实意味着**，除`string `外，**指向容器的迭代器、引用和指针在swap操作之后都不会失效**。它们==**仍指向swap操作之前所指向的那些元素**==。但是，在`swap`之后，这些元素已经属于不同的容器了。

#### 顺序容器操作

<img style="width: 1200px;height:600px" src="Image\顺序容器添加元素.png">

- ==**`deque`**==和`vector`一样提供随机访问元素的能力。

- 如果我们**传递给`insert`一对迭代器**，**他们不能指向添加元素的目标容器**。

- `emplace`操作

  - `emplace_front,emplace,emplace_back`，对应`push_front,insert,push_back`，**构造元素**：将==**参数传递给元素类型的构造函数**==。
    - 调用`emplace_back`时，会在容器管理的内存空间中直接创建对象，而调用`push_back`则会创建一个局部临时对象，并将其压入容器中。

  <img style="width: 1200px;height:400px" src="Image\顺序容器访问.png">

  <img style="width: 1200px;height:400px" src="Image\顺序容器的删除操作.png">

- `forward_list`

  <img style="width: 1200px;height:600px" src="Image\forward_list.png">

- 顺序容器大小操作

  - `c.resize(n)`调整`c`的大小位`n`个元素，若`n<c.size()`,则多出的元素被丢弃。若必须添加新元素，对**新元素进行值初始化**。
  - `c.resize(n,t)`调整`c`的大小位`n`个元素。任何新添加的元素都初始化为值`t`

- 容器操作可能使迭代器失效

  - `vector,string`
    - 如果**存储空间未重新分配**，指向==**插入位置之前**==的元素的迭代器、指针和引用仍有效，但==**指向插入位置之后**==元素的迭代器、指针和引用将会失效。
    - 对于`vector`和`string`，指向被删元素之前元素的迭代器、引用和指针仍有效。注意:当我们==**删除元素时，尾后迭代器总是会失效**==。
  - `deque`
    - 插入到==**除首尾位置之外的任何位置都会导致**==迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但==**指向存在的元素的引用和指针不会失效**==。
    - 如果在==**首尾之外的任何位置删除元素**==，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除 deque 的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响;如果是删除首元素，这些也不会受影响。

#### vector对象是如何增长的

- 容器大小管理操作
  - `shrink_to_fit()`
    - 在新标准库中，我们可以调用`shrink_to_fit`来要求`deque`、`vector`或`string`**退回不需要的内存空间**。此函数指出我们不再需要任何多余的内存空间。但是，==**具体的实现可以选择忽略此请求**==。也就是说,调用`shrink_to_fit`也并不保证一定退回内存空间。
  - `capacity()`
  - `reserve(n)`
    - 只有当**需要的内存空间超过当==前容量时==**，`reserve`调用才会改变`vector`的容量。如果需求大小大于当前容量，`reserve`至少分配与需求一样大的内存空间（可能更大)。
    - 如果需求大小小于或等于当前容量，`reserve` 什么也不做。特别是，当需求大小小于当前容量时，容器不会退回内存空间。因此，在调用`reserve`之后，`capacity`将会大于或等于传递给`reserve`的参数。
    - 调用`resize`或`reserve`时**给定的大小超过当前**`capacity`，`vector`才可能重新分配内存空间。

#### 额外的string操作

- 构造string的其它方法

  <img style="width: 1200px;height:230px" src="Image\构造string的其它方法.png">

  <img style="width: 1200px;height:140px" src="Image\substr.png">

- 改变`string`的其它方法

  - `string`的`insert`和`erase`的其它版本

    ```c++
    std::string s;
    s.insert(s.size(),5,'!');//在s的末尾插入5个感叹号
    s.erase(s.size()-5,5);	//从s删除最后5个字符
    const char *cp = "Stately,plump Buck";
    s.assign(cp,7);			//从cp的开始处，替换7个字符
    s.insert(s.size(),cp+7);//从末尾插入，直到cp结束
    s.insert(0,s2);			//在s中位置之前插入s2的拷贝
    s.insert(0,s2,0,s2.size());//在s[1]之前插入s2中s2[0]开始的s2.size ()个字符
    
    ```

- 额外的`string`操作

  <img style="width: 1200px;height:500px" src="Image\额外的string操作.png">

  <img style="width: 1200px;height:250px" src="Image\修改string的操作2.png">

  ```c++
  s2.replace(11,3,"5th");
  //插入的文本恰好与删除的文本一样长。这不是必须的，可以插入一个更长或更短的string
  s.replace(11,3,"Fifth");
  //删除了3个字符，但在其位置插入了5个新字符
  ```

  - `assign`总是替换`string`中的所有内容
  - `append`总是将新字符追加到`string`末尾

- `string`**搜索**操作

  <img style="width: 1200px;height:300px" src="Image\string的搜索操作.png">

  <img style="width: 1200px;height:300px" src="Image\string的搜索操作2.png">

  - 6个不同的搜索函数，每个函数都有4个重载版本。返回`string::size_type`值，标识匹配的位置。搜索失败，返回`string::npos`的`static`成员，标准库将`npos`定义为一个`const string::size_type`类型，并且初始化为-1
  
- `compare`函数

  - `str`与指定字符串的关系等于0，大于正数，小于负数
  - <img style="width: 1200px;height:500px" src="Image\compare函数.png">
  - <img style="width: 1200px;height:500px" src="Image\string的数值之间的操作.png">


#### 容器适配器

<img style="width: 1200px;height:600px" src="Image\容器适配器接受的操作.png">

- 三个**顺序容器**适配器：`stack`，`queue`和`priority_queue`。一个容器适配器接收一种已有的容器类型，使其行为看起来像一种不同的类型。==**`stack`不接受`array`和`forward_list`**==
  - **每个适配器都定义两个构造函数**：**默认构造函数创建一个空对象**，接受一个容器的构造函数**拷贝该容器来==初始化适配器==**。例如，假定 `deq`是一个`deque<int>`，我们可以用`deq`来初始化一个新的`stack`。
  - ==**默认情况下**==，`stack`和 `queue`是基于`deque`实现的，`priority_queue`是在`vec
    tor`之上实现的
    - `stack<string,vector<string>> str_stk`在`vector`上实现的空栈
  - `queue`和`priority_queue`适配器定义==**在`queue`头文件中**==。
  - `priority_queue`为队列中元素建立优先级。**新加入的元素会排在所有优先级比它低的已有元素之前**。

### 泛型算法

#### 概述

- ==**算法总是通过迭代器操作容器，无法改变容器的大小，应确保目的容器拥有足够多的空间可以容纳元素**==
  - ==**容器要拥有足够多的size而不是capacity，算法不具备向容器添加元素的功能**==

- `numeric`头文件中定义了一组数值泛型算法，`algorithm`
  - 通常情况下，算法==**遍历范围**==，对其中的每个元素进行一些处理
  - `find`返回第一个等于给定值的元素的迭代器，没有，返回第二个参数。

#### 初始泛型算法

- 附录A列出了所有算法
  - `accumulate`定义在`numeric`中，函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是**和的初始值**。
    - `string sum = accumulate(v.cbegin(),v.cend(),string(""));`
    - **第三个参数的类型**决定了函数中使用**哪个加法运算符**以及**返回值的类型**
  - `equal`：确定两个序列是否保存相同的值，它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。对应元素都相等返回`true`否则返回`false`
    - **那些只接受一个单一迭代器来表示第二个序列的算法，==都假定第二个序列至少与第一个序列一样长。==**
  - `fill`
    - `fill(vec.begin(),vec.end(),100)`将给定值赋予序列中的每个元素
    - `fill_n(dest,n,val)`：将**给定值赋予迭代器指向的元素**开始的**指定个元素**。
  - `back_inserter` 头文件`iterator`
    - `back_inserter`**接受一个指向容器的引用**，返回一个与该容器绑定的插入迭代器当我们通过此迭代器赋值时，赋值运算符会调用`push_back`将一个具有给定值的元素添加到容器中。
    - `fill_n(back_inserter(vec),10,0);`
  - `copy`
    - 三个迭代器：前两个标识一个输入范围，第三个表示**目的序列的起始位置**。
    - 返回的是**目的位置迭代器(递增后)的值**。
  - `replace`
    - `replace(vec.begin(),vec.end(),0,42);`将所有值为0的元素改为42
    - 多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将它们放置在输入序列的末尾，而是创建一个新序列保存这些结果。
      - `replace_copy`
      - `replace_copy(vec.begin(),vec.end(),back_inserter(lst),0,42)`
      - 此算法接受额外的第三个迭代器参数，指出调整后序列的保存位置。
  - `sort`
    - `stable_sort`：这种排序算法维持相等元素的原有位置
  - `unique`
    - 先调用排序然后重排输入序列，使得每个元素只出现一次，返回指向==**不重复区域之后一个位置**==的迭代器。
    - `unique_copy`
      - 第三个迭代器，表示==**拷贝不重复元素的目的位置**==。
  - `partition`
    - 对容器进行划分，使得**一元谓词**为true的在前半部分，false在后半部分。
    - 返回最后一个使谓词为true的元素之后的位置
  - `find_if`
    - 第三个参数一元谓词，返回第一个使谓词返回非0的元素，不存在这样的元素返回尾迭代器
  - `transform`
    - 前两个迭代器表示输入序列，第三个迭代器表示目的的位置，算法对**输入序列中每个元素可调用可调用对象，并将结果写到目的位置**。
  - `bind` 
    - 头文件`functional`名称空间`std::placeholders::_1`和`bind`函数
    - `auto newCallable = bind(callable,arg_list)`
    - `arg_list` 是一个逗号分隔的参数列表,对应给定的`callable`的参数。即，当我们调用`newCallable`时，`newCallable` 会调用`callable`,并传递给它`arg_list`中的参数。
    - **`arg_list`中`_n`的名字，表示`newcallable`的参数**
      - `auto g = bind(f,a,b,_2,c_1)`
      - ==**`g`的第一个参数绑定到`_1`上第二个参数绑定到`_2`上**==
    - ==**bind的那些不是占位符的参数被拷贝到`bind`返回的的调用对象中**==
      - `bind(print,ref (os),_1,' ')`函数`ref`返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个`cref`函数，生成一个保存`const`引用的类。与`bind`一样，函数`ref`和`cref` 也定义在头文件`functiona`l中。

#### 定制操作

- `lambda`表达式

  - `[capture list](parameter list)->return type {function body}`

  - **忽略括号和参数列表等价与指定一个空的参数列表**。

  - `lambda`不能有默认实参

  - 一个`lambda`可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量。一个`lambda`通过**将局部变量包含在其捕获列表中**来指出将会使用这些变量。

  - 当定义一个`lambda`时，编译器生成一个与`lambda`对应的新的(未命名的)类类型。我们将在14.8.1节(第507页)介绍这种类是如何生成的。目前，可以这样理解，**当向一个函数传递一个`lambda`时，同时定义了一个新类型和该类型的一一个对象:传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用`auto`定义一个用`lambda` 初始化的变量时，定义了一个从`lambda`生成的类型的对象**。默认情况下，从`lambda`生成的类都包含一个对应该`lambda`所捕获的变量的数据成员。类似任何普通类的数据成员，`lambda`的数据成员也在`lambda`对象创建时被初始化。

  - 变量的**捕获方式也可以是值或引用**。**被捕获的变量的值是在`lambda`创建时拷贝，而不是调用时拷贝。**

  - ==**隐式捕获**==

    <img style="width: 1200px;height:600px" src="Image\lambda捕获列表.png">

    - **显示捕获的变量必须使用与隐式捕获不同的方式**
    
  - 对于**一个被拷贝的变量`lambda`不会改变其值**，如果我们希望改变一个被捕获的变量的值，就==**必须在参数列表首加上关键字`mutable`**==
  
    - `auto f =[i]()mutable{return ++i;};`
  
  - **只有一条return语句`lambda`不用指定返回类型。** 反之编译器推断`return`是`void`

#### 再探迭代器

1. 插入迭代器：接受一个容器，生成一个迭代器，能实现向给定容器添加元素

   - `it=t`：在`it`**指定的当前位置插入值**`t`。假定`c`是`it`绑定的容器，依赖于插入迭代器的不同种类，此赋值会分别调用`c.push. _back(t)`、`c.push_ front(t)`或`c.insert(t,p)`，其中`P`为传递给`inserter`的迭代器位置

   - `*it,++it,it++`：这些操作虽然存在，但不会对`it`做任何事情。每个操作都返回`it`

     - `back_inserter`：创建一个`push_back`迭代器

     - `front_inserter`：创建一个`push_front`的迭代器

     - `inserter`：创建一使用`insert`的迭代器，**此函数接受第二参数，这个参数必须是一个指向给定容器的迭代器**，==元素被插入到给定迭代器所表示的元素之前==

2. `iostream`迭代器：迭代器将他们对应的流当作一个特定类型的元素序列来处理

   - `istream_iterator`：读取输入流

     - <img style="width: 1000px;height:400px" src="Image\istream_iterator.png">

     - 当创建一个流迭代器时，==**必须指定迭代器将要读写的对象类型**==。一个
       `istream_iterator` 使用`>>`来读取流。因此，`istream_iterator`要**读取的类型必须定义了输入运算符**。当创建一个`istream_ iterator`时，我们可以将它绑定到一个流。当然，我们还可以==**默认初始化迭代器，这样就创建了一个可以当作尾后值使用的迭代器**==。

       ```c++
       ifstream in("afile");
       istream_iterator<string> str_it(in);
       istream_iterator<string> eof;
       while(str_it!=eof)
       {
           //后置递增运算会从流中读取下一个值，向前推进，但返回的是迭代器的旧值。迭代器的旧值包含了从流中读取的前一个值，对迭代器进行解引用就能获得此值。
           vec.push_back(*str_it++);
       }
       
       //从迭代器范围构造vec;
       std::vector<std::string> vec(str_it,eof);
       c
       istream_iterator<int> in(cin),eof;
       std::cout<<accumulate(in,eof,0)<<std::endl;
       ```

     - **==对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或IO错误，迭代器的值就与尾后迭代器相等==**

     - 当我们将一个`istream_iterator`绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。

   - `ostream_iterator`：向一个流写数据

     <img style="width: 1000px;height:300px" src="Image\ostream_iterator.png">

     - **可以**提供第二个参数，它是一个字符串，在输出每个元素后，都会打印这个字符串，**==这个字符串必须是一个C风格的字符串==**
     - ==**不允许空的或表示尾后位置的`ostream_iterator`**==

3. 反向迭代器

   - **反向迭代器需要递减运算符**，我们只能从即支持`++`也支持`--`的迭代器来定义反向迭代器。
   
     <img style="width: 700px;height:200px" src="Image\反向迭代器和普通迭代器之间的关系.png">
   
     ```c++
     std::string str("FIRST,MIDDLE,LAST");
     auto rcomma = std::find(str.rbegin(), str.rend(), ',');
     //转换成正常的迭代器。正向打印单词
     std::cout<<std::string(rcomma.base(),str.end())<<std::endl;
     ```
   
   - `rcomma`和`rcomma.base()`**指向不同的元素**，`line.crbegin` 和`line.cend()`也是如此。==**这些不同保证了元素范围无论是正向处理还是反向处理都是相同的**==。
   
   - `vector<int>::reverse_iterator be`反向迭代器

#### 泛型算法结构

1. 迭代器类型

   1. 输入迭代器：读取序列中的元素，**必须支持的操作**

      - **==只读，不写；单遍扫描，只能递增==**

      - `==`,`!=`

      - 前置和后置`++`

      - 读元素的解引用`*`,箭头运算符`->`

   2. 输出迭代器

      - 只写，不读:单遍扫描，只能递增

      - 用于推进迭代器的**前置和后置递增运算**`++`

      - 解引用运算符`*`,只出现在赋值运算符的左侧(向一个已经解引用的输出迭代器
        赋值，就是将值写入它所指向的元素)

   3. 前向迭代器
      - 可读写;多遍扫描，只能递增

   4. 双向迭代器
      - 可读写;多遍扫描，可递增递减

   5. 随机访问迭代器
      - 可读写，多遍扫描，支持全部迭代器运算

2. 算法形参模式
   - **接受单个目标迭代器的算法**
     - 如果`dest`是一个直接指向容器的迭代器，那么算法将输出数据写到容器中已经存在的元素内。
     - 向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据。
   - 接受第二个输入序列的算法
     - 接受**单独的**`beg2`或是**接受`beg2`和`end2`**的算法用这些迭代器**表示第二个输入范围**。这些算法通常**使用第二个范围中的元素与第一个输入范围结合来进行一些运算**。
   - ==**一些算法的重载形式传递一个谓词**==：替换默认的`<`或`==`运算符
   - ==**`_if`算法**==
     - `find(beg,end,val)`,`find_if(beg,end,pred)`
     - 这两个算法提供了命名上差异的版本，而非重载版本，因为两个版本的算法都接受相同数目的参数。因此可能产生重载歧义。
     - **==拷贝元素版本和不拷贝版本==**：写到额外目的空间算法都在名字后面附加一个`_copy`

#### 特定容器算法

<img style="width: 1000px;height:200px" src="Image\list和forward_list.png">

<img style="width: 1000px;height:100px" src="Image\list和forward_list2.png">

<img style="width: 1000px;height:250px" src="Image\splice.png">

- ==对于`list`和`forward list`,应该优先使用成员函数版本的算法而不是通用算法。==

### 关联容器

<img style="width: 1000px;height:400px" src="Image\关联容器类型.png">

#### 使用关联容器

1. 八个容器的不同体现在**三个维度**上
   - `set`或`map`
   - 不重复关键字或者允许重复关键字
   - 顺序或无效，允许重复关键字`multi`，**不保持关键字按顺序存储**，`unordered`

#### 关联容器概述

1. ==**关联容器不支持顺序容器的位置相关的操作**==，例如`push_front`，原因是关联容器中元素是根据关键字存储的。

   - 关联容器的迭代器**都是双向的**。

   `map<string,int>m = {{key,value},{key,value}}`

2. 关键字类型要求

   - **对于有序容器**：关键字类型必须定义元素的比较方法。默认使用`<`运算符来比较关键字。
   - ==**严格弱序**==
     - 两个关键字不能同时“小于等于”对方
     - 如果k1“小于等于”k2，且k2“小于等于”k3，那么k1必须“小于等于”k3。
     - 如果存在两个关键字，任何一个都不“小于等于”另一个，那么我们称这两个关键字是“等价”的。
   - **自定义的操作**
     - `std::map<std::string, int, decltype(compare)*> myMap(compare);`
     - 比较操作类型**应该是一种函数指针类型**。

3. `pair`类型`utility`头文件

   <img style="width: 1000px;height:400px" src="Image\pair上的操作.png">

   ```c++
   pair<string,int>
       process(vector<string>&v)
   {
       //处理v
       if(!v.empty())
       {
           return {v.back(),v.back().size()};//列表初始化
       }
       else
       {
           return pair<string,itn>();//隐式构造返回值
       }
   }
   ```

#### 关联容器操作

<img style="width: 1000px;height:300px" src="Image\关联容器的额外类型.png">

1. 关联容器迭代器
   - **解引用一个==关联容器迭代器时==**，会得到一个类型为容器的`value_type`的值的引用，对`map`，`value_type`是一个`pair`类型，`first`成员保存`const`的关键字。
   - `set`类型同时定义了`iterator`和`const_iterator`类型，但两种类型都只允许==**读**==访问`set`中的元素。

2. 添加元素

   <img style="width: 1000px;height:300px" src="Image\关联容器insert操作.png">

   1. `insert`成员，两个版本，分别接受一对迭代器，或是一个初始化器列表，这两个版本的行为类似对应的构造函数，**对于一个给定的关键字，只有第一个带此关键字的元素才被插入到容器中**。
   2. 向`map`添加元素，
     - `word_count.insert ({word,1});`
     - `word_count.insert (make_pair (word,1) );`
     - `word_count.insert (pair<string,size_t> (word,1));`
     - `word_count.insert(map<string,size_t>::value_type (word,1));`

3. 删除元素

   <img style="width: 1000px;height:300px" src="Image\从关联容器删除元素.png">

4. `map`的下标操作

   - ==**我们不能对一个`multimap`或一个`unordered_multimap`进行下标操作**==，因为这些容器中可能有多个值与一个关键字相关联。
   - `map`下标运算符接受一个索引(即，一个关键字)获取与此关键字相关联的值。但是，与其他下标运算符不同的是，**如果关键字并不在map中，会为它创建一个元素并插入到`map`中**，关联值将进行值初始化。
   - `C.at(k)`：访问关键字为`k`的元素，==**带参数检查**==；若`k`不在`c`中，抛出一个`out_of_range`异常。

5. 访问元素

   <img style="width: 1000px;height:100px" src="Image\关联容器查找2.png">

   <img style="width: 1000px;height:300px" src="Image\关联容器查找.png">

   - **==如果一个multimap或multiset中有多个元素具有给定关键字，则这些元素在容器中会相邻存储。==**
     - 最直观的方法是使用`find`和`count`
     - 如果关键字在容器中，`lower_bound`返回的迭代器指向第一个具有给定关键字的元素，而`upper_bound`返回的迭代器则指向最后一个匹配给定关键字的元素之后的位置。如果元素不在 `multimap `中，则` lower_bound`和会返回相同的迭代器**-指向一个不影响排序的关键字插入位置**。
     - 最直接的方法`equal_range`

#### 无序容器

<img style="width: 1000px;height:700px" src="Image\无序容器的管理操作.png">

1. **无序容器在存储上组织为一组桶**，每个桶保存**零个或多个元素**。无序容器使用一个**哈希函数将元素映射到桶**。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。**容器将具有一个特定哈希值的所有元素都保存在相同的桶中**。如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。
2. **默认情况下，无序容器使用关键字类型的==运算符来比较元素**，它们还使用一个`hash<key_type>`**类型的对象**来生成每个元素的哈希值。标准库为**内置类型(包括指针)提供了hash模板**。**还为一些标准库类型**，包括`string`和智能指针类型定义了`hash`。因此，我们可以直接定义关键字是内置类型（包括指针类型)、string 还是智能指针类型的无序容器。
3. **我们==不能直接定义关键字类型==为自定义==类类型==的无序容器**。与容器不同，不能直接使用哈希模板，**而必须提供我们自己的`hash`模板版本**。我们将在16.5节(第626页)
   - 使用一个哈希函数，和关键字类型的`==`运算符组织元素。

### 动态内存

#### 动态内存与智能指针

- `memory`头文件

  - `make_shared`函数

    - 最安全的分配和使用动态内存的方法是调用一个名为`make_shared`的标准库函数。
    - `make_shared`用其参数来==**构造**==给定类型的对象，传递的参数要和类型的构造函数相匹配。
  
  - `shared_ptr`：允许多个指针指向同一个对象
  
    <img style="width: 1000px;height:300px" src="Image\智能指针1.png">
  
    <img style="width: 1000px;height:300px" src="Image\智能指针2.png">
  
    - 最后一个`shared_ptr`销毁前内存都不会释放，保证`shared_ptr`在无用之后不在保留
  
    - `shared_ptr`和`new`结合使用
  
      - 接受**指针参数**的智能指针**构造函数是`explicit`的**，我们不能将一个内置指针隐式转换为一个智能指针。
  
        ```c++
        shared_ptr<int> p1 = new int(1023);//错误
        shared_ptr<int> p2(new int(1023));
        ```
  
      - **==默认情况下，一个用来初始化的智能指针的普通指针必须指向动态内存，因为智能指针默认使用`delete`释放它所关联的对象。==**
  
        <img style="width: 1000px;height:300px" src="Image\改变shared_ptr的其它方法.png">
  
        <img style="width: 1000px;height:300px" src="Image\改变shared_ptr的其它方法2.png">
  
      - ==**`shared_ptr`可以协调对象的析构，但这仅限于其自身的拷贝**==
  
      - 当将一个`shared_ ptr`绑定到一个普通指针时，我们就将内存的管理责任交给了这个`shared_ ptr`。一旦这样做了 ，我们就不应该再使用内置指针来访问`shared_ ptr`所指向的内存了。
  
      - `get`函数：我们需要**向不能使用智能指针的代码**传递一个内置指针，使用`get`返回的指针的代码不能`delete`此指针。
  
      -  **如果在`new`和`delete`之间发送异常，且异常未在`f`中被捕获，则内存就永远不会被释放了**
  
        - 在异常发生后资源能被正确的释放，一个简单的确保资源被释放的方法是使用智能指针。
  
  - `unique_ptr`：“**独占**”所指向的对象
  
    <img style="width: 1000px;height:400px" src="Image\unique_ptr.png">
  
    - **==不能拷贝或赋值`unique_ptr`==**，可以通过调用`release`或`reset`将指针的所有权（非const）`unique_ptr`转义给另一个`unique`
    - `reset`成员接受一 个可选的指针参数，令`unique_ ptr`重新指向给定的指针。如果`unique_ ptr`不为空，它原来指向的对象被释放。
    - ==**不能拷贝`unique_ ptr`的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的`unique_ ptr`。 **==
      - ==**最常见的例子是从函数返回一个`unique_ ptr`**==
      - 还可以返回一个局部对象的拷贝
    - 标准库早期版本`auto_ptr`具有`unique_ptr`的部分特性
      - 不能在容器中保存`auto_ptr`不能从函数中返回`auto_ptr`
    - 我们必须在**尖括号中**`unique_ptr`指向类型之后提供删除器类型。在创建或`reset`一个这种`unique_ ptr`类型的对象时，必须提供一个指定类型的可调用对象
      - `unique_ptr<objT,delT> p(new objT,fcn);`
    
  - `weak_ptr`：
  
    <img style="width: 1000px;height:400px" src="Image\weak_ptr.png">
  
    - `weak_ptr`指向一个`share_ptr`管理的对象。**将一个`weak ptr`绑定到一个`shared ptr`不会改变`shared_ ptr`的引用计数**。一旦最后一个指向对象的`shared_ptr`被销毁，对象就会被释放。即使有`weak_ ptr`指向对象，对象也还是会被释放。
    - ==**由于对象可能不存在，我们不能使用`weak_ ptr` 直接访问对象，而必须调用`lock`。此函数检查`weak_ ptr`指向的对象是否仍存在。**==
  
- 直接管理内存

  - 自由空间分配的内存是无名的，`new`无法为其分配的对象命名，默认情况下，**动态分配的对象是默认初始化的**，而类类型对象将使用默认构造函数进行初始化。

  - 可以使用直接初始化，传统的构造方式，列表初始化来初始化一个动态分配的对象。

    ```c++
    int *pi = new int(1024);//直接初始化
    int *pi2 = new int();//值初始化为0
    int *pi3 = new int;//默认初始化
    string * ps = new string(10,'9');
    vector<int>*pv = new vector<int>{1,2,3,4,5};
    ```

  - 如果我们提供了**一个括号包围的初始化器**，**就可以使用`auto`从此初始化器来推断我们想要分配的对象的类型**。但是，由于编译器要用初始化器的类型来推断要分配的类型，只有当括号**中仅有单一初始化器**时才可以使用`auto`

    - `auto p = new auto(obj);`
    - `p`指向一个与`obj`类型相同的对象该对象用`obj`进行初始化

  - **动态分配的`const`对象**

    - 一个动态分配的`const`对象必须进行初始化，**定义了默认构造函数的类类型**，其`const`动态对象可以隐式初始化。

      ```c++
      const int * pci = new const int(1024);
      ```

  - ==**内存耗尽**==

    - `new`表达式失败：抛出一个类型为`bad_alloc`的异常

    - **定位new**：向`new`传递`nothrow`对象，不抛出异常，不能分配内存返回空指针。

    - `bad_alloc`和`nothrow`定义在**==头文件new中==**

      ```c++
      int *p1 = new int;
      int *p2 = new(nothrow)int;
      ```

  - 指针值和`delete`

    - 我们传递给`delete`的指针必须指向动态分配的内存，或者是一个空指针
    - 释放一个空指针总是没有错误的
    - **空悬指针**：指向一块曾经保存数据对象但现在已经无效的内存的指针。

- **使用我们自己的释放操作**

  - 定义一个函数来代替`delete`，这个删除器函数必须能够完成对`shared_ptr`中保存的指针进行释放的操作。
  - 不使用相同的内置指针值初始化(或`rese`t)多个智能指针。
  - 不`delete get()`返回的指针。
  - 不使用`get()`初始化或`reset`另一个智能指针。
  - 如果你使用`get()`返回的指针，记住当最后一个对应的智能指针销毁后，你的
    指针就变为无效了。
  - 如果你使用智能指针管理的资源不是`new`分配的内存，记住传递给它一个删除器。

#### 动态数组

- `new`和数组：方括号中的大小必须是整形，但不必是常量

  ```c++
  typedef int arrT[42];
  int *p1 = new int[10];
  int *p2 = new arrT;
  
  int *p3 = new int[10]();//值初始化为0的int
  int *p4 = new string[10]{"a","an","the",string(3,'x')};//元素初始化花括号列表
  ```

  - `new`分配一个数组时，我们并未得到一个数组类型得对象，而是得到一个数组元素类型得指针。
  - 如果**初始化器数目大于元素数目，则`new`表达式失败**，不会分配任何内存。在本例中，`new`会抛出一个类型为`bad_array_new_length`的异常。此类型定义在头文件`new`中。
  - `new`分配一个大小为`0`的数组时，`new`返回一个合法的非空指针。此指针保证与`new`返回的其他任何指针都不相同。对于零长度的数组来说，此指针就像尾后指针一样。

- 释放动态数组：`delete [] pa`

  - 销毁`pa`指向的数组中的元素，并释放对应的内存，数组中的元素**按逆向销毁**。方括号是必须的。

- 智能指针和动态数组

  <img style="width: 1000px;height:300px" src="Image\智能指针和数组.png">

  - `shared_ptr`管理的动态数组，必须提供自己定义的删除器
    - `shared_ptr<int> sp(new int[10],[](int *p){delete []p;});`

- `allocator`类：`memory`头文件

  - 将内存分配和对象构造分离开。

  <img style="width: 1000px;height:300px" src="Image\allocator.png">

  <img style="width: 1000px;height:300px" src="Image\allocator算法.png">

### 拷贝控制

- 当定义一个类时，我们**显式地**或**隐式地**指定在此类型的对象**拷贝**、**移动**、**赋值和销毁**时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括:拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数。

#### 拷贝，赋值与销毁

- 拷贝构造函数

  - 如果一个构造函数的第一个参数是自身类类型的引用，==**且任何额外参数都有默认值**==，则此构造函数是拷贝构造函数。拷贝构造函数的第一个参数必须是一个引用类型，原因我们稍后解释。**虽然我们可以定义一个接受非`const`引用的拷贝构造函数，但此参数几乎总是一个`const`的引用**。**拷贝构造函数在几种情况下都会被隐式地使用**。因此，拷贝构造函数通常不应该是 explicit

    - `Foo(const Foo&);`

  - 合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中(除去`static`成员)

    - **逐元素地拷贝一个数组类型的成员**

  - **用花括号列表初始化一个数组中的元素或一个聚合类中的成员会发生拷贝初始化。**

  - ==**在拷贝初始化过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数。**==

    ```c++
    string null_book = "9-999-99999-9";
    //改写为
    string null_book("9-999-99999-9");
    //即使编译器掠过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是存在且可访问的
    ```

- 拷贝赋值运算符

  - 重载赋值运算符
    - **operator关键字**后接表示要定义的运算符的符号组成
    - **重载运算符的==参数==表示==运算符的运算对象==**。某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的`this`参数。对于**一个二元运算符**，例如赋值运算符，其**右侧运算对象作为显式参数传递**。
    - 标准库通常要求**保存在容器中的类型**要具有赋值运算符，且其返回值是左侧运算对象的引用。
  - **合成的拷贝复制运算符**和合成的拷贝构造函数一样

- 析构函数

  - 在一个析构函数中，**首先执行函数体**，**然后销毁成员**。成员按初始化顺序的**逆序销毁**。
    - 认识到析构函数体自身并不直接销毁成员是非常重要的。**成员是在析构函数体之后隐含的析构阶段中被销毁的**。在整个对象销毁过程中，**析构函数体是作为成员销毁步骤之外的另一部分而进行的**。
  - 成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数，内置类型没有析构函数，因此**销毁内置类型成员什么也不需要做**。
  - ==**隐式销毁一个内置指针类型的成员不会`delete`它所指向的对象。**==
  - ==**当指向一个对象的引用或指针离开作用域时，析构函数不会执行。**==

- 使用`=default`

  - `=default`来显示地要求编译器生成合成的版本
  - 在类内用`=default`修饰成员的声明时，合成的函数将隐式地声明为内联的。如果我们==**不希望合成的成员是内联函数**==，因该**只对==成员的类外定义==使用**`=default`

- 阻止拷贝

  - 我们可以通过将**拷贝构造函数**和**拷贝赋值运算符**定义为删除的函数来阻止拷贝。
    - `NoCopy(const NoCopy&)=delete;`

  - **`=delete`必须出现在函数第一次声明的时候**

  - 我们可以对任何函数指定`=delete`。希望引导函数匹配过程时，删除函数有时也是有用的

  - 我们不能删除析构函数。如果析构函数被删除，就无法销毁此类型的对象了。对于一个删除了析构函数的类型，**编译器将不允许定义该类型的变量或创建该类的临时对象。**而且，如果**一个类有某个成员的类型删除了析构函数**，我们也不能定义该类的变量或临时对象。

  - 对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，**但可以动态分配这种类型的对象。但是，不能释放这些对象**。

  - ==**合成的拷贝控制成员可能是删除的**==
    - 如果**类的某个成员的==析构函数==是删除的或不可访问的**（例如，是`private` 的)，则类的合成析构函数被定义为删除的。
    - 如果类的**某个成员的==拷贝构造函数==是删除的或不可访问的**，则**类的==合成拷贝构造函数==被定义为删除**的。如果**类的某个成员的析构函数是删除**的或不可访问的，则**类合成的拷贝构造函数也被定义为删除**的。
    - 如果**类的某个成员的拷贝赋值运算符是删除的**或不可访问的，或是**类有一个`const`的或引用成员**，则**类的合成拷贝赋值运算符被定义为删除**的。
    - 如果**类的某个成员的析构函数是删除的或不可访问的**，或是**类有一个引用成员，它没有类内初始化器**（参见2.6.1节，第65页)，**或是类有一个` const`成员**，**它没有类内初始化器且其类型未显式定义默认构造函数**，则该类的默认构造函数被定义为删除的。
    - 这些规则的含义是:**如果一个类有数据成员不能默认构造、拷贝、复制或销毁,**则对应的成员函数将被定义为删除的。
    - **一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的**，这看起来可能有些奇怪。其原因是，如果没有这条规则，我们可能会创建出无法销毁的对象。
    - 对于**具有引用成员或无法默认构造的`const`成员的类**，编译器不会为其合成默认构造函数，这应该不奇怪。同样不出人意料的规则是：如果一个**类有`const`成员**、则它不能使用**合成的==拷贝赋值==运算符**,毕竟，此运算符试图赋值所有成员，而将一个新值赋予一个`const`对象是不可能的。
    - 虽然我们可以将一个新值赋予一个引用成员，但这样做**改变的是==引用指向==的对象的值**，而不是引用本身。(如果为这样的类合成拷贝赋值运算符，则赋值后，左侧运算对象仍然指向与赋值前一样的对象，而不会与右侧运算对象指向相同的对象。由于这种行为看起来并不是我们所期望的，因此对于有引用成员的类，合成拷贝赋值运算符被定义为删除的。

  - ==**通过声明（但不定义）**==`private`的拷贝控制成员，我们可以预先阻止任何拷贝该类型对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误，成员函数或友元函数中的拷贝操作将会导致连接时错误。（旧标准）
    - **希望阻止拷贝的类因该使用`=delete`**


#### 拷贝控制和资源管理

- 关键概念：**赋值运算符**
  - 如果将一个对象赋予它自身，赋值运算符必须能正确工作。·
  - 大多数赋值运算符组合了析构函数和拷贝构造函数的工作。
    - 当你编写一个赋值运算符时，一个好的模式是**先将右侧运算对象拷贝到一个局部临时对象中**。当拷贝完成后，**销毁左侧运算对象**的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下**将数据从临时对象拷贝到左侧运算对象**的成员中了。

#### 交换操作

- ```c++
  class HasPtr
  {
      friend void swap(HasPtr&,HasPtr&);
  };
  inline void swap(HasPtr&lhs,HasPtr&rhs)
  {
      using std::swap;
      swap(lhs.ps,rhs.ps);//ps 是string
      swap(lhs.i,rhs.i);//i 是 int
      //如果一个类的成员有自己类型特定的swap函数，就会调用类自定义的版本。
      //否则调用标准库的版本
  }
  ```

- 在赋值运算符中使用swap

  - ```c++
    HasPtr& HasPtr::operator=(HasPtr rhs)
    {
        swap(*this,rhs);
        return *this;
    }
    ```

  - 这个版本的赋值运算符中，参数**并不是一个引用**。`rhs`是右侧运算对象的一个副本且自动处理了自赋值情况且天然就是异常安全的

#### 拷贝控制示例

一段程序

#### 动态内存管理类

一段程序

1. 移动构造函数
   - 有一些标准库类，包括string，都定义了所谓的**移动构造函数**。移动狗战术通常是将资源从给定对象**移动**而不是拷贝到正在创建的对象。

1. `std::move`
   - 定义在`utility`头文件中，调用`move`表示希望使用`string`的移动构造函数。如果漏掉了move的调用，将会使用`string`的拷贝构造函数。通常不为move提供一个`using`声明，调用`move`时，直接调用`std::move`而不是move

#### 对象移动

1. 右值引用
   - 只能绑定到一个将要销毁的对象
   - 返回非引用类型的函数，连同算术、关系、位以及**后置递增/递减运算符**，都生成右值。我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个 const 的左值引用或者**一个右值引用**绑定到这类表达式上。
   - 变量可以看作是只有一个运算对象而没有运算符的表达式，变量表达式也有左值/右值属性，**变量表达式**都是左值。
     - 不能将一个右值引用绑定到一个右值引用类型的变量上
   - `move`标准库函数获得**绑定到左值上右值引用**。
     - 调用`move`就意味着承诺：除了对rr1赋值或销毁它外，我们将不再使用它，在调用move后，我们不能对移动后源对象的值做任何假设。
     - **我们可以销毁一个移动后源对象，也可以赋予它新值，但不能使用一个移动后源对象的值**

2. 移动构造函数和移动赋值运算符

   ```c++
   StrVec::StrVec(StrVec &&s) noexcept //移动操作不应该抛出任何异常
       :elements(s.elements),first_free(s.first_free),cap(s.cap)
   {	//成员初始化器接管s中的资源
       //令s进入这样的状态，对其运行析构函数是安全的
       s.elements = s.first_free = s.cap = nullptr;
   }
   StrVec& StrVec::operator=(StrVec &&rhs) noexcept
   {
       if(this!= &rhs) //检查的原因是此右值可能是move调用的返回结果
       {
           free();
           //接管rhs的资源
           elements = rhs.elements;
           first_free = rhs.first_free;
           cap = rhs.cap;
           
           //将rhs置于可析构状态
           rhs.elements = rhs.first_free = rhs.cap = nullptr;
       }
   }
   ```

   - 由于移动操作“**窃取**”资源，它通常不分配任何资源。因此，移动操作通常不会抛出任何异常。**当编写一个不抛出异常的移动操作时，我们应该将此事通知标准库**。我们将看到，除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且**为了处理这种可能性而做一些额外的工作**。
   - 我们必须在**类头文件的声明中和定义中**都指定`noexcept`
   - 编写**移动操作时**，必须确保移动后源对象进入一个可析构的状态。还必须保证对象仍然是有效的，对象有效就是指可以安全地为其赋予新指或者可以安全地使用而不依赖其当前值。
   - 如果一个类**定义**了自己的拷贝构造函数，拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。
     - 如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来代替移动操作
     - 只有当一个类没有定义任何自己版本的拷贝控制成员,且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员:
   - 与拷贝操作不同，**移动操作永远不会隐式定义为删除的函数**。**但是，如果我们显式地要求编译器生成=default的(参见7.1.4节，第237页）移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数**。除了一个重要例外，什么时候将合成的移动操作定义为删除的函数遵循与定义删除的合成拷贝操作类似的原则(参见13.1.6节，第449页):
     - 与拷贝构造函数不同，移动构造函数被定义为删除的函数的条件是:**有类成员==定义了自己==的拷贝构造函数且未定义移动构造函数，或者是有类成员==未定义==自己的拷贝构造函数且编译器==不能为其合==成移动构造函数**。移动赋值运算符的情况类似。
     - 如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的。
     - 类似拷贝构造函数，如果**类的析构函数被定义为删除的或不可访问**的，则类的移动构造函数被定义为删除的。
     - 类似拷贝赋值运算符，如果有类成员是`const `的或是引用，则类的移动赋值运算符被定义为删除的。
   - **移动操作**和**合成的拷贝控制成员**间还有最后**一个相互作用关系**:一个类**是否定义了自己的移动操作**对**拷贝操作如何合成有影响**。如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。
   - 如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数(参见6.4节，第208页)。赋值操作的情况类似。例如，在我们的`StrVec`类中，拷贝构造函数接受一个`const StrVec`的引用。因此，它可以用于任何可以转换为`StrVec`的类型。而移动构造函数接受一个strVec&&，因此只能用于实参是（非static）右值的情形。
     - **如果没有移动构造函数，右值也被拷贝**
   - ==**五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五各操作**。==

3. 移动迭代器

   - `make_move_iterator`函数将一个普通迭代器转换为一个移动迭代器，此函数接受一个迭代器参数，返回一个移动迭代器。移动迭代器的解引用运算符生成一个右值应用。







