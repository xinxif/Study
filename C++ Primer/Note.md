## 第1章 开始

1. 一个函数的定义包含**四部分**：返回类型（return type），函数名（function name），一个括号包围的形参列表（parameter list，**允许为空**）,以及函数体（function body）。`mian`**函数的返回值==必须为in==t**。**当return语句包括一个值时**，**此返回值的类型于函数的返回类型相同**。在大多数系统中，`main`的**返回值**都被**用来指示状态**。返回0表示成功，非0的返回值的含义有系统定义，通常用来指出错误类型。**C++程序**，不同的编译器使用不同的后缀命名约定，**最常见的包括**`.cc，.cxx，.cpp，.cp`

2. [MSVC 编译器选项 | Microsoft Learn](https://learn.microsoft.com/zh-cn/cpp/build/reference/compiler-options?view=msvc-170&form=MG0AV3)

3. 初识输入输出

   - `iostream`库包含两个基础类型`istream`和`ostream`分别表示输入流和输出流。

   - 标准库定义了4个IO对象，输入`cin`是`istream`类型对象（**标准输入**）。`cout`为`ostream`类型的对象（**标准输出**）`cerr`和`clog`**标准错误**，`clog`**用来输出程序运行时的一般信息**。

     - 默认情况下，读`cin`会刷新`cout`；程序非正常终止时也会刷新`cout`

     - 默认情况下，写到`cerr`的数据是不缓冲的。`cerr`**通常用于输出错误信息**或其它不属于程序正常逻辑的输出内容

     - 写到`clog`**的数据是被缓冲**的，`clog`通常用于报告程序的执行信息，存入一个日志文件中。

   - `#include`指令和头文件的名字必须写在同一行中。`#include`指令必须出现在所有函数之外。

   - `<<`运算符接收两个运算对象：**左侧的运算对象**必须是一个`ostream`对象，**右侧的运算对象**是要打印的值。

     - `<<`运算符**返回左侧的运算对象**，因此第一个运算符的结果成为了第二个运算符的左侧运算对象。

       ```c++
       //我们的表达式等于
       (std::cout<<"Enter two number:")<<std::endl;
       ```

     - `endl`这是一个被称为操作符的特殊值。写入`endl`的效果是**结束当前行，并将于设备关联的缓冲区中的内容刷到设备中。**

     - 程序员常常在调试时添加打印语句。这类语句应该保证“一直”刷新流。否者，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误推断。

   - `>>`**输入运算符**和输出运算符类似，它接收一个`istream`作为其左侧运算对象，接收一个对象作为其右侧运算对象。

   - 当我们使用一个`istream`**对象作为条件时，其效果是检查流的状态**。如果流是有效的，即流遇未到错误，那么检测成功。当遇到文件结束符，或遇到一个无效输入时，`istream`对象的状态会变得无效。处于无效状态的`istream`对象会使条件变为假。

   - 我们通常使用`.h`组为头文件的后缀，但也有一些程序习惯用`.H`，`.hpp`，`.hxx`。**标准库头文件通常不带后缀**。

## 第一部分

### 变量和基本类型

| 类型          | 含义           | 最小尺寸     |
| ------------- | -------------- | ------------ |
| `bool`        | 布尔类型       | 未定义       |
| `char`        | 字符           | 8位          |
| `wchar_t`     | 宽字符         | 16位         |
| `char16_t`    | Unicode字符    | 16位         |
| `char32_t`    | Unicode字符    | 32位         |
| `short`       | 短整形         | 16位         |
| `int`         | 整形           | 16位         |
| `long`        | 长整形         | 32位         |
| `long long`   | 长整形         | 64位         |
| `float`       | 单精度浮点数   | 6位有效数字  |
| `double`      | 双精度浮点数   | 10位有效数字 |
| `long double` | 扩展精度浮点数 | 10位有效数字 |

1. `wchar_t`类型用于**确保可以存放机器最大扩展字符集**中的任意一个字符，类型`char16_t`和`char32_t`则为`Unicode`字符集服务。
   
   - 字符型被分为了三种：`char`，`signed char`和`unsigned char`，**尽管字符型有三种，但是字符型的表现形式却只有两种**：带符号的和无符号的。类型char实际上会表现为上述两种形式的一种，**具体是哪种由编译器决定**。
   
2. **选着类型的一些经验尊则**
   
   - **数值不可能为负**时，选用无符号类型。
   - 使用`int`执行整数运算，`short`常常显得太小而`long`一般和`int`有一样的尺寸。数值超过了`int`的表示范围，选用`long long`。
   - 在算术表达式种不要用`char`或`bool`，只有在**存放字符**或**布尔值**时才使用它。因为类型`char`在一些机器上是有符号的，而在另一些机器上又是无符号的，所以说如果使用`char`进行运算特别容易出问题。如果**你需要使用一个不大的整数**，那么**明确指定他的类型是**`signed char`或者`unsigned char`。
   
3. 类型转换
   - **非布尔值类型**的算数值**赋值给布尔值类型**时，初始值为**0**则结果为**false**，否则结构为true。
   
   - **赋给无符号类型一个超出它表示范围的值**时，结果是初始值对无符号类型表示数值总数**取模后的余数**。
   
   - 赋给一个带符号类型一个超出它能表示范围的值时，结果是**未定义的**。
   
   - ==**程序应该尽量避免依赖于实现环境的行为**==
   
   - ==**当一个算术表达式中既有无符号数又有`int`值时，`int`值就会转换成无符号的**==
   
     - 把负数转换成无符号数类型类似于直接给无符号数赋一个负值，**结果等于这个负数加上无符号数的模**
     - ==**不要混用带符号类型和无符号类型**==
   
   - 默认情况下，十进制字面值是带符号数，八进制和十六进制值字面值即可能是带符号的也可能是无符号的。
   
   - 泛化的转义序列：形式是`\X`后紧跟1个或多个十六进制数字，或者\后紧**跟1个，2个或3个**八进制数字。
   
     - \115(字符M)\x4d(字符M)
   
   - 指定字面值类型
   
     | 前缀 | 含义                      | 类型     |
     | ---- | ------------------------- | -------- |
     | `u`  | Unicode16字符             | char16_t |
     | `U`  | Unicode32字符             | char32_t |
     | `L`  | 宽字符                    | wchar_t  |
     | `u8` | UTF-8(仅用于字符串字面零) | char     |
   
   - `nullptr`**指针字面值**。

#### 变量

1. 变量的定义

   - 初始化不是赋值，**初始化的含义是创建变量时赋予其一个初始值**，而赋值的含义是把对象的当前值擦除,而以一个新值来替代。

   ```c++
   int units_sold = 0;
   int units_sold ={0};
   int units_sold{0};//C++ 11 列表初始化
   int units_sold(0);
   ```

   - 如果我们使用**列表初始化且初始值存在丢失信息**的风险，则编译器将报错：

     ```c++
     long double ld = 3.1415926536;
     int a{ld},b{ld} //错误：转化未执行，因为存在丢失信息的风险
     int c(ld),d=ld; //正确：转换执行，且确实丢失了部分值
     ```

2. 默认初始化

   - 定义于任何函数体之外的变量被初始化为0
   - 定义于函数体内部的内置类型变量将**不被初始化**。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其它形式访问此类值将引发错误。
   - 每个**类各自决定其初始化对象的方式**。而且，**是否允许不经初始化就定义对象也由类自己决定**。如果类允许这种行为，它将决定对象的初始值到底是什么。**绝大多数类都支持无须显式初始化而定义对象**，这样的类提供了一个合适的默认值。例如，==string类规定如果没有指定初值则生成一个空串==
   - ==**声明一个变量而非定义它**==，就在**变量名前添加关键字extern**,而且不要显式地初始化变量:`extern int i`
     - 我们**能给由extern关键字标记的变量赋一个初始值**，但是这么做也就抵消了extern的作用。**extern语句如果包含初始值就不再是声明，而变成定义了**
     - ==在函数体内部，初始化一个由`extern`关键字标记的变量，将引发错误。==

3. 标识符

   - C++标识符的长度没有限制，但是对大小写字母敏感。

   - C++标准库保留了一些名字，**用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头，定义在函数体外的标识符不能以下划线开头。**

     <img style="width: 800px;height:400px" src="Image\C++关键字.png">

   - **作用域中一旦声明了某个名字**，它所**嵌套着的所有作用域中都能访问该名字**。同时，**允许在内层作用域中重新定义外层作用域已有的名字**。

     ```c++
     int reused = 42;
     int main()
     {
         int unique = 0;
         cout<<reused<<" "<<unique<<endl;//使用全局变量reused
         int reused = 0; //新建局部变量reused，覆盖全局变量reused
         cout<<reused<<" "<<unique<<endl;
         //显示地访问全局变量reused
         cout<<::reused<<" "<<unique<<endl;
     }
     ```

   - 因为**全局作用域本身并没有名字**，所以**当作用域操作符的左侧为空时，向全局作用域发出请求**获取作用域操作符右侧名字对应的变量。

4. 复合类型

   - 定义引用时，程序把引用和它的初始值**绑定**在一起，而不是将初始值拷贝给引用，一旦初始化完成，**引用将和它的初始值和对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象**，==因此引用必须初始化。==

     - ==引用并非对象，他只是为一个已经存在的对象所起的另外一个名字==。
     - 因为引用本身不是一个对象，所以不能定义引用的引用。
     - 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。

   - **指针本身就是一个对象**。

     - ==**因为引用不是对象，没有实际地址，所以不能定义指向引用的指针**==

     - ```c++
       //生成空指针的方法
       int *p1=nullptr;
       int *p2=0;
       //需包含cstdlib
       int *p3=NULL;
       ```

     - ==一个指针指向某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同的情况，即指针相等。==

     - `void*`是一种特殊的指针类型，可用于存放任意对象的地址。因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。

       ```c++
       int i =42;
       int *p;		//p是一个int型的指针
       int *&r=p;	//r是一个对指针p的引用
       
       r=&i;	//r引用了一个指针，因此给r赋值&i就是令p指向i
       *r=0;	//解引用r得到i，也就是p指向的对象，将i的值改为0
       ```

     - **面对一条比较复杂的指针或者引用的声明语句时，==从右往左阅读==有助于弄清楚它的真实含义。**

5. `const `限定符

   - 因为`const`对象一旦创建后就不能改变，所以`const`**对象必须初始化**。
   - **默认情况下，`const`对象被设定为仅在文件内有效，当文件中出现了多个同名的`const`变量时，其实就等同于在不同文件中分别定义了独立的变量。**
   - 某些时候有这样一种`const`变量，它的初始值不是一个常量表达式，但又确实有必要**在文件间共享**。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类`const`对象像其他(非常量)对象一样工作，也就是说，**只在一个文件中定义**`const`,而在**其他多个文件中声明并使用它**。解决的办法是，对于`const`==变量不管是声明还是定义都添加`extern`关键字==，这样只需定义一次就可以了:
     - `extern const int bufSize = fcn();`
     - `extern const int bufSize;`

6. `const`的引用

   - ==**对常量的引用**==

     - 引用的类型必须与其所引用对象的类型一致， 但是有**两个例外**。第一种例外情况就是在**初始化常量引用时允许用任意表达式作为初始值**，**只要该表达式的结果能转换成引用的类型即可**。尤其，==**允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式**==。

       ```c++
       double dval = 3.14;
       const int &ri=dval;
       //ri引用了一个int型的数。对ri的操作因该是整数运算，但dval却是一个双精度浮点数而非整数，因此为了确保让ri绑定到一个整数，编译器把上述代码变成了如下形式：
       const int temp = dval; //由双精度浮点数生成一个临时的整形常量
       const int &ri=temp;//让ri绑定这个临时量
       ```

     - 在这种情况下，`ri`绑定了一个**临时量**(temporary)对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。接下来探讨当`ri`不是常量时，如果执行了类似于上面的初始化过程将带来什么样的后果。**如果`ri`不是常量**，就允许对`ri`赋值，这样就会改变`ri`所引用对象的值。注意，此时绑定的对象是一个临时量而非`dval`。 程序员既然让`ri` 引用`dval`，就肯定想通过`ri`改变`dval`的值，否则干什么要给`ri`赋值呢？如此看来，既然大家基本上不会想着把引用绑定到临时量上，==**C++语言也就把这种行为归为非法**==。

   - 指针和`const`

     - **==指向常量的指针==**  `const double pi = 3.14;`
     - ==**常量指针**==必须初始化，而且一日初始化完成，则它的值(也就是存放在指针中的那个地址)就不能再改变了。

   - ==**顶层const**==**表示指针本身是个常量**，==**底层const**==**表示指针所指的对象是一个常量**

7. `constexpr`和常量表达式

   - **常量表达式**是指值不会改变并且在**编译过程就能得到计算结果的表达式**。用常量表达式初始化的`const`对象也是常量表达式。

   - 声明为`constexpr`的变量一定是一个常量，而且必须用常量表达式初始化。

   - ```c++
     constexpr int mf = 20;
     constexpr int limit = mf+1;
     constexpr int sz - size();
     ```

   - 新标准允许定义一种特殊的`constexpr`函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用`constexpr`函数去初始化`constexpr`变量了。

   - 声明`constexpr`时用到的类型必须有所限制，因为这些类型一般比较简单，值也显而易见，容易得到，就把他们称为**字面值类型**。

   - 尽管指针和引用都能定义成`constexpr`, 但它们的初始值却受到严格限制。一个`constexpr`**指针的初始值必须是`nullptr`或者`0`**，或者是存储于某个固定地址中的对象。

     ```c++
     constexpr int *p=nullptr;//constexpr把它所定义的对象置为了顶层const
     
     constexpr int *np=nullptr;//np是一个指向整数的常量指针，其值为空
     int j = 0;
     constexpr int i =42;
     //i和j都必须定义在函数体之外
     
     constexpr const int *p=&i; //p是常量指针，指向整形常量i
     constexpr int *p1=&j;//p1是常量指针，指向整数j
     ```

8. 处理类型

   - 新标准规定了一种新的方法，使用==**别名声明**==`using SI=Sales_ites SI`是`Sales_item`的同义词

     - ```c++
       typedef char *pstring;
       const pstring cstr = 0; //cstr是指向char的常量指针
       const pstring *ps;		//ps是一个指针，它的对象是指向char的常量指针
       ```

     - ==const是对给定类型的修饰==

   - `auto`类型说明符C++11

     - 它让编译器替我们取分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型。**auto定义的变量必须有初始值**
     - `auto`也能在一条语句中**声明多个变量**，因为一条声明语句只能有一个基本数据类型，所以**该语句中所有变量的初始基本类型都必须一样**。
       - `auto sz = 0,pi=3.14`//错误：sz和pi的类型不一致
     - `auto`一般会**忽略**顶层`const`，同时底层`const`**则会保留**下来。
     - **希望推断出的`auto`类型是一个顶层`const`**，需要明确指出：`const auto f = ci`
     - 设置一个类型为`auto`的引用时，初始值中的**顶层常量属性**仍然保留。

   - `decltype`类型指示符C++11

     - **希望从表达式的类型推断出要定义的类型，但是不想用该表达式的值初始化变量**，`decltype`它的作用是选择并返回操作数的数据类型。

       ```c++
       decltype(f()) sum = x; //sum的类型是函数f的返回类型
       //decltype处理顶层const和引用的方式与auto有些许不同
       //decltype使用的表达式是一个变量，则decltype返回该变量的类型(包括顶层const和引用在内)
       const int ci = 0,&cj=ci;
       decltype(ci) x = 0; //x的类型是const int
       decltype(cj) y = x; //y的类型是const int&，y绑定到变量x
       ```

     - **==引用从来都是作为其所指对象的同义词出现，只有用在`decltype`处是一个例外。==**

     - 如果`decltype`使用的表达式不是一个变量，则`decltype`返回表达式结果对应的类型。

       ```c++
       int i = 42,*p=&i,&r=i;
       decltype(r+0) b;//加法的结果是int，因此b是一个（未初始化的）int
       decltype(*P) c;//c是int&,必须初始化
       ```

     - 如果**表达式的内容是解引用操作**，则`decltype`**将得到引用类型**。正如我们所熟悉的那样，**解引用指针可以得到指针所指的对象，而且还能给这个对象赋值**。因此，`decltype ( *p)`的结果类型就是`int&`，而非`int`.

     - ==`decltype((varialbe))`的结果永远是引用，而`decltype(variable)`结果只有当variable本身就是一个引用时才使引用。==

     - 赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。`decltype(a=b) d=a` 表达式`a=b`的类型是`int&`

9. 自定义数据结构

   - **类体右侧的表示结束的花括号后必须写一个分号**，这是**因为**类体后面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少；
   
   - C++11新标准规定，**可以为数据成员提供一个类内初始值**(in-class initializer)。创建对象时，**类内初始值将用于初始化数据成员**。没有初始值的成员将被默认初始化(参见2.2.1节，第40页)。因此当定义`sales_data`的对象时，`units_sold`和 `revenue `都将初始化为0，`bookNo`将初始化为空字符串。
   
     - ```c++
       struct Sales_data
       {
           std::string bookNo;
           unsigned units_sold = 0;
           double revenue = 0.0;
       }
       ```
   
   - 对类内初始值的限制与之前介绍的类似:或者放在花括号里，或者放在等号右边，==**记住不能使用圆括号**==。
   
   - ==**类所在的头文件的名字应与类的名字一样。**==例如`string`在名为`string`的头文件中定义。

### 字符串，向量和数组

#### 命名空间的using声明

- `using std::cin;`using声明，当我们使用名字`cin`时，从命名空间`std`中获取它
- **用到的每个名字都必须有自己的声明语句，而且每句话都以分号结束。**
- 位于==**头文件的代码一般来说不应该使用using声明**==。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。

#### 标准库类型string

1. `string`类型必须首先包含`string`文件。作为标准库的一部分，`string`定义在命名空间`std`中。

   | `string s1`          | 默认初始化，s1是一个空串                                    |
   | :------------------- | ----------------------------------------------------------- |
   | `string s2(s1)`      | s2是s1的副本                                                |
   | `string s2=s1`       | 等价于s2(s1)，s2是s1的副本                                  |
   | `string s3("value")` | s3是字面值"value"的副本，**除了字面值最后的那个空字符外**。 |
   | `string s3="value"`  | 等价于s3("value")，s3是字面值"value"的副本                  |
   | `string s4(n,'c')`   | 把s4初始化为由连续n个字符c组成的串                          |

   <img style="width: 800px;height:300px" src="Image\string的操作.png">

   - 如果使用**等号初始化**一个变量，实际上执行的是==**拷贝初始化**==( copy initialization), 编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果**不使用等号**，则执行的是==**直接初始化**==( direct initialization )。
   - `string s8=string(10,'c');`
   - `cin>>s` 将`string`对象读入`s`，遇到空白停止。`string`对象会自动忽略开头的空白，并从第一个真正的字符开始读起，直到遇到下一处空白为止。
   - `getline`函数参数是**一个输入流**和一个`string`对象，函数从给定的输入流中读入内容，直到遇到换行符为止（==**读入换行符，并不存放换行符**==）`getline`返回它的流参数。
   - 大多数标准库类型都定义了几种配套的类型。这些配套类型体现了示准库类型与机器无关的特性，类型size_ type即是其中的一种。在具体使用的时候，通过作用域操作符来表明名字size_ type是在类string中定义的。
   - 如果两个string对象在**某些对应的位置上不一致**，则string对象比较的**结果**
     其实是string对象中==**第一对相异字符比较的结果**==。

2. 字面值和`string`对象相加

   - 标准库允许把**字符字面值**和**字符串字面值**转换成`string`对象。当把`string`对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保**每个加**
     **法运算符**的**两侧**的运算对象至少有一个是`string`字符串

   - `cctype`头文件和`ctype.h`头文件的内容是一样的，只不过从命名规范上
     来讲更符合C++语言的要求。特别的，在名为`cname`的头文件中定义的名字从属于命名空间`std`,而定义在名为`.h`的头文件中的则不然。

   - ==范围`for`语句==C++11。这种语句**遍历给定序列中每个元素**并对序列中的每个值执行某种操作

     ```c++
     for(declaration:expression)//expression部分是一个对象，用于表示一个序列，declaration部分负责定义一个变量，该变量用于访问序列中的基础元素。每次迭代declaration部分的变量都会被初始化为expression部分的下一个元素值。
         statement;
     
     string str("some string");
     for(auto c:str)
         cout<<c<<endl;
     //如果想改变string对象中的值，必须把循环变量定义成引用类型
     ```

   - 下标运算符`[]`接收的输入参数是`string::size_type`

#### 标准库类型 vector

1. **模板本身不是类或函数**，相反可以将**模板看作为编译器生成类或函数编写的一份说**
   **明**。编译器根据模板创建类或函数的过程称为==**实例化**==(instantiation)，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

   - 在**早期版本的C++标准中**如果vector的元素还是vector (或者其
     他模板类型),则其**定义的形式与现在的C++11新标准略有不同**。过去，必须在外层vector对象的右尖括号和其元素类型之间==**添加一个空格**==，如应该写成`vector<vector<int> >`而非`vector<vector<int>>`。

2. 初始化`vector`对象

   - <img style="width: 900px;height:200px" src="Image\初始化vector.png">

   - 其二，如果**提供的是一个类内初始值**(参见2.6.1节，第64页)，则**只能使用拷贝初始化**或**使用花括号的形式初始化**。第三种特殊的要求是，如果**提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化**，而不能放在圆括号里

   - ==**值初始化**==：通常情况下，可以只提供`vector`对象容纳的**元素数量**而不用略去初始值。此时库会创建一个**值初始化的**( value-initialized) **元素初值**，并把它赋给容器中的所有元素。==**这个初值由vector对象中元素的类型决定**==。

     - 对这种初始化的方式有==**两个特殊限制**==:其一,**有些类要求必须明确地提供初始值**(参见2.2.1节，第40页),如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始的元素值。对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。

   - ==**列表初始值还是元素数量**==

     - 用一个**整数来初始化**`vector<int>`时，**整数的含义**可能是`vector`对象的**容量**也可能是**元素的值**。类似的，用**两个整数来初始化**`vector<int>`时，这两个整数**可能一个是**`vector`对象的**容量**，**另一个是元素的初值**，也可能它们是容量为2`vector`对象中**两个元素的初值**。通过使用花括号或圆括号可以区分上述这些含义

       - ==**圆括号，可以说提供的值是用来构造`vector`对象的**==
       - ==**花括号，可以表述成我们想列表初始化`vector`对象**==

     - 另一方面，如果**初始化时使用了花括号的形式**但是==**提供的值又不能用来列表初始化**==，就要考虑用这样的值来**构造vector对象**了。例如，要想列表初始化一个含有string对象的vector对象，应该提供能赋给string对象的初值。此时不难区分到底是要**列表初始化vector对象的元素**还是用**给定的容量值来构造vector对象**。

       - 提供的值是用来初始化vector的还是vector的元素

         ```c++
         vector<string> v{10};//10被用来构造vector对象，10个字符串被值初始化。
         vector<int> v2{10};//列表初始化，v2有一个int值为10
         ```

   - 如果循环体内部包含有向`vector`对象添加元素的语句，则不能使用范围for循环。==**范围for语句体内不应该改变其所遍历序列的大小**==。

   - <img style="width: 900px;height:200px" src="Image\vector支持的操作.png">

   - 使用vector的`size_type`，`vector<int>::size_type`

#### 迭代器介绍

==所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。==，如果容器为空，则`begin`和`end`返回的是同一个迭代器，都是**尾后迭代器**。

<img style="width: 900px;height:200px" src="Image\标准容器迭代器的运算符.png">

1. 迭代器类型

   - `vector<int>::iterator it; vector<int>::const_iterator it2`
     - `it`能读写，而`it2`只能读
   - `cbegin`和`cend`C++11返回`const_iterator`
   - **箭头运算符**把解引用和成员访问两个操作结合在一起。
   - ==**限制**==：任何一种可能改变`vector`对象容量的操作，比如`push_back`，都会使该`vector`对象的迭代器失效。

2. 迭代器运算

   <img style="width: 900px;height:300px" src="Image\vector和string迭代器支持的运算.png">

   - 迭代器相减是两个迭代器的距离。类型名为`difference_type`的带符号整形数。

#### 数组

1. 编译的时候维度因该是以知的，维度必须是**一个常量表达式**。定义数组的时候必须指定数组的类型，不允许用`auto`**关键字由初始值的列表推断类型**。

   - ```c++
     int (*Parray)[10]=&arr;
     int (&arrRef)[10]=arr;//引用一个含有10个整数的数组
     					  //类型修饰符从右向左依次绑定
     unsigned scores[11]={};//全部初始化为0
     ```

   - ==**就数组而言**==，由**内向外阅读**助我们更好地理解`Parray`的含义:首先是圆括号括起来的部分，`*Parray` 意味着`Parray`是个指针，接下来观察右边，可知道`Parray`是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是`int`。这样最终的含义就明白无误了。

2. 使用数组下标的时候，通常将其定义为**size_t**类型，`size_t`是一种机器相关的的无符号类型。`cstddef`头文件定义了`size_t`类型。

   - 在很多用到**数组名**字的地方，编译器都会自动地将其替换为一个**指向数组首元素的指针**。
   - `auto p(scores);`p的类型是`int*`
   - `decltype(scores) ia;` 此关键字上述转化不会发生，返回的类型是10个整数构成的数组。

3. 标准库函数begin()和end()

   - begin函数返回指向首元素的指针，end函数返回尾元素下一个位置的指针。**定义在`iterator`头文件中**
   - 两个指针相减的结果的类型是一种名为`ptrdiff_ t`的标准库类型，`ptrdiff_t`也是一种定义在`cstddef`头文件中的机器相关的类型。
   - **标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求**

4. 与旧代码的接口

   - `string`对象的复合赋值运算中允许使用**以空字符结束的字符数组**作为右侧的运算对象。
   - `c_str`函数返回的是一个c风格的字符串，指针的类型是`const char*`
   - 使用数组初始化`vector`对象：`vector<int> ivec(begin(arr),end(arr));`

#### 多维数组

```c++
int ia[3][4] = 
{
    {0,1,2,3},
    {4,5,6,7},
    {8,9,10,11}
};
//没有标识每行的花括号，与之前的初始化语句是等价的
int ia[3][4]={0,1,2,3,4,5,6,7,8,9,10,11};
for(auto row:ia)
{//编译器初始化row时会自动将这些数组形式的元素钻换为指向该数组内首元素的指针
    for(auto col:row)
    {//这样得到的row的类型就是int*,显然内层的循环就不合法了。
        
    }
}
```

1. ==**范围for语句处理多维数组时，除了最内层的循环外，其它所有的循环的控制变量都应该是引用类型。**==

   ```c++
   using int_array = int[4];
   typedef int int_array[4];
   int_array *p = ia;//int_array只是类型，需要用*表述是4个元素的指针
   ```

### 表达式

#### 基础

#### 算术运算符

#### 逻辑和关系运算符

#### 赋值运算符

#### 递增和递减运算符

#### 成员访问运算符

#### 条件运算符

#### 位运算符

#### sizeof运算符

#### 逗号运算符

#### 类型转换

#### 运算符优先级表

