## 第1章 开始

1. 一个函数的定义包含**四部分**：返回类型（return type），函数名（function name），一个括号包围的形参列表（parameter list，**允许为空**）,以及函数体（function body）。`mian`**函数的返回值==必须为in==t**。**当return语句包括一个值时**，**此返回值的类型于函数的返回类型相同**。在大多数系统中，`main`的**返回值**都被**用来指示状态**。返回0表示成功，非0的返回值的含义有系统定义，通常用来指出错误类型。**C++程序**，不同的编译器使用不同的后缀命名约定，**最常见的包括**`.cc，.cxx，.cpp，.cp`

2. [MSVC 编译器选项 | Microsoft Learn](https://learn.microsoft.com/zh-cn/cpp/build/reference/compiler-options?view=msvc-170&form=MG0AV3)

3. 初识输入输出

   - `iostream`库包含两个基础类型`istream`和`ostream`分别表示输入流和输出流。

   - 标准库定义了4个IO对象，输入`cin`是`istream`类型对象（**标准输入**）。`cout`为`ostream`类型的对象（**标准输出**）`cerr`和`clog`**标准错误**，`clog`**用来输出程序运行时的一般信息**。

     - 默认情况下，读`cin`会刷新`cout`；程序**非正常终止时**也会刷新`cout`

     - 默认情况下，写到`cerr`的数据是不缓冲的。`cerr`**通常用于输出错误信息**或其它不属于程序正常逻辑的输出内容

     - 写到`clog`**的数据是被缓冲**的，`clog`通常用于报告程序的执行信息，存入一个日志文件中。

   - `#include`指令和头文件的名字必须写在同一行中。`#include`指令必须出现在所有函数之外。

   - `<<`运算符接收两个运算对象：**左侧的运算对象**必须是一个`ostream`对象，**右侧的运算对象**是要打印的值。

     - `<<`运算符**返回左侧的运算对象**，因此第一个运算符的结果成为了第二个运算符的左侧运算对象。

       ```c++
       //我们的表达式等于
       (std::cout<<"Enter two number:")<<std::endl;
       ```

     - `endl`这是一个被称为操作符的特殊值。写入`endl`的效果是**结束当前行，并将于设备关联的缓冲区中的内容刷到设备中。**

     - 程序员常常在调试时添加打印语句。这类语句应该保证“一直”刷新流。否者，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误推断。

   - `>>`**输入运算符**和输出运算符类似，它接收一个`istream`作为其左侧运算对象，接收一个对象作为其右侧运算对象。

   - 当我们使用一个`istream`**对象作为条件时，其效果是检查流的状态**。如果流是有效的，即流遇未到错误，那么检测成功。当遇到文件结束符，或遇到一个无效输入时，`istream`对象的状态会变得无效。处于无效状态的`istream`对象会使条件变为假。

   - 我们通常使用`.h`组为头文件的后缀，但也有一些程序习惯用`.H`，`.hpp`，`.hxx`。**标准库头文件通常不带后缀**。

## 第一部分

### 变量和基本类型

| 类型          | 含义           | 最小尺寸     |
| ------------- | -------------- | ------------ |
| `bool`        | 布尔类型       | 未定义       |
| `char`        | 字符           | 8位          |
| `wchar_t`     | 宽字符         | 16位         |
| `char16_t`    | Unicode字符    | 16位         |
| `char32_t`    | Unicode字符    | 32位         |
| `short`       | 短整形         | 16位         |
| `int`         | 整形           | 16位         |
| `long`        | 长整形         | 32位         |
| `long long`   | 长整形         | 64位         |
| `float`       | 单精度浮点数   | 6位有效数字  |
| `double`      | 双精度浮点数   | 10位有效数字 |
| `long double` | 扩展精度浮点数 | 10位有效数字 |

1. `wchar_t`类型用于**确保可以存放机器最大扩展字符集**中的任意一个字符，类型`char16_t`和`char32_t`则为`Unicode`字符集服务。
   
   - 字符型被分为了三种：`char`，`signed char`和`unsigned char`，**尽管字符型有三种，但是字符型的表现形式却只有两种**：带符号的和无符号的。类型char实际上会表现为上述两种形式的一种，**具体是哪种由编译器决定**。
   
2. **选择类型的一些经验准则**
   
   - **数值不可能为负**时，选用无符号类型。
   - 使用`int`执行整数运算，`short`常常显得太小而`long`一般和`int`有一样的尺寸。数值超过了`int`的表示范围，选用`long long`。
   - 在算术表达式种不要用`char`或`bool`，只有在**存放字符**或**布尔值**时才使用它。因为类型`char`在一些机器上是有符号的，而在另一些机器上又是无符号的，所以说如果使用`char`进行运算特别容易出问题。如果**你需要使用一个不大的整数**，那么==**明确指定他的类型是**==`signed char`或者`unsigned char`。
   
3. 类型转换
   - **非布尔值类型**的算数值**赋值给布尔值类型**时，初始值为**0**则结果为**false**，否则结构为true。
   
   - **赋给无符号类型一个超出它表示范围的值**时，结果是初始值对无符号类型表示数值总数**取模后的余数**。
   
   - 赋给一个带符号类型一个超出它能表示范围的值时，结果是**未定义的**。
   
   - ==**程序应该尽量避免依赖于实现环境的行为**==
   
   - ==**当一个算术表达式中既有无符号数又有`int`值时，`int`值就会转换成无符号的**==
   
     - 把负数转换成无符号数类型类似于直接给无符号数赋一个负值，**结果等于这个负数加上无符号数的模**
     - ==**不要混用带符号类型和无符号类型**==
   
   - 默认情况下，**十进制==字面值==是带符号数**，八进制和十六进制值字面值即可能是带符号的也可能是无符号的。
   
   - **泛化的转义序列**：形式是`\X`后紧跟1个或多个十六进制数字，或者\后紧**跟1个，2个或3个**八进制数字。
   
     - \115(字符M)\x4d(字符M)
   
   - 指定字面值类型
   
     | 前缀 | 含义                      | 类型       |
     | ---- | ------------------------- | ---------- |
     | `u`  | Unicode16字符             | `char16_t` |
     | `U`  | Unicode32字符             | `char32_t` |
     | `L`  | 宽字符                    | `wchar_t`  |
     | `u8` | UTF-8(仅用于字符串字面零) | `char`     |
   
   - `nullptr`**指针字面值**。

#### 变量

1. 变量的定义

   - 初始化不是赋值，**初始化的含义是创建变量时赋予其一个初始值**，而赋值的含义是把对象的当前值擦除,而以一个新值来替代。

   ```c++
   int units_sold = 0;
   int units_sold ={0};
   int units_sold{0};//C++ 11 列表初始化
   int units_sold(0);
   ```

   - 如果我们使用**列表初始化且初始值存在丢失信息**的风险，则编译器将报错：

     ```c++
     long double ld = 3.1415926536;
     int a{ld},b{ld} //错误：转化未执行，因为存在丢失信息的风险
     int c(ld),d=ld; //正确：转换执行，且确实丢失了部分值
     ```

2. ==**默认初始化**==

   - 定义于任何函数体之外的变量被初始化为0
   - 定义于函数体内部的内置类型变量将**不被初始化**。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其它形式访问此类值将引发错误。
   - 每个**类各自决定其初始化对象的方式**。而且，**是否允许不经初始化就定义对象也由类自己决定**。如果类允许这种行为，它将决定对象的初始值到底是什么。**绝大多数类都支持无须显式初始化而定义对象**，这样的类提供了一个合适的默认值。例如，==string类规定如果没有指定初值则生成一个空串==
   - ==**声明一个变量而非定义它**==，就在**变量名前添加关键字extern**,而且不要显式地初始化变量:`extern int i`
     - 我们**能给由extern关键字标记的变量赋一个初始值**，但是这么做也就抵消了extern的作用。**extern语句如果包含初始值就不再是声明，而变成定义了**
     - ==在函数体内部，初始化一个由`extern`关键字标记的变量，将引发错误。==

3. 标识符

   - C++标识符的长度没有限制，但是对大小写字母敏感。

   - C++标准库保留了一些名字，**用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头，定义在函数体外的标识符不能以下划线开头。**

     <img style="width: 1200px;height:600px" src="Image\C++关键字.png">

   - **作用域中一旦声明了某个名字**，它所**嵌套着的所有作用域中都能访问该名字**。同时，**允许在==内层作用域中重新定义==外层作用域已有的名字**。

     ```c++
     int reused = 42;
     int main()
     {
         int unique = 0;
         cout<<reused<<" "<<unique<<endl;//使用全局变量reused
         int reused = 0; //新建局部变量reused，覆盖全局变量reused
         cout<<reused<<" "<<unique<<endl;
         //显示地访问全局变量reused
         cout<<::reused<<" "<<unique<<endl;
     }
     ```

   - 因为**全局作用域本身并没有名字**，所以**当作用域操作符的左侧为空时，向全局作用域发出请求**获取作用域操作符右侧名字对应的变量。

4. 复合类型

   - 定义引用时，程序把引用和它的初始值**绑定**在一起，而不是将初始值拷贝给引用，一旦初始化完成，**引用将和它的初始值和对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象**，==因此引用必须初始化。==

     - ==引用并非对象，他只是为一个已经存在的对象所起的另外一个名字==。
     - 因为引用本身不是一个对象，所以不能定义引用的引用。
     - 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。

   - **指针本身就是一个对象**。

     - ==**因为引用不是对象，没有实际地址，所以不能定义指向引用的指针**==

     - ```c++
       //生成空指针的方法
       int *p1=nullptr;
       int *p2=0;
       //需包含cstdlib
       int *p3=NULL;
       ```

     - ==一个指针指向某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同的情况，即指针相等。==

     - `void*`是一种特殊的指针类型，**可用于存放任意对象的地址**。因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。

       ```c++
       int i =42;
       int *p;		//p是一个int型的指针
       int *&r=p;	//r是一个对指针p的引用
       
       r=&i;	//r引用了一个指针，因此给r赋值&i就是令p指向i
       *r=0;	//解引用r得到i，也就是p指向的对象，将i的值改为0
       ```

     - **面对一条比较复杂的指针或者引用的声明语句时，==从右往左阅读==有助于弄清楚它的真实含义。**

5. `const`限定符

   - 因为`const`对象一旦创建后就不能改变，所以`const`**对象必须初始化**。
   - **==默认情况下，`const`对象被设定为仅在文件内有效==，当文件中出现了多个同名的`const`变量时，其实就等同于在不同文件中分别定义了独立的变量。**
   - 某些时候有这样一种`const`变量，它的初始值不是一个常量表达式，但又确实有必要**在文件间共享**。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类`const`对象像其他(非常量)对象一样工作，也就是说，**只在一个文件中定义**`const`,而在**其他多个文件中声明并使用它**。解决的办法是，对于`const`==变量不管是声明还是定义都添加`extern`关键字==，这样只需定义一次就可以了:
     - `extern const int bufSize = fcn();`
     - `extern const int bufSize;`

6. `const`的引用

   - ==**对常量的引用**==

     - 引用的类型必须与其所引用对象的类型一致， 但是有**两个例外**。第一种例外情况就是在**==初始化常量引用==时允许用任意表达式作为初始值**，**只要该表达式的结果能转换成引用的类型即可**。尤其，==**允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式**==。

       ```c++
       double dval = 3.14;
       const int &ri=dval;
       //ri引用了一个int型的数。对ri的操作因该是整数运算，但dval却是一个双精度浮点数而非整数，因此为了确保让ri绑定到一个整数，编译器把上述代码变成了如下形式：
       const int temp = dval; //由双精度浮点数生成一个临时的整形常量
       const int &ri=temp;//让ri绑定这个临时量
       ```

     - 在这种情况下，`ri`绑定了一个**临时量**(temporary)对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。接下来探讨当`ri`不是常量时，如果执行了类似于上面的初始化过程将带来什么样的后果。**如果`ri`不是常量**，就允许对`ri`赋值，这样就会改变`ri`所引用对象的值。注意，此时绑定的对象是一个临时量而非`dval`。 程序员既然让`ri` 引用`dval`，就肯定想通过`ri`改变`dval`的值，否则干什么要给`ri`赋值呢？如此看来，既然大家基本上不会想着把引用绑定到临时量上，==**C++语言也就把这种行为归为非法**==。

   - 指针和`const`

     - **==指向常量的指针==**  `const double pi = 3.14;`
     - ==**常量指针**==必须初始化，而且一旦初始化完成，则它的值(也就是存放在指针中的那个地址)就不能再改变了。

   - ==**顶层const**==**表示指针本身是个常量**，==**底层const**==**表示指针所指的对象是一个常量**

7. `constexpr`和常量表达式

   - **常量表达式**是指值不会改变并且在***==编译过程==*就能得到计算结果的表达式**。用常量表达式初始化的`const`对象也是常量表达式。

   - 声明为`constexpr`的变量一定是一个常量，而且必须用常量表达式初始化。

   - ```c++
     constexpr int mf = 20;
     constexpr int limit = mf+1;
     constexpr int sz - size();
     ```

   - 新标准允许定义一种特殊的`constexpr`函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用`constexpr`函数去初始化`constexpr`变量了。

   - **声明`constexpr`时==用到的类型==必须有所限制**，因为这些类型一般比较简单，值也显而易见，容易得到，就把他们称为**字面值类型**。

   - 尽管指针和引用都能定义成`constexpr`, 但它们的初始值却受到严格限制。一个`constexpr`**指针的初始值必须是`nullptr`或者`0`**，或者是存储于某个固定地址中的对象。

     ```c++
     constexpr int *p=nullptr;//constexpr把它所定义的对象置为了顶层const
     
     constexpr int *np=nullptr;//np是一个指向整数的常量指针，其值为空
     int j = 0;
     constexpr int i =42;
     //i和j都必须定义在函数体之外
     
     constexpr const int *p=&i; //p是常量指针，指向整形常量i
     constexpr int *p1=&j;//p1是常量指针，指向整数j
     ```

8. 处理类型

   - 新标准规定了一种新的方法，使用==**别名声明**==`using SI = Sales_ites SI`是`Sales_item`的同义词

     - ```c++
       typedef char *pstring;
       const pstring cstr = 0; //cstr是指向char的常量指针
       const pstring *ps;		//ps是一个指针，它的对象是指向char的常量指针
       ```

     - ==const是对给定类型的修饰==

   - `auto`类型说明符C++11

     - 它让编译器替我们取分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型。**auto定义的变量必须有初始值**
     - `auto`也能在一条语句中**声明多个变量**，因为一条声明语句只能有一个基本数据类型，所以**该语句中所有变量的初始基本类型都必须一样**。
       - `auto sz = 0,pi=3.14`//错误：sz和pi的类型不一致
     - `auto`一般会**忽略**顶层`const`，同时底层`const`**则会保留**下来。
     - **希望推断出的`auto`类型是一个顶层`const`**，需要明确指出：`const auto f = ci`
     - **设置一个类型为`auto`的==引用时==**，初始值中的**顶层常量属性**仍然保留。

   - `decltype`类型指示符C++11

     - **希望从表达式的类型推断出要定义的类型，但是不想用该表达式的值初始化变量**，`decltype`它的作用是选择并返回操作数的数据类型。

       ```c++
       decltype(f()) sum = x; //sum的类型是函数f的返回类型
       //decltype处理顶层const和引用的方式与auto有些许不同
       //decltype使用的表达式是一个变量，则decltype返回该变量的类型(包括顶层const和引用在内)
       const int ci = 0,&cj=ci;
       decltype(ci) x = 0; //x的类型是const int
       decltype(cj) y = x; //y的类型是const int&，y绑定到变量x
       ```

     - **==引用从来都是作为其所指对象的同义词出现，只有用在`decltype`处是一个例外。==**

     - 如果`decltype`使用的表达式不是一个变量，则`decltype`返回表达式结果对应的类型。

       ```c++
       int i = 42,*p=&i,&r=i;
       decltype(r+0) b;//加法的结果是int，因此b是一个（未初始化的）int
       decltype(*P) c;//c是int&,必须初始化
       ```

     - 如果**表达式的内容是解引用操作**，则`decltype`**将得到引用类型**。正如我们所熟悉的那样，**解引用指针可以得到指针所指的对象，而且还能给这个对象赋值**。因此，`decltype ( *p)`的结果类型就是`int&`，而非`int`.

     - ==`decltype((varialbe))`的结果永远是引用，而`decltype(variable)`结果只有当variable本身就是一个引用时才使引用。==

     - **赋值是会产生引用的一类典型表达式**，引用的类型就是左值的类型。`decltype(a=b) d=a` 表达式`a=b`的类型是`int&`

9. 自定义数据结构

   - **类体右侧的表示结束的花括号后必须写一个分号**，这是**因为**类体后面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少；
   
   - C++11新标准规定，**可以为数据成员提供一个类内初始值**(in-class initializer)。创建对象时，**类内初始值将用于初始化数据成员**。没有**初始值的成员将被默认初始化**(参见2.2.1节，第40页)。因此当定义`sales_data`的对象时，`units_sold`和 `revenue `都将初始化为0，`bookNo`将初始化为空字符串。
   
     - ```c++
       struct Sales_data
       {
           std::string bookNo;
           unsigned units_sold = 0;
           double revenue = 0.0;
       }
       ```
   
   - 对类内初始值的限制与之前介绍的类似:或者放在花括号里，或者放在等号右边，==**记住不能使用圆括号**==。
   
   - ==**类所在的头文件的名字应与类的名字一样。**==例如`string`在名为`string`的头文件中定义。

### 字符串，向量和数组

#### 命名空间的using声明

- `using std::cin;` `using`声明，当我们使用名字`cin`时，从命名空间`std`中获取它
- **用到的每个名字都必须有自己的声明语句，而且每句话都以分号结束。**
- 位于==**头文件的代码一般来说不应该使用using声明**==。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。

#### 标准库类型string

1. `string`类型必须首先包含`string`文件。作为标准库的一部分，`string`定义在命名空间`std`中。

   | `string s1`          | 默认初始化，s1是一个空串                                    |
   | :------------------- | ----------------------------------------------------------- |
   | `string s2(s1)`      | s2是s1的副本                                                |
   | `string s2=s1`       | 等价于s2(s1)，s2是s1的副本                                  |
   | `string s3("value")` | s3是字面值"value"的副本，**除了字面值最后的那个空字符外**。 |
   | `string s3="value"`  | 等价于s3("value")，s3是字面值"value"的副本                  |
   | `string s4(n,'c')`   | 把s4初始化为由连续n个字符c组成的串                          |

   <img style="width: 1200px;height:500px" src="Image\string的操作.png">

   - 如果使用**等号初始化**一个变量，实际上执行的是==**拷贝初始化**==( copy initialization), 编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果**不使用等号**，则执行的是==**直接初始化**==( direct initialization )。
   - `string s8=string(10,'c');`
   - `cin>>s` 将`string`对象读入`s`，==**遇到空白停止**==。`string`对象会自动忽略开头的空白，并从第一个真正的字符开始读起，直到遇到下一处空白为止。
   - `getline`函数参数是**一个输入流**和一个`string`对象，函数从给定的输入流中读入内容，直到遇到换行符为止（==**读入换行符，并不存放换行符**==）`getline`返回它的流参数。
   - 大多数标准库类型都定义了几种配套的类型。这些配套类型体现了示准库类型与机器无关的特性，类型`size_type`即是其中的一种。在具体使用的时候，通过作用域操作符来表明名字`size_type`是在类`string`中定义的。
   - 如果两个`string`对象在**某些对应的位置上不一致**，则`string`对象比较的**结果**。其实是`string`对象中==**第一对相异字符比较的结果**==。
   
2. 字面值和`string`对象相加

   - 标准库允许把**字符字面值**和**字符串字面值**转换成`string`对象。当把`string`对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保**每个加法运算符**的**两侧**的运算对象至少有一个是`string`字符串。
     
   - `cctype`头文件和`ctype.h`头文件的内容是一样的，只不过从命名规范上来讲更符合C++语言的要求。特别的，在名为`cname`的头文件中定义的名字从属于命名空间`std`,而定义在名为`.h`的头文件中的则不然。
     
   - ==范围`for`语句==C++11。这种语句**遍历给定序列中每个元素**并对序列中的每个值执行某种操作

     ```c++
     for(declaration:expression)//expression部分是一个对象，用于表示一个序列，declaration部分负责定义一个变量，该变量用于访问序列中的基础元素。每次迭代declaration部分的变量都会被初始化为expression部分的下一个元素值。
         statement;
     
     string str("some string");
     for(auto c:str)
         cout<<c<<endl;
     //如果想改变string对象中的值，必须把循环变量定义成引用类型
     ```
   
   - 下标运算符`[]`接收的输入参数是`string::size_type`

#### 标准库类型 vector

1. **模板本身不是类或函数**，相反可以将**模板看作为编译器生成类或函数编写的一份说明**。编译器根据模板创建类或函数的过程称为==**实例化**==(instantiation)，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。
   
   - 在**早期版本的C++标准中**如果`vector`的元素还是`vector` (或者其他模板类型),则其**定义的形式与现在的C++11新标准略有不同**。过去，必须在外层vector对象的右尖括号和其元素类型之间==**添加一个空格**==，如应该写成`vector<vector<int> >`而非`vector<vector<int>>`。
   
2. 初始化`vector`对象

   <img style="width: 900px;height:300px" src="Image\初始化vector.png">

   - 其二，如果**提供的是一个类内初始值**(参见2.6.1节，第64页)，则**只能使用拷贝初始化**或**使用花括号的形式初始化**。第三种特殊的要求是，如果**提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化**，而不能放在圆括号里。

   - ==**值初始化**==：通常情况下，可以只提供`vector`对象容纳的**元素数量**而不用略去初始值。此时库会创建一个**值初始化的**( value-initialized) **元素初值**，并把它赋给容器中的所有元素。==**这个初值由vector对象中元素的类型决定**==。内置类型设置为0，类类型执行默认初始化。

     - 对这种初始化的方式有==**两个特殊限制**==:其一,**有些类要求必须明确地提供初始值**(参见2.2.1节，第40页),如果`vector`对象中元素的类型不支持默认初始化，我们就必须提供初始的元素值。对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。

   - ==**列表初始值还是元素数量**==

     - 用一个**整数来初始化**`vector<int>`时，**整数的含义**可能是`vector`对象的**容量**也可能是**元素的值**。类似的，用**两个整数来初始化**`vector<int>`时，这两个整数**可能一个是**`vector`对象的**容量**，**另一个是元素的初值**，也可能它们是容量为2`vector`对象中**两个元素的初值**。通过使用花括号或圆括号可以区分上述这些含义

       - ==**圆括号，可以说提供的值是用来构造`vector`对象的**==
       - ==**花括号，可以表述成我们想列表初始化`vector`对象**==

     - 另一方面，如果**初始化时使用了花括号的形式**但是==**提供的值又不能用来列表初始化**==，就要考虑用这样的值来**构造vector对象**了。例如，要想列表初始化一个含有string对象的vector对象，应该提供能赋给string对象的初值。此时不难区分到底是要**列表初始化vector对象的元素**还是用**给定的容量值来构造vector对象**。

       - 提供的值是用来初始化vector的还是vector的元素

         ```c++
         vector<string> v{10};//10被用来构造vector对象，10个字符串被值初始化。
         vector<int> v2{10};//列表初始化，v2有一个int值为10
         ```

   - 如果循环体内部包含有向`vector`对象添加元素的语句，则不能使用范围for循环。==**范围for语句体内不应该改变其所遍历序列的大小**==。

   - <img style="width: 900px;height:300px" src="Image\vector支持的操作.png">

   - 使用vector的`size_type`，`vector<int>::size_type`

#### 迭代器介绍

==所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。==，如果容器为空，则`begin`和`end`返回的是同一个迭代器，都是**尾后迭代器**。

<img style="width: 900px;height:200px" src="Image\标准容器迭代器的运算符.png">

1. 迭代器类型

   - `vector<int>::iterator it; vector<int>::const_iterator it2`
     - `it`能读写，而`it2`只能读
   - `cbegin`和`cend`C++11返回`const_iterator`
   - ==**限制**==：任何一种可能改变`vector`对象容量的操作，比如`push_back`，都会使该`vector`对象的迭代器失效。
   
2. 迭代器运算

   <img style="width: 900px;height:400px" src="Image\vector和string迭代器支持的运算.png">

   - 迭代器相减是两个迭代器的距离。==**类型名为`difference_type`的带符号整形数**==。

#### 数组

1. 编译的时候维度因该是以知的，维度必须是**一个常量表达式**。定义数组的时候必须指定数组的类型，不允许用`auto`**关键字由初始值的列表推断类型**。

   - ```c++
     int (*Parray)[10]=&arr;
     int (&arrRef)[10]=arr;//引用一个含有10个整数的数组
     					  //类型修饰符从右向左依次绑定
     unsigned scores[11]={};//全部初始化为0
     ```

   - ==**就数组而言**==，由**内向外阅读**助我们更好地理解`Parray`的含义:首先是圆括号括起来的部分，`*Parray` 意味着`Parray`是个指针，接下来观察右边，可知道`Parray`是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是`int`。这样最终的含义就明白无误了。

2. 使用数组下标的时候，通常将其定义为**size_t**类型，`size_t`是一种机器相关的的无符号类型。==**`cstddef`头文件**==定义了`size_t`类型。

   - 在很多用到**数组名**字的地方，编译器都会自动地将其替换为一个**指向数组首元素的指针**。
   - `auto p(scores);`p的类型是`int*`
   - `decltype(scores) ia;` **此关键字上述转化不会发生**，返回的类型是10个整数构成的数组。

3. 标准库函数`begin()`和`end()`

   - `begin`函数返回指向首元素的指针，`end`函数返回尾元素下一个位置的指针。**定义在`iterator`头文件中**
   - 两个指针相减的结果的类型是一种名为`ptrdiff_ t`的标准库类型，`ptrdiff_t`也是一种==**定义在`cstddef`头文件中**==的机器相关的类型。
   - **==标准库类型限定使用的下标必须是无符号类型==，而内置的下标运算无此要求**

4. 与旧代码的接口

   - `string`对象的复合**赋值**运算中允许使用**以空字符结束的字符数组**作为右侧的运算对象。
   - `c_str`函数返回的是一个c风格的字符串，**指针的类型是**`const char*`
   - 使用数组初始化`vector`对象：`vector<int> ivec(begin(arr),end(arr));`

#### 多维数组

```c++
int ia[3][4] = 
{
    {0,1,2,3},
    {4,5,6,7},
    {8,9,10,11}
};
//没有标识每行的花括号，与之前的初始化语句是等价的
int ia[3][4]={0,1,2,3,4,5,6,7,8,9,10,11};
for(auto row:ia)
{//编译器初始化row时会自动将这些数组形式的元素转换为指向该数组内首元素的指针
    for(auto col:row)
    {//这样得到的row的类型就是int*,显然内层的循环就不合法了。
        
    }
}
```

1. ==**范围for语句处理多维数组时，除了最内层的循环外，其它所有的循环的控制变量都应该是引用类型。**==

   ```c++
   using int_array = int[4];
   typedef int int_array[4];
   int_array *p = ia;//int_array只是类型，需要用*表述是4个元素的指针
   ```

### 表达式

#### 基础

**同一组内**的运算符**优先级相同**，组的位置越**靠前**组内的运算符**优先级越高**。

<img style="width: 1200px;height:700px" src="Image\运算符优先级表1.png">

<img style="width: 1200px;height:1200px" src="Image\运算符优先级表2.png">

- 函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。
- 一般的二元运算符都要求两个**运算对象相同**，但是很多时候即使运算对象的类型不行同也没有关系，只要他们能被**转换成同一种类型**。
- 使用关键字`decltype`的时候，左值和右值也有所不同。如果==**表达式的求值结果是左值**==，`decltype` **作用于该表达式**(不是变量)得到一个引用类型。
- **优先级**于**结合率**
  - 算术运算符满足左结合率，如果**优先级相同**，将按照从**左向右**的顺序**组合运算对象**
  - **优先级规定了运算对象的组合方式**，**但是没有说明运算对象按照什么顺序求值**。在大多数情况下，==**不会明确指定求值的顺序**==。`int i = f1()*f2();`
  - **求值顺序**、**优先级**、**结合律**
    - **运算对象的求值顺序与优先级和结合律无关**，在一条形如f()+g()*h()+j()的表达式中:
      - **优先级规定**，g()的返回值和h()的返回值相乘。
      - **结合律规定**，f()的返回值先与g()和h()的乘积相加，所得结果再与j ()的返回值相加。
      - 对于这些函数的调用顺序没有明确规定。
- 括号无视优先级与结合律

#### 算术运算符

1. 布尔类型的==**运算对象**==将被提升为`int`类型

#### 逻辑和关系运算符

1. 逻辑运算符和关系运算符的**返回值都是布尔类型**
2. 逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，**当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值**。

#### 赋值运算符

1. ==**赋值运算的结果是它的左侧运算对象**==，并且是一个左值。
2. **赋值运算优先级较低**
3. 使用复合运算符只求值一次，使用普通的运算符则求值两次。这两次包括:一 次是作为右边子表达式的一部分求值，另一次是作为赋值运算的左侧运算对象求值。其实在很多地方，**这种区别除了对程序性能有些许影响外几乎可以忽略不计**。

#### 递增和递减运算符

1. 前置版本，这种形式的运算符首先将运算对象加1 (或减1)，然后将改变后的对象作为求值结果。**后置版本**也会将运算对象加1 (或减1)，但是**求值结果是运算对象改变之前那个值的==副本==**。

#### 成员访问运算符

#### 条件运算符

1. 条件运算符`?:`允许我们把简单的if-else逻辑嵌入到单个表达式中
   - 当条件表达符的**==两个表达式都是左值或者能转换成同一种左值类型时==**，**运算的结果是左值**：否则运算的结果是右值。
   - 条件运算符的优先级非常底。

#### 位运算符

- 如果运算对象是**带符号**的且**它的值为负**，那么位运算符如何处理运算符对象的==**符号位依赖于机器**==。而且此时的左移操作可能会改变符号位的值，因此是一种未定义的行为。

- 这两种运算符的内置含义是对其**运算对象执行基于二进制位的移动操作**，首先令左侧运算对象的内容**按照右侧运算对象的要求移动指定位数**，然后将经过移动的(可能还进行了提升)左侧运算对象的==**拷贝作为求值结果**==。其中，==**右侧的运算对象一定不能为负**==，而且值必须严格小于结果的位数，否则就会产生未定义的行为。二进制位或者向左移(<<)或者向右移(>>)，移出边界之外的位就被舍弃掉了。

- `>>`如果该运算对象是**带符号类型**，在左侧插入带符号位的副本或者值位0的二进制位，==**如何选择要视具体环境而定。**==
- `char`为运算对象时，`char`会提升为`int`
- `^`**位异或**运算符**有且只有一个1**结果为1，否则为0。

#### `sizeof`运算符

- `sizeof`右结合律，**所得的值是一个==size_t==**类型。`sizeof(type)`或`sizeof expr`，`sizeof`==**并不实际计算其运算对象的值**==
- 对`char`或者类型为`char`的表达式执行`sizeof`运算，结果得1。
- 对**引用类型执行**`sizeof`运算得到**被引用对象**所占空间的大小。
- 对**指针执行**`sizeof`运算得到**指针本身所占空间**的大小。
- 对**解引用指针执行**`sizeof`运算得到**指针指向的对象所占空间的大小**，**==指针不需有效==**。
- **对数组执行**`sizeof`运算**得到整个数组所占空间的大小**，等价于对数组中所有的元素各执行一次`sizeof`运算并将所得结果求和。注意，`sizeof`==**运算不会把数组转换成指针来处理。**==
- 对`string`对象或`vector`对象执行`sizeof`运算**只返回该类型固定部分的大小**，不会计算对象中的元素占用了多少空间。

#### 逗号运算符

- 对于逗号运算符来说，**首先对左侧的表达式求值，然后将求值结果丢弃掉**。**逗号运算符==真正的结果==是右侧表达式的值**。如果右侧运算对象是左值，那么最终的求值结果也是左值。
  - `somevalue?++x,++y:--x,--y`实际上等于`(somevalue?++x,++y:--x),--y`首先判断`someValue`是否为真，如果为真，依次执行++x和++y，==**最后执行--y**==; 如果为假，执行--x和--y。

#### 类型转换

- 算术转换

  - **运算符**的**运算对象**将转换成**最宽的类型**。当表达式中**既有浮点类型**也**有整数类型**时，整形值将转**换成相应的浮点类型**。
  - **整形提升**负责把小整数类型转换成较大的整数类型，`bool,char,signed char,unsigned char,short,unsigned short`只要**他们所有可能的值都能存在`int`里**，他们就会**提升为**`int`类型。**否则提升为**`unsigned int`**类型**。
  - 较大的`char`类型(`wchar_ t.char16_ t.char32_ t `)提升成`int、unsigned int、long、unsigned long、long long和unsigned long long`中**最小的一种类型**，前提是**转换后的类型要能容纳原类型所有可能的值**。

- 无符号类型的运算对象

  - 类型不一致，这些运算对象将转换成同一种类型。但是如果**某个运算对象的类型是无符号类型**，那么**转换的结果**就要**依赖于**机器中各个整数类型的**相对大小**了
  - 如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且其中的**无符号类型不小于带符号类型**，那么**带符号的运算对象转换成无符号**的。例如，假设两个类型分别是`unsigned int`和`int`，则`int`类型的运算对象转换成`unsigned int`类型。需要注意的是，如果`int`型的==**值恰好为负值**==，其结果将以2.1.2节(第32页)介绍的方法转换，并带来该节描述的所有副作用。
  - 剩下的一种情况是**带符号类型大于无符号类型**，此时转换的结果依赖于机器。如果**无符号类型的所有值**都**能存在该带符号类型中**，则**无符号类型的运算对象转换成带符号类型**。如果不能，那么带符号类型的运算对象转换成无符号类型。例如，如果两个运算对象的类型分别是`long`和`unsigned int`,并且`int`和`long`的大小相同，则`long`类型的运算对象转换成`unsigned int` 类型;如果`long`类型占用的空间比`int`更多，则`unsigned int`类型的运算对象转换成`long`类型。

- 其它隐式类型钻换

  - 当==**数组**==被用作`decltype`关键字的参数，或==**者作为取地址符(&)**==、`sizeof` 及`typeid`(第19.2.2 节，732页将介绍)等运算符的运算对象时，**数组不会自动转换成指向数组首元素的指针**。
  - ==**类类型定义的转换**==：类类型能定义由编译器自动执行的转换，不过**编译器每次只能执行一种类类型的转换**。在7.5.4节(第263页)中我们将看到一个例子，如果同时提出多个转换请求，这些请求将被拒绝。

- 显示转换

  - `cast-name<type>(expression)` type是转换的目标类型，expression是要转换的值，cast-name是`static_cast，dynamic_cast，const_cast，reinterpret_cast`中的一种，cast-name指定了**执行的是哪种转换**

  - `static_cast`

    - 任何具有明确定义的类型转换，只要==**不包含底层**==`const`,都可以使用static_ cast.
      - “**有明确定义的类型转换**”指的是那些在语言规范中明确规定可以进行的类型转换。这意味着这些类型转换是安全的、合法的，并且编译器知道如何正确地执行它们。
    - 当需要把**一个较大的算术类型赋值给较小的类型时**，static_ cast非常有用。此时，强制类型转换告诉程序的读者和编译器:我们知道并且不在乎潜在的精度损失。一般来说，如果**编译器发现一个较大的算术类型试图赋值给较小的类型，就会给出警告信息**;但是当我们执行了显式的类型转换后，警告信息就会被关闭了。

  - `const_cast`

    - `const_cast`==**只能改变运算对象的底层const**==

    - ```c++
      const char *pc;
      char *p = const_cast<char*>(pc);
      //正确：但是通过p写值是未定义的行为。
      ```

    - ==**只有`const_cast`能改变表达式的常量属性**==，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。同样的，也不能用`const_ cast`改变表达式的类型。

  - `reinterpret_cast`

    - ==**通常为运算对象的位模式提供较低层次上的重新解释**==。

  - ==**避免强制类型转换**==

    - 强制类型转换干扰了正常的类型检查(参见2.2.2节，第42页)，因此我们强烈建议程序员避免使用强制类型转换。这个建议对于`reinterpret_cast`尤其适用，因为此类类型转换总是充满了风险。在有重载函数的上下文中使用`const_cast`无可厚非，关于这一点将在6.4节(第208页)中详细介绍;但是在其他情况下使用`const_cast`也就意味着程序存在某种设计缺陷。其他强制类型转换，比如`static_cast`和`dynamic_ cast`,都不应该频繁使用。 每次书写了一条强制类型转换语句，都应该反复斟酌能否以其他方式实现相同的目标。就算实在无法避免，也应该尽量限制类型转换值的作用域，并且记录对相关类型的所有假定，这样可以减少错误发生的机会。

  - 旧式的强制类型钻换

    - type(expr) 函数式的强制类型转换
    - (type) expr C语言风格的强制类型转换

### 语句

#### 简单语句

- 如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使==**用空语句**==。`;`

#### 语句作用域

- 定义在**控制结构当中的变量只在相应语句的内部可见**。

#### 条件语句

- `else`于**离他最近的尚未匹配**的`if`匹配，从而消除了程序的二义性。

- `case`标签==**必须是整形常量表达式**==，任何两个`case`标签的值不能相同

- ```c++
  switch(ch)
  {//写在一行里，强调这些case代表的是某个范围内的值
      case 'a': case'e': case'i': case'o': case'u':
         	++vowelcnt;
          break;
  }
  ```

- `switch`内部的变量定义

  - ==**不允许跨过变量的初始化语句直接跳到转到该变量作用域的另一个位置。**==
  - 如果某个`case`分支定义并初始化一个变量，我们因该把变量定义在块内。

#### 迭代语句

- `for`语句省略`condition`的效果等价于在条件部分写了一个`true`。

- 范围`for`语句每次迭代都会重新定义循坏控制变量，并将其初始化成序列中的下一个值。

- ```c++
  //范围for语句与之等价的传统for语句
  for(auto beg = v.begin(),end = v.end();beg!=end;++beg)
  {
      auto &r = *beg;
      r*=2;
  }
  //范围for中预存了begin和end的值，一旦在序列中添加(删除)元素，预存的值可能失效。
  ```

- `do while`语句

  - ==**`condition`使用的变量必须定义在循环体之外**==。
  - 先执行语句或块，后判断条件，所以不允许在条件部分定义变量。

#### 跳转语句

- `continue`对于`while`或者`do while`来说**继续判断条件的值**，对于`for`循环来说，==**继续执行`for`语句头的`expression`**==`for(;;expression)`
- ==**标签标示符独立于变量或其他标示符的名字**==，因此，标签标示符可以和程序中其他实体的标示符使用同一个名字而不会相互干扰。`goto`==**语句和控制权转向的那条带标签的语句必须位于同一个函数之内**==。

#### try语句块和异常处理

- 当程序的**某部分检测到一个它无法处理的问题**时，需要用到异常处理。此时，**检测出问题的部分应该发出某种信号以表明程序遇到了故障**，无法继续下去了，而且**信号的发出方无须知道故障将在何处得到解决**。一旦发出异常信号，检测出问题的部分也就完成了任务。如果程序中**含有可能引发异常的代码**，那么**通常也会有专门的代码处理问题**。例如，如果程序的问题是输入无效，则异常处理部分可能会要求用户重新输入正确的数据;如果丢失了数据库连接，会发出报警信息。

- ==**抛出异常将终止当前的函数**==，并把控制权转移给能处理该异常的代码。

  ```c++
  if(item1.isbn()!=item2.isbn())
  {
      throw runtime_error("Data must refer to same ISBN");
  }
  cout<<item1+item2<<endl;
  ```

  - `runtime_error`是标准异常类型的一种，==定义在==`stdexcept`==头文件==中，我们必须初始化`runtime_ error`的对象，方式是**给它提供一个string对象或者一个C风格的字符串**。
  - `throw`后紧跟一个表达式，==**表达式的类型就要抛出异常的类型**==。

  ```c++
  while (cin>>item1>>item2)
  {
      try{
          //执行两个Sales_item对象的代码
          //如果添加失败，代码抛出一个runtime_error异常
      }catch(runtime_error err){
          cout<<err.what()<<endl;
      }
  }
  ```

  - 跟在`try`块之后的**是一个或多个`catch`子句**。`catch`子句包括三部分:关键字`catch`、**括号内一个(可能未命名的)对象的声明**(称作异常声明，exception declaration)以及一个块。当选中了某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch**子句之后的那条语句继续执行**。
  - try**语句块中的program-statements 组成程序的正常逻辑**，像其他任何块一样，program-statements可以有包括声明在内的任意C++语句。一如往常， ==**try语句块内声明的变量在块外部无法访问，特别是在catch子句内也无法访问。**==
  - 寻找处理代码的过程与函数调用链刚好**相反**。当**异常被抛出时**，**首先搜索抛出该异常的函数。如果没找到匹配的`catch`子句，终止该函数**，**并在调用该函数的函数中继续寻找。如果还是没有找到匹配的`catch`子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推**，沿着程序的执行路径逐层回退，直到找到适当类型的`catch`子句为止。如果**最终还是没能找到任何匹配的`catch`子句，程序转到名为`terminate`的标准库函数**。该函数的行为与系统有关，一般情况下， **执行该函数将导致程序非正常退出**。
  - <img style="width: 1000px;height:400px" src="Image\stdexcept.png">
  - `exception`**头文件**定义了最通用的异常类`exception`，它只报告异常的发送，不提供任何额外信息。
  - `new`**头文件**定义了`bad_alloc`异常类型，这种类型将在12.1.2节(第407页)详细介绍。
  - `type_info`**头文件**定义了`bad_cast`异常类型，这种类型将在19.2节(第731而)详细介绍
    - 我们只能以==**默认初始化(**==参见2.2.1节，第40页)的方式初始化`exception`.`bad_alloc` 和`bad_cast` 对象，**不允许为这些对象提供初始值**。

### 函数

#### 函数基础

- ==**实参是形参的初始值**==，第一个实参初始化第一个形参**。尽管实参于形参存在对应关系，但是并没有规定==实参的*求值*顺序==。**
  - 为了于`C`兼容，也可使用关键字`void`表示函数没有形参。
  - ==**函数的返回值不能是数组类型或函数类型**==。

- 函数的名字也必须在使用之前声明，**如果一个函数永远不会被我们用到，那么它可以只有声明没有定义**。
  - 因为函数的声明不包含函数体，所以也就无须形参的名字。事实上，在函数的声明中经常省略形参的名字。尽管如此，写上形参的名字还是有用处的，它可以帮助使用者更好地理解函数的功能
  - 定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。

#### 参数传递

- 当用**实参初始化形参**时==**会忽略掉顶层**==`const`，当形参有顶层`const`时，传给它常量对象或者非常量对象都是可以的。

  - 使用**非常量引用会极大地限制函数所能接受的实参类型**，例如：我们不能把`const`对象，字面值或者需要类型转换的对象传递给普通的引用形参。

- 数组形参

  - ```c++
    //尽管形式不同，但这三个print函数是等价的
    void print(const int *);
    void print(const int []);
    void print(const int [10]);//这里的维度表示我们期望数组含有多少元素，实际不一定。
    ```

- 含有可变形参的函数

  - 如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用`initializer_ list` 类型的形参。
    
    <img style="width: 1000px;height:400px" src="Image\initializer_list.png">
    
    ```c++
    //expected和actual是string对象
    if(expected !=actual)
    {
        error_msg({"functionX",expected,actual});
    }
    else
    {
        error_msg({"functionX","okey"});
    }
    ```
    
  - 如果想向`initializer list`形参中传递一个值的序列，则==**必须把序列放在一对花括号内**==
  
- 省略符形参

  - `stdarg.h`可变参数宏

#### 返回类型和return语句

- 返回`void`的函数不要求非得有`return`语句，因为在这类函数的**最后一句后面会隐式地执行return**。

- 有返回值函数

  - `return`语句返回值的类型**必须与函数的返回类型**相同，或者**能隐式地转换**成函数的返回型。
  - 函数的返回类型决定函数调用是否是左值。调用**一个返回引用的函数**得到**左值**，其他返回类型得到右值。**返回常量引用**不能给调用**结果**赋值。

- ==**列表初始化返回值**==

  - **C++11新标准规定**，函数可以**返回花括号包围的值的列表**。此处的列表也用来对表示**函数返回的临时量进行初始化**。如果**列表为空**，临时**执行值初始化**否则，返回的值由函数的返回类型决定。
  - 如果函数返回的是内置类型，则**花括号包围的列表**最多包含**一个值**，而且该值所占空间不应该大于目标类型的空间(参见2.2.1 节，第39页)。如果函数返回的是类类型，由类本身定义初始值如何使用。
  - ==**main函数没有返回值，编译器将隐式地插入一条返回0地return语句。**==

- ==**返回数组指针**==

  - **因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用**。

  - 声明一个返回数组指针的函数

    - 如果我们想定义一个返回数组指针的函数，则==**数组的维度必须跟在函数名字之后**==。然而，==**函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度**==。
      - `Type (*function(parameter_list))[dimention]`

  - **==使用尾置返回类型==**

    - C++11，**任何函数的定义都能使用尾置返回**，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。
      - `auto func(int i)->int(*)[10];`

  - 使用`decltype`

    - 如果我们知道函数返回的指针将指向哪个数组，就可以使用`decltype`关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数`i`的不同指向两个已知数组中的某一个

      ```c++
      int add[]={1,3,5,7,9};
      int even[]={2,4,6,8};
      decltype(odd)* arrPtr(int i)
      {
          return (i%2)?&odd:&even;
      }
      //decltype并不把数组类型转换成对应的指针。
      ```


#### 函数重载

- 不允许两个函数除了返回类型外其它所有的要素都相同。

  - 一个拥有**顶层`const`的形参无法和另一个没有顶层`const`的形参区分**开来。

    ```c++
    Record loopup(Phone*);
    Record loopup(Phone*const);
    ```

  - 如果形参是某种类型的**指针**或**引用**，则通过**区分其指向的是==常量对象还是非常量对象==可以实现函数重载**，此时的`const`是底层的。

    ```c++
    Record loopuo(Account*);
    Record loopup(const Account*);
    ```

    - 传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数。

  - 有多个函数可以匹配，但是每一个都不是明显的最佳选择，此时将发送错误称为**二义性调用**。

- 如果在内层作用域中声明名字，他将隐藏外层作用域中声明的同名实体。==**在不同的作用域中无法重载函数名**。==

  - **在局部作用于中声明函数不是一个好的选择。**
  - ==**C++中，名字查找发生在类型检查之前**==

#### 特殊用途语言特性

- 默认实参

  - 一旦某个形参被赋予了默认值，他后面的所有形参都必须有默认值。

  - 函数调用时实参按位置解析。

  - **尽量让不怎么使用默认值得形参出现在前面，而让那些经常使用默认值得形参出现在后面。**

  - **==在给定得作用域中一个形参只能被赋予一次默认实参==**

    ```c++
    string screen(sz,sz,char = ' ');
    string screen(sz,sz,char = '*');//错误：重复声明
    ```

  - **==局部变量不能作为默认实参，除此之外，只要表达式得类型能转换成形参所需得类型，该表达式就能作为默认实参。==**

    ```c++
    //wd,def和ht得声明必须出现在函数之外
    sz wd = 80;	//sz是关键字别名
    char def = ' ';
    sz ht();
    string screen(sz = ht(),sz = wd,char = def);
    //用作默认实参的名字在函数声明所在得作用域内解析
    //而这些名字得求值过程发生在函数调用时。
    ```

- 内联函数和`constexpr`函数

  - 内联机制用于优化规模较小，流程直接，频繁调用得函数。很多编译器都不支持内联递归函数。
  - `constexpr`函数：函数得**==返回类型==及所有==形参的类型==都得是字面值类型**，且**函数体中必须==有且只有==一条`return`语句**。
    - `constexpr`函数被隐式地定义为内联函数。
    - `constexpr`函数体内也可以包含其它语句，只要这些语句在==**运行时**==不执行任何操作就行。
    - `constexpr`函数不一定返回常量表达式。
  - 内联函数或者`constexpr`函数通常定义在头文件中。
  - 调试帮助`cassert`
    - `CC -D NDEBUT main.c` 这条命令的作用等价于在`main.c`的文件的一开始写`#define NDEBUG`

#### 函数匹配

- 实参类型转换
  1. 精确匹配
     - 实参类型和形参类型相同。
     - 实参从数组类型或函数类型转换成对应的指针类型
     - 向实参**添加项层**`const`或者从实参中**删除**顶层`const`.
  2. 通过`const`==**转换**==实现的匹配(参见4.11.2 节，第143页)。
  3. 通过**类型提**升实现的匹配(参见4.11.1 节，第142页)。
  4. 通过算术类型转换或指针转换实现的匹配。
     - **所有算术类型转换的级别都一样**。
       - `int`向`unsigned int`的转换并不比从`int`向`double`的转换级别高。
  5. 通过类类型转换实现的匹配(参见14.9节，第514页，将详细介绍这种转换)。

#### 函数指针

- 把函数名作为一个值使用时，函数自动地转换成指针。

  - `pf = lengthCompare或pf=&lengthCompare`
  - `pf("hello","goodbye")或(*pf)("hello","goodbye")`等价的方式。
  - 函数指针类型必须与重载函数中的某一个精确匹配

- 函数指针形参

  ```c++
  void useBigger(const string&s1,const string&s2
                 ,bool pf(const string&,const string&));//自动地转换成指向函数的指针
  
  void useBigger(const string&s1,const string&s2
                 ,bool (*pf)(const string&,const string&));//显示地将形参定义成指向函数的指针
  
  typedef bool Func(const string&,const string*);
  typedef decltype(lengthCompare) Func2;//Func和Func2是函数类型
  
  typedef bool (*FuncP)(const string&,const string&);
  typedef decltype(lengthCompare)*FuncP2//指向函数的指针
  ```

- 返回**指向函数的指针**

  - ==**必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。**==

    ```c++
    using F = int(int*,int);//F是函数类型，不是指针
    using PF = int(*)(int*,int);//PF是指针类型
    
    auto f1(int)->int(*)(int*,int);
    ```


### 类

#### 定义抽象数据类型

- 定义在类内的函数是隐式的`inline`函数

- `this指针`
  - 成员函数通过一个名为`this`的额外的隐式参数来访问调用它的那个对象。当我们**调用一个成员函数**时，**用请求该函数的对象地址初始化this**。
  - 任何对类成员的直接访问都被看做`this`的隐式引用
  - **尽管`this`是隐式的，但它仍然需要遵循初始化规则。**
  
- ==**const成员函数**==
  - 成员函数的参数列表之后的`const`的关键字是==**修改隐式**`this`**指针**==的类型。
  - 默认情况下，`this`的类型是**指向类类型非常量版本**的常量指针。
    - 不能把`this`绑定到一个常量对象上，这使我们==**不能在一个常量对象上调用普通的成员函数**==。
  - 允许把`const`关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的`const`表示`this`**是一个指向常量的指针**。像这样使用`const`的成员函数被称作**常量成员函数**(const member function)。
  - **常量对象，以及常量对象的引用或指针都只能调用常量成员函数。**
  - **==一个const成员函数如果以引用的形式返回`*this`，那么它的返回类型将是常量引用。==**
  
- 类作用域和成员函数
  - **编译器分两步处理类**:首先==**编译成员的声明**==，==然后才轮到成员函数体==(如果有的话)。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。
  - **如果成员被声明成常量成员函数，那么它的==定义也必须==在参数列表后明确指定`const`属性**。同时，类外部定义的成员的名字**必须包含它所属的类名**
  
  - **因为I0类属于不能被拷贝的类型**，因此我们只能通过引用来传递它们(参见6.2.2节，第188页)。而且，因为读取和写入的操作会改变流的内容，所以两个函数接受的都是普通引用，而非对常量的引用。
  
- 构造函数

  - ==**构造函数不能被声明成`const`的**==(参见7.1.2节，第231页)。当我们创建类的一个`const`对象时，**直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。**因此，构造函数在`const`对象的构造过程中可以向其写值。
  - 如果我们的==**类没有显示地定义构造函数**==，那么**编译器就会为我们隐式地定义一默认构造函数**。编译器创建的构造函数又被称为**合成的默认构造函数**。对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员:
    - 如果**存在类内的初始值**(参见2.6.1节，第64页)，**用它来初始化成员**。
    - **否则，默认初始化(参见2.2.1节，第40页)该成员。**
  - ==**编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数**==。一但我们定义了一些其他的构造函数，那么除非我们再定义个默认的构造函数，否则类将没有默认构造函数
  - 有时候编译器不能为某些类合成默认的构造函数。例如，如果类中**包含一个其他类类型的成员且这个成员的类型没有默认构造函数**，那么编译器将无法初始化该成员。
  - 在`C++11`新标准中，如果**我们需要默认的行为，那么可以通过在参数列表后面写上= default来要求编译器生成构造函数**。其中，= default既可以和声明一起出现在类的内部。也可作为定义出现在类的外部。
  - **构造函数初始值列表**
    - 构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来（**或在花括号内的**）成员初始值。
    - **当某个数据成员被构造函数初始值列表忽略时，它将以于==合成默认构造函数相同的方式隐式初始化。==**
  
- 拷贝，赋值和析构

  - 不主动定义这些操作，编译器将替我们合成他们，一般来说，编译器生成的版本将对对象的每个成员拷贝，赋值和销毁。


#### 访问控制于封装

- 我们可以使用`class`和`struct`这两个关键字中的任何一个定义类，唯一的一点区别是，`struct`和`class`的默认访问权限不太一样。
- 友元
  - 把一个函数作为它的友元，只需要添加一条以`friend`**关键字开始的函数声明**语句即可。
  - ==**友元的声明仅仅指明了访问的权限，而非一个通常意义上的函数声明**==
    - ==**如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外专门对函数进行一次声明（这个声明是函数的定义，在类的外部）。**==
  - 我们可以在类的内部把`inline`作为声明的一部分显式地声明成员函数，同样的，也能在类的外部用`inline`关键字修饰函数的定义。
  - 虽然我们无须在声明和定义的地方同时说明`1inline`,但这么做其实是合法的。不过，**最好只在类外部定义的地方说明inline**。
  - 和我们在头文件中定义`inline`函数的原因一样**inline成员函数也应该与相应的类定义在同一个头文件中**。

#### 类的其它特性

- ==**可变数据成员**==
  
  - 我们希望能够修改类的某个数据成员，即使在一个`const`**成员函数==内==**。
    - `mutable`关键字
    - `mutable size_t access_ctr`即使在一个`const`对象内也能被修改
    - ==**当一个成员调用另一个成员时，this指针在其中隐式地传递。**==
  
- ==**类类型**==
  
  - `struct ClassName myClass`继承C语言，在C++中合法
  - 我们也能**仅仅声明类而暂时不定义它**
    - `class Screen;`
    - 这种声明有时被称作**前向声明**( forward declaration)， ==**它向程序中引入了名字Screen并且指明Screen是一种类类型**==。
    - 对于类型Screen来说，在==**它声明之后定义之前**==是一个不完全类型( incomplete type)，也就是说，此时我们已知Screen是一个类类型，但是不清楚它到底包含哪些成员。
    - ==**不完全类型只能在非常有限的情景下使用**:==
      - 可以定义指向这种类型的指针或引用，
      - 也可以声明(*==**但是不能定义**==*)以不完全类型作为参数或者返回类型的函数。
    - 在7.6节(第268页)中我们将描述一种例外的情况：直到**类被定义之后**数据成员才能被声明成这种类类型。换句话说，我们必须首先完成类的定义，然后编译器才能知道存储该数据成员需要多少空间。因为**只有当类全部完成后类才算被定义**，所以一个类的成员类型不能是该类自己。然而，**一旦一个类的名字出现后，它就被认为是声明过了(但尚未定义)，因此类允许句含指向它自身类型的引用或指针。**
  
- 友元再探
  - 类还可以把其**他的类定义成友元**，也可以把**其他类(之前已定义过的)的成员函数定义成友元**。此外，**==友元函数能定义在类的内部==，这样的函数是隐式内联的**。
  
  - 令成员函数作为友元
    - `friend void Window_mgr::clear(ScreenIndex);`
    
  - 如果一个类想把一组重载函数声明成它的友元，它**需要对这组函数中的==每一个分==别声明**。
  
  - ==**友元声明和作用域**==
  
    - **类**和**非成员函数**的**声明**不是必须在它们的**友元声明之前**。当**一个名字第一次出现在一个友元声明中**时，我们**隐式地假定该名字在==当前作用域中==是可见的**。然而，友元本身不一定真的声明在当前作用域中(参见7.2.1节，第241页)。甚至就算在类的内部定义该函数，我们也必须在==**类的外部提供相应的声明**==从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的。
  
      ```c++
      struct X
      {
          friend void f(){}
          X(){f();}			//错误：f还没有被声明
          void g();
          void h();
      };
      void X::g(){return f();}//错误：f还没有被声明
      void f();				//声明那个定义在X中的函数
      void X::h(){return f();}//正确：现在f的声明在作用域中了
      ```

#### 类的作用域

- **在类的外部，成员的名字被隐藏起来了。**

  - **函数的返回类型通常出现在函数名之前**。因此当**成员函数定义在类的外部时**，**返回类型中使用的名字都位于类的作用域之外**。这时，返回类型必须指明它是哪个类的成员

    ```c++
    Window_mgr::ScreenIndex
    Window_mgr::addScreen(const Screen&s)	{}
    ```

- ==**用于类成员声明的名字查**==找

  ```c++
  typedef double Money;
  std::string bal;
  class Account
  {
  public:
     	
  	Money balance()const { return bal; }
  private:
  	Money bal;
  };
  ```

  - 当编译器看到`balance`函数的声明语句时，它将在`Account`类的**范围内**寻找对`Money`的声明。==**编译器只考虑Account中在使用Money前出现的声明**==，因为没找到匹配的成员，所以编译器会接着到`Account`的外层作用域中查找。在这个例子中,编译器会找到`Money`的t`ypedef`语句，该类型被用作`balance`函数的返回类型以及数据成员`bal`的类型。另一方面，`balance`函数体在整个类可见后才被处理，因此，该函数的`return`语句返回名为`bal`的成员，而非外层作用域的`string`对象。
  - 类中，如果==**成员使用了外层作用域中的某个名字**==，而该名字**代表一种类型**，则类不能在之后重新定义该名字。
    - 尽管重新定义类型名字是一种错误的行为，但是编译器并不为此负责。一些编译器仍将顺利通过这样的代码，而忽略代码有错的事实。

- **==成员定义中的普通块作用域的名字查找==**

  - 首先，在**成员函数内**查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。
  - 如果在**成员函数内没有找到**，则在**类内**继续查找，这时类的所有成员都可以被考虑。
  - 如果**类内也没找**到该名字的声明，在==**成员函数定义之前的作用域**==内继续查找。
    - 当==**成员定义在类的外部**==时，**名字查找**考虑名字查找的第三步不仅要考虑**类定义之前的全局作用域中声明**，还需要考虑在**成员函数定义==之前==的全局作用域中的声明**。

#### 构造函数再探

- 构造函数初始值列表

  - 如果**没有在构造函数的初始值列表中**显示地初始化成员，则该==**成员将在构造函数体之前**==执行**默认初始化**。
  - 在构造函数初始值中的每个成员只能出现一次。
  - ==**成员的初始化顺序与它们在类定义中的出现顺序一致**==：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。
  - 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。

- ==委托构造函数==

  - `Sales_data():Sales_data("",0,0){};`

- 默认构造函数

  - 默认构造函数的使用方法：`Sales_data obj`，而不是`Sales_data obj()`这将是一个函数声明
  - ==**一个类没有默认构造函数，则当编译器确实需要隐式地使用默认构造函数时，该类无法使用。所以一般情况下，都应该为类构建一个默认构造函数。**==

- 隐式的类类型转化

  - **如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的==隐式转换机制==，有时我们把这种构造函数称作转换构造函数**

  - **==只允许一步类类型转换==**

    ```c++
    Sales_data item;
    string null_book = "9-999-99999-9";
    //构造一个临时的Sales_data对象
    //该对象的units_sold和revenue等于0，bookNo等于null_book
    item.combine(null_bool);
    
    //错误:需要用户定义的两种转换:
    // (1)把“9-999-99999-9” 转换成string
    // (2)再把这个(临时的)string转换成Sales data 
    item.combine("9-999-99999-9");
    ```

  - ==**印制构造函数定义的隐式钻换**==

    - `explicit`只对一个参数的构造函数有效且**只能在类内声明**构造函数时使用`explicit`关键字。
    - **发生隐式转换的一种情况是当我们执行拷贝形式的初始化时**`=`
      - `Sales_data item2 = null_book;`

  - **==接收一个容量参数的vector构造函数是explicit的==**

- **聚合类**：C语言的struct

  - 所有成员都是`public`的
  - 没有定义任何构造函数
  - 没有类内初始值
  - 没有基类，也没有`virtual`函数

- 字面值常量类

  - 数据成员都是**==字面值==类型的聚合类**是字面值常量类。
  - 如果**一个类不是聚合类，但它复合下述要求**
    - 数据成员都必须是字面值类型。
    - 类必须至少含有一个`constexpr`构造函数。
    - 如果一个**数据成员含有类内初始值**，则**内置类型成员的初始值必须是一条常量表达**式或者如果成员**属于某种类类型**，则初始值**必须使用成员自己的constexpr构造函数**。
    - 类必须使用析构函数的默认定义，该成员负责销毁类的对象。
  - **字面值常量类**的==**构造函数**==可以是`constexpr`函数，事实上，一个字面值常量类必须至少提供一个`constexpr`构造函数。
    - `constexpr`构造函数可以声明成`=default`或删除形式。
    - `constexpr`构造函数**必须初始化所有数据成员**，初始值**或者使用`constexpr`构造函数**，**或者是一条常量表达式**。
    - `constexpr`构造函数用于**生成`constexpr`对象**以及**`constexpr`函数的参数或返回类型**:

#### 类的静态成员

- 对象中不包含任何与静态数据成员有关的数据，静态成员函数也不和任何对象绑定在一起，他们不包含`this`指针。

- 可以使用作用域运算符直接访问静态成员

- 静态成员不属于类的某个对象，但是**我们仍然可以使用类的对象，引用或者指针来访问静态成员**。

- 我们既可以在类的内部也可以在类的外部定义静态成员函数，**在类的外部定义静态成员时，==不能重复`static`关键字==**。

- 因为**静态数据成员不属于类的任何一个对象**，所以**他们并不是在创建类的对象时被定义的，这意味着他们不是由类的构造函数初始化的**。

  - **==必须在类的外部定义和初始化每个静态成员==**

    ```c++
    double Account::interestRate = initRate();
    ```

  - 类型是`double`。从==**类名开始，这条定义语句的剩余部分就都位于类的作用域之内了**==。因此,我们可以直接使用`initRate`函数。注意，虽然`initRate`是私有的，我们也能用它初始化`interestRate`。和其他成员的定义一样，`interestRate`的定义也可以访问类的私有成员。

- 我们可以为静态成员提供**`const`整数类型的==类内初始值==**。要求**静态数据成员**必须==**是字面值类型的`constexpr`，初始值必须是常量表达式。**==

- **==即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。==**

- 静态数据成员可以是不完全类型，静态数据成员的类型可以就是它所属的类类型。

- 静态成员和普通成员的另外一个区别是**我们可以使用静态成员作为默认实参**。

- ==**静态成员函数，只能访问静态成员**==

## 第二部分

### IO库

#### IO类

<img style="width: 1000px;height:400px" src="Image\IO库类型和头文件.png">

- 为了**支持使用宽字符的语言**，标准库定义了一组类型和对象来操纵`wchar_t`类型数据。宽字符版本的类型和函数的名字以一个w开始。例如`wcin`、`wcou`t和 `wcerr`是分别对应`cin`、`cout`和` cerr`的宽字符版对象。==**宽字符版**==
  - ==**`ifstream`和`istringstream`继承自`istream`。`ostream`和`ostringstream`都继承自`ostream`**==
    - 在要求使用基类型对象的地方，我们可以用继承类型的对象来代替

  - **==不能拷贝或对IO对象赋值==**

<img style="width: 1400px;height:250px" src="Image\IO库条件状态.png">

<img style="width: 1400px;height:640px" src="Image\IO库条件状态2.png">

- **由于流可能处于错误状态，因此代码通常因该在使用一个流之前检查它是否处于良好状态。**

  - ```c++
    auto old_state = cin.rdstate();//记住cin的当前状态.
    cin.clear();					//使cin有效
    process_input(cin);				//使用cin
    cin.setstate(old_state);		//将cin置为原有状态
    ```

  - `badbit`系统级错误，通常情况下，一旦`badbit`被置位，流就无法使用了。

  - `failbit`：可恢复错误，如期望读取数值却读到一个字符。

    - `is.clear(is.rdstate() & ~std::istream::failbit);`==**恢复上次io错误**==

  - **到达文件结束位置**：`eofbit`和`failbit`都会被置位。

  - 如果`badbit`、`failbit` 和`eofbit`任一个被置位，则检测流状态的条件会失败。

  - 4个`iostate`类型的`constexpr`值**表示特定的位模式**。这些值用来表示特定类型的I0条件，**可以与位运算符一起使用来一次性检测或设置多个标志位**。

- 管理输出缓冲

  - ```c++
    //flush刷新缓冲区，但不输出任何额外的字符: ends 向缓冲区插入一个空字符，然后刷新缓冲区。
    cout<<"hi!"<<flush;
    
    //unitbuf告诉流接下来的每次写操作之后都要进行flush，nounitbuf使其恢复使用正常的系统管理的缓冲区刷新机制:
    cout<<unitbuf;
    //任何输出都立刻刷新
    cout<<nounitbuf;
    ```

  - 当**一个输入流被关联到一个输出流**时，任何试图从**输入流**读取数据的操作都会先**刷新关联的输出流**。

    - 标准库将`cout`和`cin`关联在一起
    - ==`tie()`==：
      - 不带参数，返回指向输出流的指针，没有返回空指针
      - 带参数：`ostream`指针，将自己关联到`ostream`
      - `cin.tie(&cout);`
    - **==每个流同时最多关联到一个流，但多个流可以同时关联到同一个`ostream`==**

#### 文件输入输出

<img style="width: 1400px;height:500px" src="Image\fstream.png">

- 头文件`fstream`

  - `ifstream`从一个给定的文件读取数据
  - `ofstream`向一个给定的文件写入数据
  - `fstream`读写给定文件
  - 一旦一个文件流已经打开，它就保持与对应文件的关联。实际上，对一个已经打开的文件流调用`open`会失败，并会导致`failbit`被置位。随后的试图使用文件流的操作都会失败。为了将文件流关联到另外一个文件，必须首先关闭已经关联的文件。一旦文件成功关闭，我们可以打开新的文件
  - ==**当一个`fstream`对象被销毁时，`close`会自动被调用**==

- 文件模式

  <img style="width: 1400px;height:350px" src="Image\文件模式.png">

  - 只要当`out`也被设定时才可设定`trunc`模式

  -  只要`trunc`没被设定，就可以设定`app`模式。在`app`模式下，即使没有显式指定`out`模式，文件也总是以输出方式被打开。

  - 默认情况下，即使我们没有指定`trunc,` **以out模式打开的文件也会被截断**。为了==**保留以`out`模式打开的文件的内容，我们必须同时指定app模式**==，这样只会将数据追加写到文件末尾。或**者同时指定in模式，即打开文件同时进行读写操作**

  - **`fstream`关联的文件默认以`in`和`out`模式打开。**

    ```c++
    ofstream app("file2",ofstream::app);
    ofstream app2("file2",ofstream::out|ofstream::app);
    //保留被`ofstream`打开的文件中已用数据的唯一方法是显示指定app或in模式
    ```

#### string流

<img style="width: 1400px;height:300px" src="Image\stringstream.png">

- ==`sstream`头文件==：内存IO
  - `sstream`头文件中定义的类型都==**继承**==自我们已经使用过的`iostream`头文件中定义的类型。
  
  - `istringstream`从`string`读取数据，`ostringstream`向`string`写入数据，`stringstream`即可从`string`读数据也可向`string`写数据
  
    ```c++
    struct PersonInfo
    {
    	std::string name;
    	std::vector<std::string> phones;
    };	
    std::string line, word;
    std::vector<PersonInfo> people;
    std::istringstream record;
    PersonInfo info;
    while (std::getline(std::cin, line))
    	{
    		record.str(line);
    		record>>info.name;
    		while (record >> word)
    		{
    			info.phones.push_back(word);
    		}
    		people.push_back(info);
    		info.name.clear();
    		info.phones.clear();
    		record.clear();//重复使用字符串流时每次都要调用clear
    	}
    for (const auto& person : people)
    	{
    		std::cout << person.name << " ";
    		for (const auto& phone : person.phones)
    		{
    			std::cout << phone << " ";
    		}
    		std::cout << std::endl;
    	}
    ```
  
    

### 顺序容器

#### 顺序容器概述

<img style="width: 1400px;height:400px" src="Image\顺序容器.png">

<img style="width: 1200px;height:1500px" src="Image\容器操作.png">

<img style="width: 1200px;height:200px" src="Image\容器操作2.png">

#### 容器库概览

- `list<string>::vale_type，::reference，::const_reference`
  - `list`中放的元素类型

- 为了**创建一个==容器为另一个容器的拷贝==**，**两个容器的类型及其元素类型必须匹配**。不过，==**当传递迭代器参数来拷贝一个范围时**==，就**不要求容器类型是相同的了**。而且，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的==**元素转换**==为要初始化的容器的元素类型即可。

- `array`

  - **定义一个`array`时，除了指定元素类型，还要指定容器大小。**
  - `array<int,42> ia;`
  - ==**支持数组赋值**==

- 赋值和`swap`

  <img style="width: 1200px;height:300px" src="Image\顺序容器赋值操作.png">

  - 两个容器的交换操作：`swap`元素本事并未交换，`swap`只是交换了两个容器的内部结构。
    - 除`array`外,`swap`不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。
    - **元素不会被移动的事实意味着**，除`string `外，**指向容器的迭代器、引用和指针在swap操作之后都不会失效**。它们==**仍指向swap操作之前所指向的那些元素**==。但是，在`swap`之后，这些元素已经属于不同的容器了。

#### 顺序容器操作

<img style="width: 1200px;height:600px" src="Image\顺序容器添加元素.png">

- ==**`deque`**==和`vector`一样提供随机访问元素的能力。

- 如果我们**传递给`insert`一对迭代器**，**他们不能指向添加元素的目标容器**。

- `emplace`操作

  - `emplace_front,emplace,emplace_back`，对应`push_front,insert,push_back`，**构造元素**：将==**参数传递给元素类型的构造函数**==。
    - 调用`emplace_back`时，会在容器管理的内存空间中直接创建对象，而调用`push_back`则会创建一个局部临时对象，并将其压入容器中。

  <img style="width: 1200px;height:400px" src="Image\顺序容器访问.png">

  <img style="width: 1200px;height:600px" src="Image\顺序容器的删除操作.png">

- `forward_list`

  <img style="width: 1200px;height:600px" src="Image\forward_list.png">

- 顺序容器大小操作

  - `c.resize(n)`调整`c`的大小为`n`个元素，若`n<c.size()`,则多出的元素被丢弃。若必须添加新元素，对**新元素进行值初始化**。
  - `c.resize(n,t)`调整`c`的大小为`n`个元素。任何新添加的元素都初始化为值`t`

- 容器操作可能使迭代器失效

  - `vector,string`
    - 如果**存储空间未重新分配**，指向==**插入位置之前**==的元素的迭代器、指针和引用仍有效，但==**指向插入位置之后**==元素的迭代器、指针和引用将会失效。
    - 对于`vector`和`string`，指向被删元素之前元素的迭代器、引用和指针仍有效。注意:当我们==**删除元素时，尾后迭代器总是会失效**==。
  - `deque`
    - 插入到==**除首尾位置之外的任何位置都会导致**==迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但==**指向存在的元素的引用和指针不会失效**==。
    - 如果在==**首尾之外的任何位置删除元素**==，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除 deque 的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响;如果是删除首元素，这些也不会受影响。

#### vector对象是如何增长的

- 容器大小管理操作
  - `shrink_to_fit()`
    - 在新标准库中，我们可以调用`shrink_to_fit`来要求`deque`、`vector`或`string`**退回不需要的内存空间**。此函数指出我们不再需要任何多余的内存空间。但是，==**具体的实现可以选择忽略此请求**==。也就是说,调用`shrink_to_fit`也并不保证一定退回内存空间。
  - `capacity()`
  - `reserve(n)`
    - 只有当**需要的内存空间超过当==前容量时==**，`reserve`调用才会改变`vector`的容量。如果需求大小大于当前容量，`reserve`至少分配与需求一样大的内存空间（可能更大)。
    - 如果需求大小小于或等于当前容量，`reserve` 什么也不做。特别是，当需求大小小于当前容量时，容器不会退回内存空间。因此，在调用`reserve`之后，`capacity`将会大于或等于传递给`reserve`的参数。
    - 调用`resize`或`reserve`时**给定的大小超过当前**`capacity`，`vector`才可能重新分配内存空间。

#### 额外的string操作

- 构造`string`的其它方法

  <img style="width: 1200px;height:230px" src="Image\构造string的其它方法.png">

  <img style="width: 1200px;height:140px" src="Image\substr.png">

- 改变`string`的其它方法

  - `string`的`insert`和`erase`的其它版本

    ```c++
    std::string s;
    s.insert(s.size(),5,'!');//在s的末尾插入5个感叹号
    s.erase(s.size()-5,5);	//从s删除最后5个字符
    const char *cp = "Stately,plump Buck";
    s.assign(cp,7);			//从cp的开始处，替换7个字符
    s.insert(s.size(),cp+7);//从末尾插入，直到cp结束
    s.insert(0,s2);			//在s中位置之前插入s2的拷贝
    s.insert(0,s2,0,s2.size());//在s[1]之前插入s2中s2[0]开始的s2.size ()个字符
    
    ```

- 额外的`string`操作

  <img style="width: 1200px;height:500px" src="Image\额外的string操作.png">

  <img style="width: 1200px;height:250px" src="Image\修改string的操作2.png">

  ```c++
  s2.replace(11,3,"5th");
  //插入的文本恰好与删除的文本一样长。这不是必须的，可以插入一个更长或更短的string
  s.replace(11,3,"Fifth");
  //删除了3个字符，但在其位置插入了5个新字符
  ```

  - `assign`总是替换`string`中的所有内容
  - `append`总是将新字符追加到`string`末尾

- `string`**搜索**操作

  <img style="width: 1200px;height:300px" src="Image\string的搜索操作.png">

  <img style="width: 1200px;height:300px" src="Image\string的搜索操作2.png">

  - 6个不同的搜索函数，每个函数都有4个重载版本。返回`string::size_type`值，标识匹配的位置。**搜索失败，返回`string::npos`的`static`成员**，标准库将`npos`定义为一个`const string::size_type`类型，并且初始化为-1
  
- `compare`函数

  - `str`与指定字符串的关系等于0，大于正数，小于负数
  - <img style="width: 1200px;height:500px" src="Image\compare函数.png">
  - <img style="width: 1200px;height:500px" src="Image\string的数值之间的操作.png">


#### 容器适配器

<img style="width: 1200px;height:600px" src="Image\容器适配器接受的操作.png">

- 三个**顺序容器**适配器：`stack`，`queue`和`priority_queue`。一个容器适配器接收一种已有的容器类型，使其行为看起来像一种不同的类型。==**`stack`不接受`array`和`forward_list`**==
  - **每个适配器都定义两个构造函数**：**默认构造函数创建一个空对象**，接受一个容器的构造函数**==拷贝==该容器来==初始化适配器==**。例如，假定 `deq`是一个`deque<int>`，我们可以用`deq`来初始化一个新的`stack`。
  - ==**默认情况下**==，`stack`和 `queue`是基于`deque`实现的，`priority_queue`是在`vector`之上实现的
    - `stack<string,vector<string>> str_stk`在`vector`上实现的空栈
  - `queue`和`priority_queue`适配器定义==**在`queue`头文件中**==。
  - `priority_queue`为队列中元素建立优先级。**新加入的元素会排在所有优先级比它低的已有元素之前**。
  - ` std::priority_queue<int> pq;  // 默认使用 std::less<int>`

### 泛型算法

#### 概述

- ==**算法总是通过迭代器操作容器，无法改变容器的大小，应确保目的容器拥有足够多的空间可以容纳元素**==
  - ==**容器要拥有足够多的size而不是capacity，算法不具备向容器添加元素的功能**==

- `numeric`头文件中定义了一组数值泛型算法，`algorithm`
  - 通常情况下，算法==**遍历范围**==，对其中的每个元素进行一些处理
  - `find`返回第一个等于给定值的元素的迭代器，没有，返回第二个参数。

#### 初始泛型算法

- 附录A列出了所有算法
  - `accumulate`定义在`numeric`中，函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是**和的初始值**。
    - `string sum = accumulate(v.cbegin(),v.cend(),string(""));`
    - **第三个参数的类型**决定了函数中使用**哪个加法运算符**以及**返回值的类型**
  - `equal`：确定两个序列是否保存相同的值，它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。对应元素都相等返回`true`否则返回`false`
    - **那些只接受一个单一迭代器来表示第二个序列的算法，==都假定第二个序列至少与第一个序列一样长。==**
  - `fill`
    - `fill(vec.begin(),vec.end(),100)`将给定值赋予序列中的每个元素
    - `fill_n(dest,n,val)`：将**给定值赋予迭代器指向的元素**开始的**指定个元素**。
  - `back_inserter` 头文件`iterator`
    - `back_inserter`**接受一个指向容器的引用**，返回一个与该容器绑定的插入迭代器当我们通过此迭代器==**赋值**==时，赋值运算符会调用`push_back`将一个具有给定值的元素添加到容器中。
    - `fill_n(back_inserter(vec),10,0);`
  - `copy`
    - 三个迭代器：前两个标识一个输入范围，第三个表示**目的序列的起始位置**。
    - 返回的是**目的位置迭代器(递增后)的值**。
  - `replace`
    - `replace(vec.begin(),vec.end(),0,42);`将所有值为0的元素改为42
    - 多个算法都提供所谓的“==**拷贝**==”版本。这些算法计算新元素的值，但不会将它们放置在输入序列的末尾，而是创建一个新序列保存这些结果。
      - `replace_copy`
      - `replace_copy(vec.begin(),vec.end(),back_inserter(lst),0,42)`
      - 此算法接受额外的第三个迭代器参数，指出调整后序列的保存位置。
  - `sort`
    - `stable_sort`：这种排序算法维持相等元素的原有位置
  - `unique`
    - 先调用排序然后重排输入序列，使得每个元素只出现一次，返回指向==**不重复区域之后一个位置**==的迭代器。
    - `unique_copy`
      - 第三个迭代器，表示==**拷贝不重复元素的目的位置**==。
  - `partition`
    - 对容器进行划分，使得**一元谓词**为true的在前半部分，false在后半部分。
    - 返回最后一个使谓词为true的元素之后的位置
  - `find_if`
    - 第三个参数一元谓词，返回第一个使谓词返回非0的元素，不存在这样的元素返回尾迭代器
  - `transform`
    - 前两个迭代器表示输入序列，第三个迭代器表示目的的位置，算法对**输入序列中每个元素可调用可调用对象，并将结果写到目的位置**。
  - `bind` 
    - 头文件`functional`名称空间`std::placeholders::_1`和`bind`函数
    - `auto newCallable = bind(callable,arg_list)`
    - `arg_list` 是一个逗号分隔的参数列表,对应给定的`callable`的参数。即，当我们调用`newCallable`时，`newCallable` 会调用`callable`,并传递给它`arg_list`中的参数。
    - **`arg_list`中`_n`的名字，表示`newcallable`的参数**
      - `auto g = bind(f,a,b,_2,c_1)`
      - ==**`g`的第一个参数绑定到`_1`上第二个参数绑定到`_2`上**==
    - ==**bind的那些不是占位符的参数被拷贝到`bind`返回的的调用对象中**==
      - `bind(print,ref(os),_1,' ')`函数`ref`返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个`cref`函数，生成一个保存`const`引用的类。与`bind`一样，函数`ref`和`cref` 也定义在头文件`functiona`l中。
      - `bind2st(std::modulus<int>(),x)`**固定第二个参数是X**

#### 定制操作

- `lambda`表达式

  - `[capture list](parameter list)->return type {function body}`

  - **忽略括号和参数列表等价与指定一个空的参数列表**。

  - `lambda`**不能有默认实参**

  - 一个`lambda`可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量。一个`lambda`通过**将局部变量包含在其捕获列表中**来指出将会使用这些变量。

  - 当定义一个`lambda`时，编译器生成一个与`lambda`对应的新的(未命名的)类类型。我们将在14.8.1节(第507页)介绍这种类是如何生成的。目前，可以这样理解，**当向一个函数传递一个`lambda`时，同时定义了一个新类型和该类型的一一个对象:传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用`auto`定义一个用`lambda` 初始化的变量时，定义了一个从`lambda`生成的类型的对象**。默认情况下，从`lambda`生成的类都包含一个对应该`lambda`所捕获的变量的数据成员。类似任何普通类的数据成员，`lambda`的数据成员也在`lambda`对象创建时被初始化。

  - 变量的**捕获方式也可以是值或引用**。**被捕获的变量的值是在`lambda`创建时拷贝，而不是调用时拷贝。**

  - ==**隐式捕获**==

    <img style="width: 1200px;height:600px" src="Image\lambda捕获列表.png">

    - **显示捕获的变量必须使用与隐式捕获不同的方式**
    
  - 对于**一个==被拷贝的变量==`lambda`不会改变其值**，如果我们希望**改变一个被捕获的变量的值**，就==**必须在参数列表首加上关键字`mutable`**==
  
    - `auto f =[i]()mutable{return ++i;};`
  
  - **只有一条return语句`lambda`不用指定返回类型。** 反之编译器推断`return`是`void`

#### 再探迭代器

1. 插入迭代器：接受一个容器，生成一个迭代器，能实现向给定容器添加元素

   - `it=t`：在`it`**指定的当前位置插入值**`t`。假定`c`是`it`绑定的容器，依赖于**插入迭代器的==不同种类==**，此赋值会分别调用`c.push. _back(t)`、`c.push_front(t)`或`c.insert(t,p)`，**其中`P`为传递给`inserter`的迭代器位置**

   - `*it,++it,it++`：这些操作虽然存在，但不会对`it`做任何事情。每个操作都返回`it`
   - `back_inserter`：创建一个`push_back`迭代器
     
   - `front_inserter`：创建一个`push_front`的迭代器
     
   - `inserter`：创建一使用`insert`的迭代器，**此函数接受第二参数，这个参数必须是一个指向给定容器的迭代器**，==元素被插入到给定迭代器所表示的元素之前==
   
2. `iostream`迭代器：迭代器将他们对应的流当作一个特定类型的元素序列来处理

   - `istream_iterator`：读取输入流

     - <img style="width: 1000px;height:400px" src="Image\istream_iterator.png">

     - 当创建一个流迭代器时，==**必须指定迭代器将要读写的对象类型**==。一个
       `istream_iterator` 使用`>>`来读取流。因此，`istream_iterator`要**读取的类型必须定义了输入运算符**。当创建一个`istream_ iterator`时，我们可以将它绑定到一个流。当然，我们还可以==**默认初始化迭代器，这样就创建了一个可以当作尾后值使用的迭代器**==。

       ```c++
       ifstream in("afile");
       istream_iterator<string> str_it(in);
       istream_iterator<string> eof;
       while(str_it!=eof)
       {
           //后置递增运算会从流中读取下一个值，向前推进，但返回的是迭代器的旧值。迭代器的旧值包含了从流中读取的前一个值，对迭代器进行解引用就能获得此值。
           vec.push_back(*str_it++);
       }
       
       //从迭代器范围构造vec;
       std::vector<std::string> vec(str_it,eof);
       
       istream_iterator<int> in(cin),eof;
       std::cout<<accumulate(in,eof,0)<<std::endl;
       ```

     - **==对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或IO错误，迭代器的值就与尾后迭代器相等==**

     - 当我们将一个`istream_iterator`绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。

   - `ostream_iterator`：向一个流写数据

     <img style="width: 1000px;height:300px" src="Image\ostream_iterator.png">

     - **可以**提供第二个参数，它是一个字符串，在输出每个元素后，都会打印这个字符串，**==这个字符串必须是一个C风格的字符串==**
     - ==**不允许空的或表示尾后位置的`ostream_iterator`**==

3. 反向迭代器

   - **反向迭代器需要递减运算符**，我们只能从即支持`++`也支持`--`的迭代器来定义反向迭代器。
   
     <img style="width: 700px;height:200px" src="Image\反向迭代器和普通迭代器之间的关系.png">
   
     ```c++
     std::string str("FIRST,MIDDLE,LAST");
     auto rcomma = std::find(str.rbegin(), str.rend(), ',');
     //转换成正常的迭代器。正向打印单词
     std::cout<<std::string(rcomma.base(),str.end())<<std::endl;
     ```
   
   - `rcomma`和`rcomma.base()`**指向不同的元素**，`line.crbegin` 和`line.cend()`也是如此。==**这些不同保证了元素范围无论是正向处理还是反向处理都是相同的**==。
   
   - `vector<int>::reverse_iterator be`反向迭代器

#### 泛型算法结构

1. 迭代器类型

   1. 输入迭代器：读取序列中的元素，**必须支持的操作**

      - **==只读，不写；单遍扫描，只能递增==**

      - `==`,`!=`

      - 前置和后置`++`

      - 读元素的解引用`*`,箭头运算符`->`

   2. 输出迭代器

      - 只写，不读:单遍扫描，只能递增

      - 用于推进迭代器的**前置和后置递增运算**`++`

      - 解引用运算符`*`,只出现在赋值运算符的左侧(向一个已经解引用的输出迭代器
        赋值，就是将值写入它所指向的元素)

   3. 前向迭代器
      - 可读写;多遍扫描，只能递增

   4. 双向迭代器
      - 可读写;多遍扫描，可递增递减

   5. 随机访问迭代器
      - 可读写，多遍扫描，支持全部迭代器运算

2. 算法形参模式
   - **接受单个目标迭代器的算法**
     - 如果`dest`是一个直接指向容器的迭代器，那么算法将输出数据写到容器中已经存在的元素内。
     - 向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据。
   - 接受第二个输入序列的算法
     - 接受**单独的**`beg2`或是**接受`beg2`和`end2`**的算法用这些迭代器**表示第二个输入范围**。这些算法通常**使用第二个范围中的元素与第一个输入范围结合来进行一些运算**。
   - ==**一些算法的重载形式传递一个谓词**==：替换默认的`<`或`==`运算符
   - ==**`_if`算法**==
     - `find(beg,end,val)`,`find_if(beg,end,pred)`
     - 这两个算法提供了命名上差异的版本，而非重载版本，因为两个版本的算法都接受相同数目的参数。因此可能产生重载歧义。
     - **==拷贝元素版本和不拷贝版本==**：写到额外目的空间算法都在名字后面附加一个`_copy`

#### 特定容器算法

<img style="width: 1000px;height:300px" src="Image\list和forward_list.png">

<img style="width: 1000px;height:150px" src="Image\list和forward_list2.png">

<img style="width: 1000px;height:350px" src="Image\splice.png">

- ==对于`list`和`forward list`,应该优先使用成员函数版本的算法而不是通用算法。==

### 关联容器

<img style="width: 1000px;height:400px" src="Image\关联容器类型.png">

#### 使用关联容器

1. 八个容器的不同体现在**三个维度**上
   - `set`或`map`
   - 不重复关键字或者允许重复关键字
   - 顺序或无序，允许重复关键字`multi`，**不保持关键字按顺序存储**，`unordered`

#### 关联容器概述

1. ==**关联容器不支持顺序容器的位置相关的操作**==，例如`push_front`，原因是关联容器中元素是根据关键字存储的。

   - 关联容器的迭代器**都是双向的**。

   `map<string,int>m = {{key,value},{key,value}}`

2. 关键字类型要求

   - **对于有序容器**：关键字类型必须定义元素的比较方法。默认使用`<`运算符来比较关键字。
   - ==**严格弱序**==
     - 两个关键字不能同时“小于等于”对方
     - 如果k1“小于等于”k2，且k2“小于等于”k3，那么k1必须“小于等于”k3。
     - 如果存在两个关键字，任何一个都不“小于等于”另一个，那么我们称这两个关键字是“等价”的。
   - **自定义的操作**
     - `std::map<std::string, int, decltype(compare)*> myMap(compare);`
     - 比较操作类型**应该是一种函数指针类型**。

3. `pair`类型`utility`头文件

   <img style="width: 1000px;height:400px" src="Image\pair上的操作.png">

   ```c++
   pair<string,int>
       process(vector<string>&v)
   {
       //处理v
       if(!v.empty())
       {
           return {v.back(),v.back().size()};//列表初始化
       }
       else
       {
           return pair<string,itn>();//隐式构造返回值
       }
   }
   ```

#### 关联容器操作

<img style="width: 1000px;height:200px" src="Image\关联容器的额外类型.png">

1. 关联容器迭代器
   - **解引用一个==关联容器迭代器时==**，会得到一个类型为容器的`value_type`的值的引用，对`map`，`value_type`是一个`pair`类型，`first`成员保存`const`的关键字。
   - `set`类型同时定义了`iterator`和`const_iterator`类型，但两种类型都只允许==**读**==访问`set`中的元素。

2. 添加元素

   <img style="width: 1000px;height:500px" src="Image\关联容器insert操作.png">

   1. `insert`成员，两个版本，分别接受一对迭代器，或是一个初始化器列表，这两个版本的行为类似对应的构造函数，**对于一个给定的关键字，只有第一个带此关键字的元素才被插入到容器中**。
   2. 向`map`添加元素，
     - `word_count.insert ({word,1});`
     - `word_count.insert (make_pair (word,1) );`
     - `word_count.insert (pair<string,size_t> (word,1));`
     - `word_count.insert(map<string,size_t>::value_type (word,1));`

3. 删除元素

   <img style="width: 1000px;height:300px" src="Image\从关联容器删除元素.png">

4. `map`的下标操作

   - ==**我们不能对一个`multimap`或一个`unordered_multimap`进行下标操作**==，因为这些容器中可能有多个值与一个关键字相关联。
   - `map`下标运算符接受一个索引(即，一个关键字)获取与此关键字相关联的值。但是，与其他下标运算符不同的是，**如果关键字并不在map中，会为它创建一个元素并插入到`map`中**，关联值将进行值初始化。
   - `C.at(k)`：访问关键字为`k`的元素，==**带参数检查**==；若`k`不在`c`中，抛出一个`out_of_range`异常。

5. 访问元素

   <img style="width: 1000px;height:100px" src="Image\关联容器查找2.png">

   <img style="width: 1000px;height:300px" src="Image\关联容器查找.png">

   - **==如果一个multimap或multiset中有多个元素具有给定关键字，则这些元素在容器中会相邻存储。==**
     - 最直观的方法是使用`find`和`count`。容器的成员函数
     - 如果关键字在容器中，`lower_bound`返回的迭代器指向第一个具有给定关键字的元素，而`upper_bound`返回的迭代器则指向最后一个匹配给定关键字的**元素之后的位置**。如果元素不在 `multimap `中，则` lower_bound`和`upper_bound`会返回相同的迭代器**----指向一个不影响排序的关键字插入位置**。
     - 最直接的方法`equal_range`

#### 无序容器

<img style="width: 1000px;height:700px" src="Image\无序容器的管理操作.png">

1. **无序容器在存储上组织为一组桶**，每个桶保存**零个或多个元素**。无序容器使用一个**哈希函数将元素映射到桶**。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。**容器将具有一个特定哈希值的所有元素都保存在相同的桶中**。如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。
2. **默认情况下，无序容器使用关键字类型的==运算符来比较元素**，它们还使用一个`hash<key_type>`**类型的对象**来生成每个元素的哈希值。标准库为**内置类型(包括指针)提供了hash模板**。**还为一些标准库类型**，包括`string`和智能指针类型定义了`hash`。因此，我们可以直接定义关键字是内置类型（包括指针类型)、string 还是智能指针类型的无序容器。
3. **我们==不能直接定义关键字类型==为自定义==类类型==的无序容器**。与容器不同，不能直接使用哈希模板，**而必须提供我们自己的`hash`模板版本**。我们将在16.5节(第626页)
   - 使用一个哈希函数，和关键字类型的`==`运算符组织元素。

### 动态内存

#### 动态内存与智能指针

- `memory`头文件

  - `make_shared`函数

    - 最安全的分配和使用动态内存的方法是调用一个名为`make_shared`的标准库函数。
    - `make_shared`用其参数来==**构造**==给定类型的对象，传递的参数要和类型的构造函数相匹配。
  
  - `shared_ptr`：允许多个指针指向同一个对象
  
    <img style="width: 1000px;height:300px" src="Image\智能指针1.png">
  
    <img style="width: 1000px;height:300px" src="Image\智能指针2.png">
  
    - 最后一个`shared_ptr`销毁前内存都不会释放，保证`shared_ptr`在无用之后不在保留
  
    - `shared_ptr`和`new`结合使用
  
      - 接受**指针参数**的智能指针**构造函数是`explicit`的**，我们不能将一个内置指针隐式转换为一个智能指针。
  
        ```c++
        shared_ptr<int> p1 = new int(1023);//错误
        shared_ptr<int> p2(new int(1023));
        ```
  
      - **==默认情况下，一个用来初始化的智能指针的普通指针必须指向动态内存，因为智能指针默认使用`delete`释放它所关联的对象。==**
  
        <img style="width: 1000px;height:200px" src="Image\改变shared_ptr的其它方法.png">
  
        <img style="width: 1000px;height:250px" src="Image\改变shared_ptr的其它方法2.png">
  
      - ==**`shared_ptr`可以协调对象的析构，但这仅限于其自身的拷贝**==
  
      - 当将一个`shared_ ptr`绑定到一个普通指针时，我们就将内存的管理责任交给了这个`shared_ ptr`。一旦这样做了 ，我们就不应该再使用内置指针来访问`shared_ ptr`所指向的内存了。
  
      - `get`函数：我们需要**向不能使用智能指针的代码**传递一个内置指针，使用`get`返回的指针的代码不能`delete`此指针。
  
      -  **如果在`new`和`delete`之间发送异常，且异常未在`f`中被捕获，则内存就永远不会被释放了**
  
        - 在异常发生后资源能被正确的释放，一个简单的确保资源被释放的方法是使用智能指针。
  
  - `unique_ptr`：“**独占**”所指向的对象
  
    <img style="width: 1000px;height:400px" src="Image\unique_ptr.png">
  
    - **==不能拷贝或赋值`unique_ptr`==**，可以通过调用`release`或`reset`将指针的所有权（非const）`unique_ptr`转义给另一个`unique`
    - `reset`成员接受一 个可选的指针参数，令`unique_ ptr`重新指向给定的指针。如果`unique_ ptr`不为空，它原来指向的对象被释放。
    - ==**不能拷贝`unique_ ptr`的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的`unique_ ptr`。 **==
      - ==**最常见的例子是从函数返回一个`unique_ ptr`**==
      - 还可以返回一个局部对象的拷贝
    - 标准库早期版本`auto_ptr`具有`unique_ptr`的部分特性
      - 不能在容器中保存`auto_ptr`不能从函数中返回`auto_ptr`
    - `unique_ptr`默认使用`delete`
      - 我们必须在**尖括号中**`unique_ptr`指向类型之后提供删除器类型。在创建或`reset`一个这种`unique_ ptr`类型的对象时，必须提供一个指定类型的可调用对象
        - `unique_ptr<objT,delT> p(new objT,fcn);`
    
  - `weak_ptr`：
  
    <img style="width: 1000px;height:400px" src="Image\weak_ptr.png">
  
    - `weak_ptr`指向一个`share_ptr`管理的对象。**将一个`weak ptr`绑定到一个`shared ptr`不会改变`shared_ ptr`的引用计数**。一旦最后一个指向对象的`shared_ptr`被销毁，对象就会被释放。即使有`weak_ ptr`指向对象，对象也还是会被释放。
    - ==**由于对象可能不存在，我们不能使用`weak_ ptr` 直接访问对象，而必须调用`lock`。此函数检查`weak_ ptr`指向的对象是否仍存在。**==
  
- 直接管理内存

  - 自由空间分配的内存是无名的，`new`无法为其分配的对象命名，默认情况下，**动态分配的对象是默认初始化的**，而类类型对象将使用默认构造函数进行初始化。

  - 可以使用直接初始化，传统的构造方式，列表初始化来初始化一个动态分配的对象。

    ```c++
    int *pi = new int(1024);//直接初始化
    int *pi2 = new int();//值初始化为0
    int *pi3 = new int;//默认初始化
    string * ps = new string(10,'9');
    vector<int>*pv = new vector<int>{1,2,3,4,5};
    ```

  - 如果我们提供了**一个括号包围的初始化器**，**就可以使用`auto`从此初始化器来推断我们想要分配的对象的类型**。但是，由于编译器要用初始化器的类型来推断要分配的类型，只有当括号**中仅有单一初始化器**时才可以使用`auto`

    - `auto p = new auto(obj);`
    - `p`指向一个与`obj`类型相同的对象该对象用`obj`进行初始化

  - **动态分配的`const`对象**

    - 一个动态分配的`const`对象必须进行初始化，**定义了默认构造函数的类类型**，其`const`动态对象可以隐式初始化。

      ```c++
      const int * pci = new const int(1024);
      ```

  - ==**内存耗尽**==

    - `new`表达式失败：抛出一个类型为`bad_alloc`的异常

    - **定位new**：向`new`传递`nothrow`对象，不抛出异常，不能分配内存返回空指针。

    - `bad_alloc`和`nothrow`定义在**==头文件new中==**

      ```c++
      int *p1 = new int;
      int *p2 = new(nothrow)int;
      ```

  - 指针值和`delete`

    - 我们传递给`delete`的指针必须指向动态分配的内存，或者是一个空指针
    - 释放一个空指针总是没有错误的
    - **空悬指针**：指向一块曾经保存数据对象但现在已经无效的内存的指针。

- **使用我们自己的释放操作**

  - 定义一个函数来代替`delete`，这个删除器函数必须能够完成对`shared_ptr`中保存的指针进行释放的操作。
  - 不使用相同的内置指针值初始化(或`rese`t)多个智能指针。
  - 不`delete get()`返回的指针。
  - 不使用`get()`初始化或`reset`另一个智能指针。
  - 如果你使用`get()`返回的指针，记住当最后一个对应的智能指针销毁后，你的
    指针就变为无效了。
  - 如果你使用智能指针管理的资源不是`new`分配的内存，记住传递给它一个删除器。

#### 动态数组

- `new`和数组：方括号中的大小必须是整形，但不必是常量

  ```c++
  typedef int arrT[42];
  int *p1 = new int[10];
  int *p2 = new arrT;
  
  int *p3 = new int[10]();//值初始化为0的int
  int *p4 = new string[10]{"a","an","the",string(3,'x')};//元素初始化花括号列表
  ```

  - `new`分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。
  - 如果**初始化器数目大于元素数目，则`new`表达式失败**，不会分配任何内存。在本例中，`new`会抛出一个类型为`bad_array_new_length`的异常。此类型定义在头文件`new`中。
  - `new`分配一个大小为`0`的数组时，`new`返回一个合法的非空指针。此指针保证与`new`返回的其他任何指针都不相同。对于零长度的数组来说，此指针就像尾后指针一样。

- 释放动态数组：`delete [] pa`

  - 销毁`pa`指向的数组中的元素，并释放对应的内存，数组中的元素**按逆向销毁**。方括号是必须的。

- 智能指针和动态数组

  <img style="width: 1000px;height:300px" src="Image\智能指针和数组.png">

  - `shared_ptr`管理的动态数组，必须提供自己定义的删除器
    - `shared_ptr<int> sp(new int[10],[](int *p){delete []p;});`

- `allocator`类：`memory`头文件

  - 将内存分配和对象构造分离开。

  <img style="width: 1000px;height:300px" src="Image\allocator.png">

  <img style="width: 1000px;height:300px" src="Image\allocator算法.png">

### 拷贝控制

- 当定义一个类时，我们**显式地**或**隐式地**指定在此类型的对象**拷贝**、**移动**、**赋值和销毁**时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括:拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数。

#### 拷贝，赋值与销毁

- 拷贝构造函数

  - 如果一个构造函数的第一个参数是自身类类型的引用，==**且任何额外参数都有默认值**==，则此构造函数是拷贝构造函数。拷贝构造函数的第一个参数必须是一个引用类型，原因我们稍后解释。**虽然我们可以定义一个接受非`const`引用的拷贝构造函数，但此参数几乎总是一个`const`的引用**。**拷贝构造函数在几种情况下都会被隐式地使用**。因此，拷贝构造函数通常不应该是 explicit

    - `Foo(const Foo&);`

  - 合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中(除去`static`成员)

    - **逐元素地拷贝一个数组类型的成员**

  - **用花括号列表初始化一个数组中的元素或一个聚合类中的成员会发生拷贝初始化。**

  - ==**在拷贝初始化过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数。**==

    ```c++
    string null_book = "9-999-99999-9";
    //改写为
    string null_book("9-999-99999-9");
    //即使编译器掠过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是存在且可访问的
    ```

- 拷贝赋值运算符

  - 重载赋值运算符
    - **operator关键字**后接表示要定义的运算符的符号组成
    - **重载运算符的==参数==表示==运算符的运算对象==**。某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的`this`参数。对于**一个二元运算符**，例如赋值运算符，其**右侧运算对象作为显式参数传递**。
    - 标准库通常要求**保存在容器中的类型**要具有赋值运算符，且其返回值是左侧运算对象的引用。
  - **合成的拷贝复制运算符**和合成的拷贝构造函数一样

- 析构函数

  - 在一个析构函数中，**首先执行函数体**，**然后销毁成员**。成员按初始化顺序的**逆序销毁**。
    - 认识到析构函数体自身并不直接销毁成员是非常重要的。**成员是在析构函数体之后隐含的析构阶段中被销毁的**。在整个对象销毁过程中，**析构函数体是作为成员销毁步骤之外的另一部分而进行的**。
  - 成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数，内置类型没有析构函数，因此**销毁==内置类型成员==什么也不需要做**。
  - ==**隐式销毁一个内置指针类型的成员不会`delete`它所指向的对象。**==
  - ==**当指向一个对象的引用或指针离开作用域时，析构函数不会执行。**==

- 使用`=default`

  - `=default`来显示地要求编译器生成合成的版本
  - 在类内用`=default`修饰成员的声明时，合成的函数将隐式地声明为内联的。如果我们==**不希望合成的成员是内联函数**==，因该**只对==成员的类外定义==使用**`=default`

- 阻止拷贝

  - 我们可以通过将**拷贝构造函数**和**拷贝赋值运算符**定义为删除的函数来阻止拷贝。
    - `NoCopy(const NoCopy&)=delete;`

  - **`=delete`必须出现在函数第一次声明的时候**

  - 我们可以对任何函数指定`=delete`。希望引导函数匹配过程时，删除函数有时也是有用的

  - 我们不能删除析构函数。如果析构函数被删除，就无法销毁此类型的对象了。对于一个删除了析构函数的类型，**编译器将不允许定义该类型的变量或创建该类的临时对象。**而且，如果**一个类有某个成员的类型删除了析构函数**，我们也不能定义该类的变量或临时对象。

  - 对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，**但可以动态分配这种类型的对象。但是，不能释放这些对象**。

  - ==**合成的拷贝控制成员可能是删除的**==
    - 如果**类的某个成员的==析构函数==是删除的或不可访问的**（例如，是`private` 的)，则类的合成析构函数被定义为删除的。
    - 如果类的**某个成员的==拷贝构造函数==是删除的或不可访问的**，则**类的==合成拷贝构造函数==被定义为删除**的。如果**类的某个成员的析构函数是删除**的或不可访问的，则**类合成的拷贝构造函数也被定义为删除**的。
    - 如果**类的某个成员的拷贝赋值运算符是删除的**或不可访问的，或是**类有一个`const`的或引用成员**，则**类的合成拷贝赋值运算符被定义为删除**的。
    - 如果**类的某个成员的析构函数是删除的或不可访问的**，或是**类有一个引用成员，它没有类内初始化器**（参见2.6.1节，第65页)，**或是类有一个` const`成员**，**它没有类内初始化器且其类型未显式定义默认构造函数**，则该类的默认构造函数被定义为删除的。
    - 这些规则的含义是:**如果一个类==有数据成员不能默认构造、拷贝、复制或销毁,==**则对应的成员函数将被定义为删除的。
    - **一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的**，这看起来可能有些奇怪。其原因是，如果没有这条规则，我们可能会创建出无法销毁的对象。
    - 对于**具有引用成员或无法默认构造的`const`成员的类**，编译器不会为其合成默认构造函数，这应该不奇怪。同样不出人意料的规则是：如果一个**类有`const`成员**、则它不能使用**合成的==拷贝赋值==运算符**,毕竟，此运算符试图赋值所有成员，而将一个新值赋予一个`const`对象是不可能的。
    - 虽然我们可以将一个新值赋予一个引用成员，但这样做**改变的是==引用指向==的对象的值**，而不是引用本身。(如果为这样的类合成拷贝赋值运算符，则赋值后，左侧运算对象仍然指向与赋值前一样的对象，而不会与右侧运算对象指向相同的对象。由于这种行为看起来并不是我们所期望的，因此对于有引用成员的类，合成拷贝赋值运算符被定义为删除的。

  - ==**通过声明（但不定义）**==`private`的拷贝控制成员，我们可以预先阻止任何拷贝该类型对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误，成员函数或友元函数中的拷贝操作将会导致连接时错误。（旧标准）
    - **希望阻止拷贝的类因该使用`=delete`**


#### 拷贝控制和资源管理

- 关键概念：**赋值运算符**
  - 如果将一个对象赋予它自身，赋值运算符必须能正确工作。·
  - 大多数赋值运算符组合了析构函数和拷贝构造函数的工作。
    - 当你编写一个赋值运算符时，一个好的模式是**先将右侧运算对象拷贝到一个局部临时对象中**。当拷贝完成后，**销毁左侧运算对象**的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下**将数据从临时对象拷贝到左侧运算对象**的成员中了。

#### 交换操作

- ```c++
  class HasPtr
  {
      friend void swap(HasPtr&,HasPtr&);
  };
  inline void swap(HasPtr&lhs,HasPtr&rhs)
  {
      using std::swap;
      swap(lhs.ps,rhs.ps);//ps 是string
      swap(lhs.i,rhs.i);//i 是 int
      //如果一个类的成员有自己类型特定的swap函数，就会调用类自定义的版本。
      //否则调用标准库的版本
  }
  ```

- 在赋值运算符中使用swap

  - ```c++
    HasPtr& HasPtr::operator=(HasPtr rhs)
    {
        swap(*this,rhs);
        return *this;
    }
    ```

  - 这个版本的赋值运算符中，参数**并不是一个引用**。`rhs`是右侧运算对象的一个副本且自动处理了自赋值情况且天然就是异常安全的

#### 拷贝控制示例

一段程序

#### 动态内存管理类

一段程序

1. 移动构造函数
   - 有一些标准库类，包括string，都定义了所谓的**移动构造函数**。移动狗战术通常是将资源从给定对象**移动**而不是拷贝到正在创建的对象。

1. `std::move`
   - 定义在`utility`头文件中，调用`move`表示希望使用`string`的移动构造函数。如果漏掉了move的调用，将会使用`string`的拷贝构造函数。通常不为move提供一个`using`声明，调用`move`时，直接调用`std::move`而不是move

#### 对象移动

1. 右值引用
   - 只能绑定到一个将要销毁的对象
   - 返回非引用类型的函数，连同算术、关系、位以及**后置递增/递减运算符**，都生成右值。我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个 const 的左值引用或者**一个右值引用**绑定到这类表达式上。
   - 变量可以看作是只有一个运算对象而没有运算符的表达式，变量表达式也有左值/右值属性，**变量表达式**都是左值。
     - 不能将一个右值引用绑定到一个右值引用类型的变量上
   - `move`标准库函数获得**绑定到左值上右值引用**。
     - 调用`move`就意味着承诺：除了对rr1赋值或销毁它外，我们将不再使用它，在调用move后，我们不能对移动后源对象的值做任何假设。
     - **我们可以销毁一个移动后源对象，也可以赋予它新值，但不能使用一个移动后源对象的值**

2. 移动构造函数和移动赋值运算符

   ```c++
   StrVec::StrVec(StrVec &&s) noexcept //移动操作不应该抛出任何异常
       :elements(s.elements),first_free(s.first_free),cap(s.cap)
   {	//成员初始化器接管s中的资源
       //令s进入这样的状态，对其运行析构函数是安全的
       s.elements = s.first_free = s.cap = nullptr;
   }
   StrVec& StrVec::operator=(StrVec &&rhs) noexcept
   {
       if(this!= &rhs) //检查的原因是此右值可能是move调用的返回结果
       {
           free();
           //接管rhs的资源
           elements = rhs.elements;
           first_free = rhs.first_free;
           cap = rhs.cap;
           
           //将rhs置于可析构状态
           rhs.elements = rhs.first_free = rhs.cap = nullptr;
       }
   }
   ```

   - 由于移动操作“**窃取**”资源，它通常不分配任何资源。因此，移动操作通常不会抛出任何异常。**当编写一个不抛出异常的移动操作时，我们应该将此事通知标准库**。我们将看到，==**除非标准库知道我们的移动构造函数不会抛出异常**==，否则它会认为移动我们的类对象时可能会抛出异常，并且**为了处理这种可能性而做一些额外的工作**。

   - 我们必须在**类头文件的==声明中和定义中==**都指定`noexcept`

   - 编写**移动操作时**，必须确保移动后源对象进入一个可析构的状态。还必须保证对象仍然是有效的，对象有效就是指可以安全地为其赋予新指或者可以安全地使用而不依赖其当前值。

   - 如果一个类**定义**了自己的拷贝构造函数，拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。
     - 如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来代替移动操作
     - 只有当**一个类没有定义任何自己版本的拷贝控制成员**，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员:
     
   - 与拷贝操作不同，**移动操作永远不会隐式定义为删除的函数**。**但是，如果我们显式地要求编译器生成=default的(参见7.1.4节，第237页）移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数**。除了一个重要例外，什么时候将合成的移动操作定义为删除的函数遵循与定义删除的合成拷贝操作类似的原则(参见13.1.6节，第449页):
     - 与拷贝构造函数不同，移动构造函数被定义为删除的函数的条件是:**有类成员==定义了自己==的拷贝构造函数且未定义移动构造函数，或者是有类成员==未定义==自己的拷贝构造函数且编译器==不能为其合==成移动构造函数**。移动赋值运算符的情况类似。
     - 如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的。
     - 类似拷贝构造函数，如果**类的析构函数被定义为删除的或不可访问**的，则类的移动构造函数被定义为删除的。
     - 类似拷贝赋值运算符，如果有类成员是`const `的或是引用，则类的移动赋值运算符被定义为删除的。
     
   - **移动操作**和**合成的拷贝控制成员**间还有最后**一个相互作用关系**:一个类**是否定义了自己的移动操作**对**拷贝操作如何合成有影响**。如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。

   - 如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数(参见6.4节，第208页)。赋值操作的情况类似。例如，在我们的`StrVec`类中，拷贝构造函数接受一个`const StrVec`的引用。因此，它可以用于任何可以转换为`StrVec`的类型。而移动构造函数接受一个strVec&&，因此只能用于实参是（非static）右值的情形。
     - **如果没有移动构造函数，右值也被拷贝**
     
   - ==**五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作**。==

     - 拷贝构造函数，拷贝赋值运算符，移动构造函数，移动赋值运算符，析构函数

   - **为一个类添加一个移动构造函数，实际上也会获得一个移动赋值运算符**。

     ```c++
     class HasPtr
     {
         public:
         HasPtr(HasPtr&&p)noexcept:ps(p.ps),i(p.i){p.ps = nullptr;}
         //赋值运算符即是移动赋值运算符，也是拷贝赋值运算符
         HasPtr&operator=(HasPtr rhs)
         {
             swap(*this,rhs);
             return *this;
         }
     }
     ```

     

3. 移动迭代器

   - `make_move_iterator`函数将一个普通迭代器转换为一个移动迭代器，此函数接受一个迭代器参数，返回一个移动迭代器。**移动迭代器的==解引用运算符生==成一个右值引用**。

     ```c++
     void StrVec::reallocate()
     {
     	auto necapacity = size() ? 2 * size() : 1;
     	auto first = alloc.allocate(necapacity);
     
     	auto last = std::uninitialized_copy(std::make_move_iterator(begin()),
     		std::make_move_iterator(end()), first);
         //
     	free();
     	elements = first;
     	first_free = last;
     	cap = first + necapacity;
     }
     ```

4. 移动成员函数

   - 如果一个成员函数提供拷贝和移动版本，它也能从中受益。一般来说，我们不需要为函数操作定义接受一个`const X&&`或是一个（普通的）`X&`参数的版本。当我们希望**从实参“窃取”数据时，通常传递一个右值引用**。**为了达到这目的，实参不能是` const`的**。类似的，从一个对象进行考贝的操作不应该改变该对象因此，通常不需要定义一个接受一个（普通的）X&参数的版本。

     ```c++
     void StrVec::push_back(const std::string& s)//拷贝元素
     {
     	chk_n_alloc();
     	alloc.construct(first_free++, s);
     
     }
     void StrVec::push_back(std::string&& s)//移动元素
     {
     	chk_n_alloc();
     	alloc.construct(first_free++, std::move(s));
     }
     
     ```

   - 通常，我们在一个对象上调用成员函数，而不管该对象是一个左值还是友值。例如：

     - `string s1 = "a value",s2 = "another";`
       `anto n = (s1+s2).find('a');`

       `s1 + s2 = "wow!"` 有时右值的使用方式可能令人惊讶！

     - 在自己的**类中**阻止使用这种用法，在此情况下，我们希望**==强制左侧对象（this指向的对象）是一个左值==**。即在参数列表后放置一个==**引用限定符**==。

     - 引用限定符可以是`&`或`&&`，分别==**指出`this`可以指向一个左值或右值**==。类似`const`限定符，**引用限定符只能用于(非static）成员函数**，且==**必须同时出现在函数的声明和定义中**==

       ```c++
       class Foo
       {
           public:
           Foo &operator=(const Foo&)&;//只能向可修改的左值赋值
           
           Foo anotherMem()const &;//一个函数可以同时用const和引用限定。在此情况下﹐引用限定符必须跟随在cons限定符之后。
       }
       Foo& Foo::operator=(const Foo&rhs)&
       {
           //执行将rhs赋予本对象所需的工作
           return *this;
       }
       ```

   - 重载和引用函数

     ```c++
     class Foo
     {
     public:
     	Foo sorted()&&//Foo 右值可调用这个函数
     	{
     		std::sort(data.begin(), data.end());
     		return *this;
     	}
         
     	Foo sorted() const & //const Foo(右值) 或 Foo(左值)，哪种情况我们都不能对其进行源地排序
     	{ 
             Foo ret(*this);//拷贝构造函数
             sort(ret.data.begin(),ret.data.end());//排序副本
     		//return Foo(*this).sorted(); 
     	}
     private:
     	std::vector<int> data;
     };
     ```

     - 当我们定义`const`成员函数时,可以定义两个版本,唯一的差别是一个版本有`const`限定而另一个没有。引用限定的函数则不一样。如果我们**定义两个或两个以上具==有相同名字和相同参数列表==的成员函数，就必须对所有函数都==加上==引用限定符，或者所有==都不加==**。

### 重载运算与类型转换

#### 基本概念

- ==**除了重载的函数调用运算符`operator()`之外，其它重载运算符不能含有默认实参**==。

- 当一个重载的运算符是成员函数时，==**`this`绑定到左侧运算对象**==。

- 对于一个运算符函数来说，**它或者==是类的成员==**，或者**至少==含有一个类类型的参数==**。

  <img style="width: 1000px;height:300px" src="Image\运算符.png">

  ```c++
  //一个非成员运算符函数的等价调用
  data1 + data2;			//普通的表达式
  operator+(data1,data2);	//等价的函数调用
  
  data1+=data2;			
  data1.operator+=(data2);//对成员运算符函数的等价调用
  ```

- 回忆之前介绍过的，**某些运算符指定了运算对象求值的顺序**。**因为使用重载的运算符本质上是一次函数调用**，**所以这些关于==运算对象求值顺序的规则==无法应用到重载的运算符上**。特别是，==**逻辑与**==、==**逻辑或**==和==**逗号**==运算符的运算对象**求值顺序规则无法保留下来**。除此之外，**&&和||运算符的重载版本也无法保留内置运算符的短路求值属性**，两个运算对象总是会被求值。因为上述运算符的重载版本无法保留求值顺序和/或短路求值属性,因此不建议重载它们。当代码使用了这些运算符的重载版本时，用户可能会突然发现他们一直习惯的求值规则不再适用了。

- 还有一个原因使得我们**一般不重载逗号运算符==取地址运算符==**：**C++语言已经定义了两种运算符用于类类型对象时的特殊含义**，这一点与大多数运算符都不相同。因为这两种运算符已经有了内置的含义，所以一般来说它们不应该被重载，否则它们的行为将异于常态，从而导致类的用户无法适应。

- **==只有当操作的含义对于用户来说清晰明了时才使用运算符==**

- **选择作为成员或者非成员**

  - **赋值(=)**、**下标([])**、**调用（()）**和**成员访问箭头(->)**运算符==**必须是成员**==。
  - **复合赋值运算符一般来说应该是成员，但并非必须**,这一点与赋值运算符略有不同。
  - **改变对象状态的运算符或者与给定类型密切相关的运算符**，如递增、递减和解引用运算符，通常应该是成员。
  - **具==有对称性==的运算符可能转换任意一端的运算对象**，例如算术、相等性、关系和位运算符等，**因此它们通常应该是普通的非成员函数**。

  ```c++
  string s = "world";
  string t = s + "!";
  string u = "hi" + s; // "hi".operator+(s) const char * 没有成员函数
  ```

  - **当我们把运算符定义成成员函数时，它的==左侧运算对象==必须是运算符==所属类==的一个**
  - 因为`string` 将`＋`定义成了普通的非成员函数，所以`"hi"+s `等价于`operator+("hi",s)`。和任何其他函数调用一样，每个实参都能被转换成形参类型。唯一的要求是至少有一个运算对象是类类型，并且两个运算对象都能准确无误地转换成`string`。

#### 输入和输出运算符

- **输出运算符尽量减少==格式化操作==**可以使用户有权控制输出的细节

- **输入运算符必须处理==输入可能失败的情况==，而输出运算符不需要**

  - 当流含有错误类型的数据时读取操作可能失败。当读取操作到达文件尾或者遇到输入流的其它错误时也会失败。

  - **当读取操发生错误时，输入运算符应该负责从错误中恢复。**

  - **一些输入运算符需要做更多数据验证的工作**，例如，我们的输入运算符可能需要检查`bookNo`**是否符合规范**的格式。在这样的例子中，**即使从技术上来看`IO`是成功的，输入运算符也应该设置流的条件状态以标示出失败信息**。通常情况下,输入运算符只设置`failbit`。除此之外，设置`eofbit`表示文件耗尽，而设置`badbit`表示流被破坏,最**好的方式是由IO标准库自己来标示这些错误。**

    ```c++
    std::istream& operator>>(std::istream& in, Sales_data& data)
    {
    	double price;
    	in>>data.bookNo>>data.units_sold>>price;
    	if (in)
    	{
    		data.revenue = data.units_sold*price;
    	}
    	else
    	{
    		data = Sales_data();
    	}
    	return in;
    }
    ```

#### 算术和关系运算符

1. 算术运算符

   - 把算术和关系运算符定义成非成员函数以允许对左侧或右侧的对象进行转换。

   - 算术运算符通常会**计算**它的**两个运算对象并得到一个新值**，这个值有别于任意一个运算对象，**常常位于一个局部变量之内**，操作完成后**返回该局部变量的副本**作为其结果

     ```c++
     Sales_data operator+(const Sales_data &lhs,const Sales_data &rhs)
     {
         Sales_data sum(lhs);
         sum+=rhs;//如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下因该使用复合赋值来实现算术运算符
         return sum;
     }
     ```

2. 相等运算符

   - **比较对象的每一个数据成员，只有当所有对应的成员都相等时才认为两个对象相等**。
   - 相等运算符和不相等运算符中的一个应该把工作委托给另外一个,这意味着其中一个运算符应该负责实际比较对象的工作，而另一个运算符则只是调用那个真正工作的运算符。

3. 关系运算符

   - 定义了相等运算符的类也常常（但不总是）包含关系运算符。特别是，因为**关联容器和一些算法要用到小于运算符**，所以定义`operator<`会比较有用。通常情况下关系运算符应该
     - 定义顺序关系，令其与关联容器中对关键字的要求一致（参见11.2.2节，第378页);
     - 如果类同时也含有`==`运算符的话，则定义一种关系令其与`==`保持一致。特别是，==**如果两个对象是`!=`的，那么一个对象应该`<`另外一个**==。
     - 如果存在唯一一种逻辑可靠的`<`定义,则应该考虑为这个类定义`<`运算符。如果类同时还包含`==`,则当且仅当`<`的定义和`==`产生的结果一致时才定义`<`运算符。
       - **一致性要求**：若 `a == b` 为 `true`，则 `a < b` 和 `b < a` 必须均为 `false`

#### 赋值运算符

- 类还可定义其它赋值运算符**以使用==别的类型==作为右侧运算对象**。、

  ```c++
  std::vector<std::string> v;
  v={"a","an","the"};
  
  class StrVec
  {
      public:
      StrVec&operator=(std::initializer_list<std::string> il)
      {
          auto data = alloc_n_copy(il.begin(),il.end());
          free();
          elements = data.first;
          first_free = cap = data.second;
          return *this;
      }
  }
  ```

  - **这个运算符无须检查对象向自身的赋值**，这是因为它的形参`initializer list<string>`(参见6.2.6节，第198页）**确保`il`与`this`所指的不是同一个对象**。

- **复合赋值运算符**

  - 复合赋值运算符不非得是类的成员，不过**我们还是倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部**。`+=`，`-=`

#### 下标运算符

- 下标运算符通常以所访问元素的引用作为返回值，**我们最好定义下标运算符的常量和非常亮版本**。

  ```c++
  class StrVec
  {
      public:
      std::string& operator[](std::size_t n)
      {
          return elements[n];
      }
      const std::string& operator[](std::size_t n)const;
      private:
      std::string *elements;		//指向数组首元素的指针
  }
  ```

  

#### 递增和递减运算符

- C++语音并不要求递增和递减运算符必须是类的成员，但是因为他们改变的正好是说操作对象的状态，**所以建议将其设定尾成员函数**。

- **==前置和后置版本使用的是同一个符号==，意味着其重载版本所用的名字将是相同的,并且运算对象的数量和类型也相同。为了==解决这个问题，后置版本接受一个额外的(不被使用) `int`类型的形参==。当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参。尽管从语法上来说后置函数可以使用这个额外的形参，但是在实际过程中通常不会这么做。这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。**

  ```c++
  class StrBlobPtr
  {
      public:
      //因为我们不会用到int形参，说以无须为其命名
      StrBlobPtr operator++(int)//后置运算符
      {
          auto ret = *this;
          //实现
          return ret;
      }
      StrBlobPtr& operator++(){//实现}
    	StrBlobPtr operator+(int n); //+n 实现指针运算
  };
  StrBlobPtr p(a1);
  p.operator++(0);		//调用后置版本的++
  p.operator++();			//前置版本
  ```

#### 成员访问运算符

- **箭头运算符必须是类的成员，解引用运算符通常也是类的成员**，尽管并非如此。

  ```c++
  class StrBlobPtr
  {
      public:
      std::string& operator*()const
      {
          auot p = check(curr,"dereference past end");
          return (*p)[curr];//(*p)是对象所指的vector
      }
      std::string* operator->()const
      {
          //将实际工作委托给解引用运算符
          return &this->operator*();
      }
  }
  ```

- 和大多数其他运算符一样(尽管这么做不太好)，我们能令`operator*`**完成任何我们指定的操作**。换句话说，我们可以让` operator*`返回一个固定值`42`，或者打印对象的内容，或者其他。**箭头运算符则**不是这样，**它永远==不能丢掉成员访问这个最基本的含义==**。当我们重载箭头时，可以改变的是箭头从哪个对象当中获取成员，而箭头获取成员这一事实则永远不变。

- 对于形如`point->mem`的表达式来说,`point`必须**是指向类对象的指针或者是一个重载了operator->的类的对象**。根据`point`类型的不同，`point->mem`分别等价于

  - `(*point).mem`;				//point是一个内置的指针类型
  - `point.operator()->mem`;       //point是类的一个对象

- 除此之外，代码都将发生错误。`point->mem` 的执行过程如下所示:

  - 如果**`point`是指针,**则我们**应用内置的箭头运算符**,表达式等价于`(*point).mem`首先解引用该指针，然后从所得的对象中获取指定的成员。**如果`point`所指的类型没有名为`mem`的成员，程序会发生错误**。
  - 如果**`point`是定义了`operator->`的类的一个对象**,则我们使用`point.operator->()` 的结果来获取`mem`。其中，如果该结果是一个指针，则执行第1步;如果该结果本身含有重载的 `operator->()`，则重复调用当前步骤。最终，当这一过程结束时程序或者返回了所需的内容，或者返回一些表示程序错误的信息。

#### 函数调用运算符

1. 如果**类重载了函数调用运算符，则我们可以像使用函数一样使用==该类的对象==**。因为这样的类同时也能存储状态，所以**与普通函数相比它们更加灵活**。

   ```c++
   struct absInt
   {
       int operator()(int val)const
       {
           return val < 0 ? -val:val;
       }
   };
   int i = -42;
   absInt  absObj;		//含有函数调用运算符的对象
   int ui = absObj(i);	//将i传递给obsobj.operator();
   ```

   - 函数调用运算符必须是成员函数。**一个类可以定义多个不同版本的调用运算符**。**相互之间应该在==参数数量或类型上有所区别==。**
   - 如果**类定义了调用运算符**，则**该类的对象称作函数对象**( function object)。因为可以调用这种对象，所以我们说这些对象的“行为像函数一样”。

   ```c++
   class PrintString
   {
       public:
       PrintString(ostream&os= cout,char c = ' '):os(o),sep(c){}
       void operator()(const string&s)const{os<<s<<sep;}
       private:
       ostream &os;		//用于写入的目的流
       char sep;			//用于将不同输出隔开的字符
   }
   PrintString printer;		//使用默认值，打印到cout
   printer(s);
   PrintString errors(cerr,'\n');
   errors(s);					//在cerr中打印s，后面根一个换行符
   ```

   - 函数对象类通常含有一些数据成员，这些成员被用于**==定制==调用运算符中的操作**。且常常作为泛型算法的实参。

2. Lambda是函数对象

   - 编译器将该表达式翻译成一个未命名类的未命名对象，在lambda表达式产生的类中含有一个重载的函数调用运算符。

   ```c++
   //根据单词的长度对其进行排序，对于长度相同的单词按照字母表顺序排序
   stable_sort(words.begin(),words.end(),
               [](const string &a,const string &b)
               {return a.size()<b.size();});
   //其行为类似于下面这个类的一个未命名对象
   class ShorterString
   {
       public:
       bool operator()(const string &s1,const string &s2)const
       {
           return s1.size()<s2.size();
       }
   }
   ```

   - **==默认情况下`lambda`不能改变它捕获的变量==。因此在默认情况下，由`lambda`产生的==类当中的函数调用运算符是一个`const`成员函数==。如果 `lambda`被声明为可变的，则调用运算符就不是`const` 的了。**
   - **当一个`lambda`表达式通过引用捕获变量时，将由程序负责确保 lam执行时引用所引的对象确实存在**。因此，**编译器可以直接使用该引用而无须在lambda 产生的类中将其存储为数据成员**。
   - 相反，**通过值捕获的变量被拷贝到`lambda`中**。因此，**这种lambda 产生的类必须为每个值捕获的变量==建立对应的数据成员==**，同**时创建构造函数**,令**其==使用捕获的变量的值来初始化数据成员==**。

   ```c++
   auto wc = find_if(words.begin(),words.end(),
                     [sz](const string &a)
                     		{return a.size()>=sz;});
   //该lambda表达式产生的类
   class SizeComp()
   {
       public:
       SizeComp(size_t n):sz(n){}
       bool operator()(const string &s)cosnt
       {
           return s.size()>=sz;
       }
       private:
       size_t sz;
   }
   ```

   - **`lambda`表达式产生的类==不含默认构造函数、赋值运算符及默认析构函数==;它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定**（参见13.1.6节，第 450页和13.6.2节.第475)

3. 标准库定义的函数调用对象 `<functional>`

   <img style="width: 1000px;height:300px" src="Image\标准库函数对象.png">

   - **标准库规定其函数对象对于指针同样适用**。我们之前曾经介绍过==**比较两个无关指针将产生未定义的行为**==(参见3.5.3节，第107页)，然而我们可能会希望通过比较指针的内存地址来`sort` 指针的`vector`。直接这么做将产生未定义的行为因此我们可以使用一个标准库函数对象来实现该目的:

     ```c++
     
     
     vector<string*> nameTable;
     
     //错误:nameTable中的指针彼此之间没有关系，所以<将产生未定义的行为
     sort(nameTable.begin(),bameTbale.end(),
         	[](string*a,string*b){return a<b});
     
     //正确:标准库规定指针的less是定义良好的
     sort(nameTable.begin(), nameTable.end(), less<string*>() ); //对指针的值进行排序
     										//即使指针彼此之间不在同一数组内，也可以进行比较而不会导致未定义行为
     
     ```

   - **==关联容器使用less<key_type>对元素排序==**

4. 可调用对象与`function`

   - C++语言中有几种可调用的对象:**函数**、**函数指针**、**`lambda`表达式**、**bind创建的对象**以及**重载了函数调用运算符的类**。和其他对象一样，**可调用的对象也有类型**。例如，每个lambda有它自己唯一的（未命名）类类型;函数及函数指针的类型则由其返回值类型和实参类型决定，等等。
   
     ```c++
     //普通函数
     int add(int i,int j) {return i+j;}
     //lambda
     auto mod =[](int j,int j){return i%j;}
     //函数对象类
     struct divide
     {
         int operator()(int demoinator,int divisor)
         {
             return demoinator / divisor;
         }
     }
     
     //构建从运算符到函数指针的映射关系，其中函数接受两个int、返回一个int
     map<string, int (*）(int,int) > binops;
     binops.insert({ "+", add});				//正确:add是一个指向正确类型函数的指针
     binops.insert({"%",mod}); 				//错误：mod不是一个函数指针
     ```
   
     - 这些可调用对象分别对其参数执行了不同的算术运算，**尽管他们类型各不相同，但是==共享同一种调用形式==`int (int ,int)`**
   
   - 标准库`function`类型
   
     - 我们可以使用一个名为`function`的新的标准库类型解决上述问题，`function`定义在`functional`头文件中。
   
       <img style="width: 1000px;height:400px" src="Image\function.png">
   
     - `function`是一个模板，和我们使用过的其他模板一样，当创建一个具体的`function`类型时我们必须提供额外的信息。在此例中，所谓**额外的信息是指该`function`==类型能够表示的对象的调用形式==**。
   
     ```c++
     map<string,function<int (int,int)>> binops = 
     {
     	{"+",add},					//函数指针
     	{"-",std: :minus<int> () },	//标准库函数对象
     	{"/",divide ( ) },			//用户定义的函数对象
     	{"*",[](int i, int j) { return i * j; }}, //未命名的 lambda
     	{"%",mod}					//命名了的lambda对象
     };
     ```
   
     - ==**我们不能（直接）将重载函数的名字存入`function`类型的对象中**==
   
     ```c++
     int add(int i, int j){ return i +j;}
     sales_data add (const sales_data&,const Sales_data&);
     
     binops.insert( { "+", add}); //错误:哪个add?
     
     int (*fp) (int, int) = add;	//指针所指的add是接受两个int的版本
     binops.insert ({"+",fp});//正确:fp指向一个正确的add 版本
     
     //正确:使用lambda来指定我们希望使用的add版本
     binops.insert( { "+"，[](int a, int b)(return add (a， b);} });
     
     ```
   
     - 新版本标准库中的`function`类与旧版本中的`unary function`和`binary function`没有关联,后两个类已经被更通用的`bind`函数替代了。

#### 重载、类型转换与运算

1. 类型转换运算符

   - **由一个实参调用的==非显式==构造函数定义了一种隐式的类型转换**，这种构造函数将**==实参类型的对象转换成类类型==**。我们同样能定义对于类类型的类型转换，通过定义**类型转换运算符**可以做到这一点。==**转换构造函数**==和==**类型转换运算符**==共同定义了类类型转换（class-type conversions)，这样的转换有时也被称作用户定义的类型转换（user-defined conversions)。
   - **类型转换函数的一般形式**:`operator type() const;`
     - **其中 `type`表示某种类型**。**==类型转换运算符可以面向任意类型(==除了`void`之外)进行定义，只要该类型能作为函数的返回类型**(参见6.1节，第184页)。因此，我们不允许转换成数组或者函数类型，但允许转换成指针（包括数组指针及函数指针）或者引用类型。**类型转换运算符既没有显式的返回类型,也没有形参，而且必须定义成类的成员函数**。类型转换运算符通常不应该改变待转换对象的内容，因此，类型转换运算符一般被定义成`const`成员。

   ```c++
   class SmallInt
   {
     public:
       SmallInt(int i = 0):val(i) //向类类型的转换
       {
           if(i<0||i>255)
               throw std::out_of_range("Bad SmallInt value");
       }
       operator int()const {return val;}//向int类型的转换
   };
   SmallInt si;
   si = 4;//首先将4隐式地转换成SmallInt，然后调用SmallInt::operator=
   si + 3;//首先将si隐式地转换成int，然后执行整数的加法
   ```

   - 尽管**编译器一次只能执行一个用户定义的类型转换**（参见4.11.2节，第144页)，**但是隐式的用户定义类型转换可以置于一个标准(内置)类型转换==之前或之后==**（参见4.11.1节，第141页)，**并与其一起使用**。因此，我们可以将任何算术类型传递给`SmallInt`构造函数。类似的，我们也能使用类型转换运算符将一个`SmallInt`对象转换成士t然后再将所得的`int`转换成任何其他算术类型。

   ```c++
   //内置类型转换将double实参转换成int
   SmallInt si = 3.14;		//调用SmallInt (int)构造函数
   
   //SmallInt的类型转换运算符将si转换成int
   si + 3.14;				//内置类型转换将所得的int继续转换成double
   ```

   - **因为类型转换运算符是隐式执行的，所以无法给这些函数传递实参**，当然也就不能在类型转换运算符的定义中使用任何形参。同时，**尽管类型转换函数不负责指定返回类型，但实际上每个类型转换函数都会返回一个对应类型的值**。
     - `operator int*()const{return 42;}`	//错误：42不是一个指针

   - ==**显示的类型转换运算符**==

     - 在实践中，类很少提供类型转换运算符。在大多数情况下，如果类型转换自动发生,用户可能会感觉比较意外,而不是感觉受到了帮助。然而这条经验法则存在一种例外情况:**对于类来说，定义向`bool`的类型转换还是==比较普遍的现象==**。

     - 在C++标准的早期版本中，**如果类想定义一个向`bool`的类型转换，则它常常**遇个问题：**因为`bool`是一种算术类型**，**所以类类型的对象转换成`bool`后就能被用在任何需要算术类型的上下文中**。这样的类型转换可能引发意想不到的结果，特别是当`istream`含有向`bool`的类型转换时，下面的代码仍将编译通过:

       ```c++
       int i = 42;
       cin << i; 		//如果向bool的类型转换不是显式的，则该代码在编译器看来将是合法的!
       				//cin 转换为bool，bool提升为int
       class SmallInt
       {
           public:
           //编译器不会执行这一类型转换
           explicit operator int() const {return val;}
       };
       
       SmallInt si = 3;			//正确:SmallInt的构造函数不是显式的
       si + 3;						//错误:此处需要隐式的类型转换，但类的运算符是显式的
       static_cast<int>(si) +3; 	//正确:显式地请求类型转换
       ```

     - ==**该规定存在一个例外，即如果表达式被用作条件,则编译器会将显式的类型转换自动应用于它。换句话说，当表达式出现在下列位置时，显式的类型转换将被隐式地执行**:==

       - `if`、 `while`及`do`语句的条件部分
       - `for`语句头的条件表达式
       - 逻辑非运算符（!)、逻辑或运算符（)、逻辑与运算符（&&）的运算对象条件运算符
       - （?:）的条件表达式。

     - ==**向`bool`的类型转换通常用在条件部分，因此`operator bool`一般定义成`explicit`的。**==

   - ==**避免有二义性的类型转换**==

     - 如果**类中包含==一个或多个类型转换==，则必须确保在类类型和目标类型之间只存在==唯一一种转换方式==**。**否则的话，我们编写的代码将很可能会具有二义性**。在两种情况下可能产生多重转换路径。

       - 第一种情况是**两个类提供相同的类型转换**:例如，当**A类定义了一个接受B类对象**的转换构造函数，同时**B类定义了一个转换目标是A类**的类型转换运算符时，我们就说它们提供了相同的类型转换。
       - 第二种情况是类定义了多个转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。最典型的例子是算术运算符，==**对某个给定的类来说，最好只定义最多一个与算术类型有关的转换规则**==。

       ```c++
       struct B;
       struct A
       {
       	A() = default;
       	A(const B&);		//把一个B转换成A
       };
       struct B
       {
       	operator A()const; //把一个B转换成A
       };
       A f(const A&);
       B b;
       A a = f(b);		//二义性错误：含义是f(B::operator A())
       				//还是f(A::A(const B&))
       A a1 = f(b.operator A());	//正确:使用B的类型转换运算符
       A a2 = f(A(b));				//正确:使用A的构造函数
       ```

       - **我们无法使用强制类型转换来解决二义性问题，因为==强制类型转换本身也面临二义性。==**

     - **另外如果类定义了一组类型转换，==它们的转换源（或者转换目标）类型本身可以通过其他类型转换联系在一起==，则同样会产生二义性的问题。最简单也是最困扰我们的例子就是类当中定义了多个参数都是算术类型的构造函数，或者转换目标都是算术类型的类型转换运算符。**

       ```c++
       struct A
       {
           A(int = 0);				//最好不要创建两个转换源都是算术类型的类型转换
           A(double);
           operator int()const;
           operator double() const;
       }；
       void f2(long double);
       A a;
       f2(a);		//二义性错误:含义是f(A::operator int ())
       			//还是f(A::operator double())?
       long lg;
       A a2(lg);	//1二义性错误:含义是A::A(int)还是A::A (double) ?
       ```

       - 调用`f2`及初始化 `a2`的过程之所以会产生二义性，根本原因是它们所需的标准类型转换级别一致(参见6.6.1节，第219页)。当我们使用用户定义的类型转换时，如果转换过程包含标准类型转换,则**标准类型转换的级别**将决定编译器选择最佳匹配的过程:

         ```c++
         short s = 42;//把short提升成int优于把short转换成double
         A a3(s);	//使用A::A(int)
         ```

       - 在此例中，把`short`提升成`int` 的操作要优于把`short`转换成`double` 的操作，因此编译器将使用`A: :A (int)`构造函数构造`a3`，其中实参是`s` (提升后）的值。
       - **当我们使用两个用户定义的类型转换时，如果==转换函数之前或之后存在标准类型转换,==则==标准类型转换==将决定最佳匹配到底是哪个。**

     - 要想正确地设计类的**重载运算符、转换构造函数及类型转换函数**，必须加倍小心。尤其是当类同时定义了类型转换运算符及重载运算符时特别容易产生二义性。

       - ==**不要令两个类执行相同的类型转换:**==如果Foo类有一个接受Bar类对象的构造函数,则不要在 Bar类中再定义转换目标是Foo类的类型转换运算符。
       - **避免转换目标是内置算术类型的类型转换**。特别是当你**已经定义了一个转换成算术类型的类型转换时**,接下来
         - **不要再定义接受==算术==类型的重载运算符**。如果用户需要使用这样的运算符则类型转换操作将转换你的类型的对象,然后使用内置的运算符。
         - **不要定义转换到多种算术类型的类型转换**。让标准类型转换完成向其他算术类型转换的工作。
       - 一言以蔽之:**除了显式地向bool类型的转换之外，我们应该尽量避免定义类型转换函数并尽可能地限制那些“显然正确”的非显式构造函数**。

   - ==**函数重载与转换构造函数**==

     - 当我们**调用重载的函数时**,**从多个类型转换中进行选择将变得更加复杂**。==**如果两个或多个类型转换都提供了同一种可行匹配，则这些类型转换一样好**==

       ```c++
       struct C
       {
         C(int);  
       };
       struct D
       {
          D(int);
       };
       void manip(const C&);
       void manip(const D&);
       manip (10);			//二义性错误:含义是manip(C(10))还是manip(D(10))
       					//manip(C(10))显式地构造正确的类型从而消除二义性:
       ```

     - **当==调用重载函数时==，如果==两个(或多个)用户定义==的类型转换都提供了可行匹配,我们认为这些类型转换一样好,==在这个过程中，我们不会考虑任何可能出现的标准类型转换的级别==**

   - ==**函数匹配与重载运算符**==

     - **重载的运算符也是重载的函数**。因此，**通用的函数匹配规则同样适用于判断在给定的表达式中到底应该使用内置运算符还是重载的运算符**。
     - 当我们使用**重载运算符作用于==类类型==的运算对象时**，**候选函数中==包含==该运算符的==普通非成员版本==和==内置版本==**,除此之外，如果左侧运算对象是类类型，则定义在该类中的运算符的重载版本也包含在候选函数内。
     - 当我们调用一个**命名的函数时**，具有该名字的**成员**函数和**非成员**函数**不会彼此重载**，这是**因为我们用来调用==命名函数的语法形式对于成员函数和非成员函数来说是不相同的==**。当我们通过**类类型的==对象(或者该对象的指针及引用==）进行函数调用时**，**只考虑该类的==成员函数==**。而当我们**在表达式中使用重载的运算符时，无法判断正在使用的是成员函数还是非成员函数**，因此二者都应该在考虑的范围内。

     ```c++
     class SmallInt 
     {
     	friend SmallInt operator+(const SmallInt&, const SmallInt&) ;
     public:
         
     	SmallInt (int = 0);					//转换源为int的类型转换
     	operator int () const{ return val; }//转换目标为int的类型转换
     private:
     	std: :size_t val;
     };
     SmallInt s1,s2;
     SmallInt s3 = s1 +s2;		//使用重载的operator+
     int i = s3 + 0；				//二义性错误
     ```

### 面向对象程序设计

#### OOP：概述

1. 继承

   - 通过**继承**（inheritance）联系在一起的类构成一种层次关系。通常在层次关系的根部有一个**基类**（base class)，**其他类则直接或间接地从基类继承而来**，这些继承得到的类称为**派生类**(derived class)。**基类负责定义在层次关系中所有类==共同拥有==的成员，而每个派生类定义==各自特有==的成员**。

   - 基类将**类型相关的函数与派生类不做改变直接继承的函数区分对待**。对于某些函数，基**类希望它的==派生类各自定义适合自身的版本==,此时基类就==将这些函数声明成虚函数==**( virtual function)。
   - **派生类必须在其内部对所有重新定义的虚函数进行声明。==派生类可以在这样的函数之前加上virtual关键字，但是并不是非得这么做==**。出于15.3节(第538页)将要解释的原因，**C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数**，具体措施是在该函数的形参列表之后增加一个 `override`关键字。


```c++
class Quote
{
    public:
    std::string isbn()const;
    virtual double net_price(std::size_t n) const;
};
// 派生类必须通过使用类派生列表，明确指出它是从哪个（哪些）基类继承而来的
class Bulk_quote : public Quote
{
    public:
    double net_price(std::size_t ) const override;
}
```

2. 动态绑定

   - **当我们使用基类的引用(或指针)调用一个虚函数时将发生动态绑定。**

   - ==**基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此**==。

#### 定义基类和派生类

1. 定义基类

   - 成员函数与继承

     - 基类必须将它的**两种成员函数区分开来**:一种是**基类希望其派生类进行覆盖的函数;另一种是基类希望派生类直接继承而不要改变的函数**。对于前者，基类通常将其定义为虚函数(virtual)。当我们使用指针或引用调用虚函数时，该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。

     - 基类通过在其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定。**任何构造函数之外的非静态函数都可以是虚函数**。**关键字`virtual`==只能出现在类内部的声明语句之前==而不能用于类外部的函数定义**。**如果基类把一个函数声明成虚函数，则==该函数在派生类中隐式地也是虚函数==**。

   - 访问控制与继承

     - 派生类可以继承定义在基类中的成员，**但是派生类的成员函数不一定有权访问从基类继承而来的成员**。和其他使用基类的代码一样，**派生类能访问公有成员，而不能访问私有成员**。**基类希望它的==派生类有权访问==该成员同时禁止其他用户访问**。我们用**受保护的（protected）访问运算符说明这样的成员**。

2. 定义派生类

   - ==**类派生列表**==的形式是:首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个: public、protected或者private。

   - 派生类中的虚函数

     - **如果==派生类没有覆盖其基类中的某个虚函数==,则该虚函数的行为类似于其他的普通成员,派生类会直接继承其在基类中的版本**。

   - 派生类对象及派生类向基类的类型转换

     - **一个派生类对象包含多个组成部分**:**一个含有派生类自己定义的（非静态）成员的子对象**，**以及一个与该派生类继承的基类对应的子对象**，**如果有多个基类，那么这样的子对象也有多个**。

       <img style="width: 1000px;height:500px" src="Image\继承.png">

     - **因为在==派生类对象中含有与其基类对应的组成部分==，所以我们能把派生类的对象当成基类对象来使用，而且我们也能==将基类的指针或引用==绑定到派生类对象中的==基类部分==**

       ```c++
       Quote item;				//基类对象
       Bulk_quote bulk;		//派生类对象
       Quote *p = &item;		//p指向Quote对象
       p = &bulk;				//p指向bulk的 Quote部分
       Quote &r = bulk;		//r绑定到bulk的 Quote部分
       ```

   - 派生类构造函数

     - **尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，==派生类也必须使用基类的构造函数==来初始化它的基类部分**

     ```c++
     Bulk_quote(const std::string &book,double p,std::string qty,double disc):
     			Quote(book,p),min_qty(qty),discount(disc){}
     ```

     - **除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化如果想使用其他的基类构造函数，我们需要以类名加圆括号内的实参列表的形式为构造数提供初始值**。这些实参将帮助编译器决定到底应该选用哪个构造函数来初始化派生类对象的基类部分。
       - 必须明确一点:每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。因此，**派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做**。和使用基类的其他场合一样，派生类应该遵循基类的接口,并且通过调用基类的构造函数来初始化那此从基类中继承而来的成员。

   - 继承与静态成员

     - 如果基类定义了一个==**静态成员**==，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于**每个静态成员来说都只存在唯一的实例**。

       - **静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它**。

       ```c++
       class Base
       {
       public:
       	static void statmem()	{}
       };
       class Derived :public Base
       {
       	void f(const Derived&);
       };
       void Derived::f(const Derived& derived_obj)
       {
       	Base::statmem();		
       	Derived::statmem();
       
       	derived_obj.statmem();
       	statmem();
       }
       class Bulk_quote : public Quote;	//错误：派生列表不能出现在这里
       class Bulk_quote;					//正确：声明派生类的正确方式
       ```

   - 被用作基类的类

     - **某个类用作基类，则该类必须已经定义而非仅仅声明**。这一规定的原因显而易见:**派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么**。因此该规定还有一层隐含的意思，即一个类不能派生它本身。

       ```c++
       class Base{/*............*/}
       class D1:public Base{/*............*/}
       class D2:public D1{/*............*/}
       //Base是D1的直接基类，同时是D2的间接基类
       //每个类都会继承直接基类的所有成员。对于一个最终的派生类来说，它会继承其直接基类的成员;该直接基类的成员又含有其基类的成员;依此类推直至继承链的顶端。
       
       //C++11 我们不希望其它类继承它	
       class NoDerived final : public Base{/*............*/}
       ```

3. 类型转换与继承

   - 静态类型与动态类型
     - **表达式的==静态类型==在编译时总是已知的,，它==是变量声明时的类型或表达式生成的类型==;==动态类型==则是==变量或表达式表示的内存中的对象的类型==。动态类型直到运行时才可知**。

   - **不存在从基类向派生类的隐式类型转换**

     - ==**之所以存在派生类向基类的类型转换是因为每个派生类对象都包含一个基类部分**==，而基类的引用或指针可以绑定到该基类部分上。一个基类的对象既可以以独立的形式存在,也可以作为派生类对象的一部分存在。

       ```c++
       Quote base;
       Bulk_quote* bulkP = &base;		//错误：不能将基类转换成派生类
       Bulk_quote& bulkRef = base;		//错误：不能将基类转换成派生类
       //如果上述赋值是合法的，则我们有可能会使用bulkP或bulkRef访问base 中本不存在的成员。
       ```

       - 即使**一个基类指针或引用绑定在一个==派生类对象上==，我们==也不能执行从基类向派生类的转换==**。
       - **编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。如果在基类中含有一个或多个虚函数，我们可以使用==dynamic_cast== 请求一个类型转换，==该转换的安全检查将在运行时执行==。同样，==如果我们已知某个基类向派生类的转换是安全的则我们可以使用static_cast==来强制覆盖掉编译器的检查工作。**

   - 当我们**初始化**或**赋值一个类类型的对象时**，**实际上是在调用某个函数**。当执行初始化时，我们调用构造函数;而当执行赋值操作时，我们调用赋值运算符。这**些成员通常都包含一个参数，该参数的类型是类类型的const版本的引用**。

   - **因为这些成员接受引用作为参数**，所以派生类向基类的转换允许我们给**基类的拷贝/移动操作**传递一个**派生类的对象**,这些操作不是虚函数。**当我们给==基类的构造函数传递个派生类对象时==，实际运行的构造函数是基类中定义的那个，显然该构造函数只能处理基类自己的成员**。类似的，如果我们将一个派生类对象赋值给一个基类对象，则实际运行的赋值运算符也是基类中定义的那个，该运算符同样只能处理基类自己的成员。

     ```c++
     Bulk_quote bulk;		//派生类对象
     Quote item(bulk);		//使用Quote::Quote(const Quote&)构造函数
     item = bulk				//调用Quote::operator=(const Quote&);
     ```

     - 当构造`item`时，运行`Quote`的拷贝构造函数。该函数只能处理`bookNo`和`price`两个成员，它负责拷贝`bulk` 中 `Quote`部分的成员，同时忽略掉`bulk `中 `Bulk_quote`部分的成员。类似的，对于将 `bulk`赋值给`item` 的操作来说，只有`bulk` 中 `Quote`部分的成员被赋值给`item`。

   - 关键概念
     - 要想理解在具有**继承关系的类之间发生的类型转换**，有三点非常重要:
       - 从派生类向基类的类型转换只对指针或引用类型有效。
       - 基类向派生类不存在隐式类型转换。
       - 和任何其他成员一样,派生类向基类的类型转换也可能会由于访问受限而变得不可行。我们将在15.5节(第544页)详细介绍可访问性的问题。
       - 尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然(显式或隐式地)定义了考贝控制成员(参见第13章)。因此,我们通常能够将一个派生类对象措贝、移动或赋值给一个基类对象。不过需要注意的是，这种操作只处理派生类对象的基类部分。

#### 虚函数

1. 对虚函数的调用可能在运行时才被解析

   - 通常情况下，如果我们不使用某个函数,则无须为该函数提供定义(参见6.1.2节，第186页)。但是**我们必须为每一个虚函数都提供定义**，而不管它是否被用到了，这是因为连编译器也无法确定到底会使用哪个虚函数
   - 当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与**绑定到指针或引用上的对象的==动态类型相匹配的那一个==**。
   - **当我们通过一个具有普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来**。

2. 派生类中的虚函数

   - 当我们在派生类中覆盖了某个虚函数时，可以再一次使用`virtual`关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。
   - 一个派生类的函数如果覆盖了某个继承而来的虚函数则它的形参类型必须与被它覆益的基类函数完全一致
     - **例外**：**类的虚函数返回类型是类本身的指针或引用时，上述规则无效**。也就是说，如果D由B派生得到，则基**类的虚函数可以返回**`B*`而**派生类的对应函数可以返回**`D*`，只不过这样的返回类型要求从D到B的类型转换是可访问的。

3. final和override说明符

   - 在C++11 新标准中我们可以使用`override`**关键字来说明派生类中的虚函数**。**这么做的好处是在使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误**，后者在编程实践中显得更加重要。**如果我们使用`override`标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错**;
   - 我们还能把某个函数指定为 `final`，**如果我们已经把函数定义成`final`了，则之后任何尝试覆盖该函数的操作都将引发错误:**
   - ==**`final`和`override`说明符出现在`const`或引用限定符及尾置返回类型之后**==

4. 虚函数与默认实参

   - 如果我们通过**基类的引用或指针调用函数**,则**使用基类中定义的默认实参即使实际运行的是派生类中的函数版本也是如此**。此时，==**传入派生类函数的将是基类函数定义的默认实参**==。如果派生类函数依赖不同的实参，则程序结果将与我们的预期不符。

5. 回避虚函数的机制

   - 我们希望**对虚函数的调用==不要进行动态绑定==，而是强迫其执行虚函数的某个特定版本**。使用作用域运算符可以实现这一目的。

     ```c++
     //强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么
     double undiscounted = baseP->Quote::net_price (42);
     ```

   - 只有成员函数(或友元)中的代码才需要使用作用域回避虚函数的机制

     - 什么时候我们需要回避虚函数的默认机制呢？通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时。在此情况下，基类的版本通常完成继承层次中所有类型都要做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切相关的操作。
     - **如果一个派生类虚函数需要调用它的基类版本,但是没有使用作用域运算符,则在运行时该调用将被解析为对派生类版本自身的调用,从而导致无限递归**。

#### 抽象基类

- **纯虚函数**

  - 纯虚函数无需定义，我们通过在函数体的位置书写`=0`，就可以将一个虚函数说明为纯虚函数。`=0`**只能出现在类内部的虚函数声明语句处**。
  - **我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部**也就是说，我们不能在类的内部为一个`=0`的函数提供函数体。

  ```c++
  class Disc_quote:public Quote
  {
      public:
      
      double net_price(std::size_t)const = 0;
  }
  ```

  

- 含有纯虚函数的类是抽象基类

  - ==**含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类**==( abstract base class)。抽象基类负责定义接口,而后续的其他类可以覆盖该接口。**我们不能（直接）创建一个抽象基类的对象**。
  - ==**`Disc_quote`的派生类必须给出自己的`net_price`定义，否则他们仍将是抽象基类**==。

#### 访问控制与继承

1. 受保护的成员

   - `protected`关键字声明哪些**它希望与==派生类分享==但是不想被其它公共访问使用的成员**。
     - 和私有成员类似，**受保护的成员对于类的用户来说是不可访问的**。
     - 和公有成员类似，**受保护的成员对于派生类的成员和友元来说是可访问的**。
       - **==派生类的成员或友元只能通过派生类对象来访问基类的受保护成员==。派生类对于个基类对象中的受保护成员没有任何访问特权。**

2. 公有，私有和受保护继承

   ```c++
   class Base
   {
       public:
       void pub_mem();
       private:
       int prot_mem();
       private:
       char priv_mem;
   }
   struct Pub_Derv :public Base
   {
       //派生类能访问protected成员
       int f(){return prot_mem;}
       //private成员对应派生类来说是不可访问的
       char g() {return priv_mem;}
   }
   struct Priv_Derv:private Base
   {
       //private不影响派生类的访问权限
       int f1()const{return prot_mem;}
   }
   ```

   - **派生访问说明符的目的是==控制派生类用户(包括派生类的派生类在内)==对于基类成员的访问权限**。

     ```c++
     Pub_Derv dl;//继承自 Base的成员是public的
     Priv_Derv d2;//继承自 Base的成员是private的
     
     dl.pub_mem();//正确: pub_mem在派生类中是public的
     d2.pub_mem () ;//错误:pub _mem在派生类中是private的
     ```

     

3. **派生类向基类转换的可访问性**

   - **派生类向基类**的转换是否可访问由使用**该转换的代码**决定，同时派生类的**派生访问说明符**也会有影响。假定**D继承自B**:

     - 只有**==当D公有地继承B时==**，==用户代码==才**能使用派生类向基类的转换**;如果D继承B的方式是==**受保护的或者私有的**==，则用户代码不能使用该转换。

     - 不论D以什么方式继承B，**D的==成员函数和友元==都能使用派生类向基类的转换**;**派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的**。

     - **如果D继承B的方式是公有的或者受保护的**，**则D的==*派生类*的成员和友元==可以使用D向B的类型转换**;反之，如果D继承B的方式是私有的，则不能使用。

   - **基类**应该将其接口成员声明为公有的，同时将属于其实现的部分分成两组：一组可供派生类访问，另一组只能由基类及基类的友元访问。

4. 友元与继承

   - **友元关系同样也不能继承基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员**

   ```c++
   class Pal;
   class Base
   {
   	friend class Pal;
   public:
   	void pub_mem();
   protected:
   	int prot_mem;
   private:
   	char priv_mem;
   };
   class Sneaky :public Base	{int j;};
   class Pal
   {
   public:
   	int f(Base b) { return b.prot_mem; };//Pal是Base的友元
   
   	//对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此
   	int f3(Sneaky s) { return s.prot_mem; }		//Pal是Base的友元
   
   };
   class D2 :public Pal
   {
   public:
   	int mem(Base b) { return b.prot_mem; }//友元关系无法继承
   };
   ```

5. 改变个别成员的可访问性

   ```c++
   class Base
   {
       public:
       std::size_t size()const{return n;}
       protected:
       std::size_t n;
   };
   class Derived :private Base		//private继承
   {
       public:
       using Base::size;
       
       protected:
       using Base::n;
   }
   ```

   - 因为 `Derived`使用了私有继承，所以继承而来的成员`size`和`n`（在默认情况下）是`Derived`的私有成员。然而，我们使用`using`声明语句改变了这些成员的可访问性。改变之后，`Derived`的用户将可以使用`size`成员，而 `Derived` 的派生类将能使用`n`.
   - 通过在类的内部使用`using`声明语句，我们可以将该类的**直接或间接基类中的==任何可访问成员==**(例如,非私有成员()标记出来。**`using`声明语句中名字的访问权限由该`using`声明语句之前的访问说明符来决定**。也就是说，如果一条 `using`声明语句出现在类的`private`部分,则该名字只能被类的成员和友元访问;如果`using`声明语句位于`public`部分，则类的所有用户都能访问它;如果`using`声明语句位于`protected`部分，则该名字对于成员、友元和派生类是可访问的。

6. 默认的继承保护级别

   - 使用class关键字定义的派生类是私有继承的;而使用struct关键字定义的派生类是公有继承的:

#### 继承中的类作用域

1. **派生类的作用域嵌套在其基类的作用域之内。如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。**

2. 名字冲突与继承

   - 和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在**内层作用域(即派生类)的名字将隐藏定义在外层作用域(即基类)的名字**。

     ```C++
     struct Base
     {
     	Base():mem(0){}
         protected:
         int mem;
     };
     struct Derived:Base
     {
         Derived(int i):mem(i){}//Base::mem进行默认初始化
         int get_mem()		{return mem;}
         int get_base_mem()	{return Base::mem;}
         protected:
         int mem;			//隐藏基类中mem
     }
     
     ```

   - 作用域运算符将覆盖掉原有的查找规则,并指示编译器从`Base`类的作用域开始查找`mem`

   - 除了覆盖继承而来的虚函数之外，派生类最好不要重用其它定义在基类中的名字。

   - **假定我们调用`p->mem ()`或者`obj.mem()`,则依次执行以下4个步骤**:
     - 首先确定`p`(或 `obj`)的静态类型。因为我们调用的是一个成员，所以该类型必然是类类型。
     - 在`p`(或`obj`)的静态类型对应的类中查找`mem`。如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端。如果找遍了该类及其基类仍然找不到，则编译器将报错。
     - 一旦找到了`mem`，就进行常规的类型检查(参见6.1节,第183页)以确认对当前找到的`mem`，本次调用是否合法。
     - 假设调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码:
       - 如果`mem`是虚函数且我们是通过引用或指针进行的调用，则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本,依据是对象的动态类型。
       - 反之,如果`mem`不是虚函数或者我们是通过对象(而非引用或指针)进行调用，则编译器将产生一个常规函数调用。

3. 名字查找先于类型检查

   - **声明在内层作用域的函数并不会重载声明在外层作用域的函数**。因此，**定义派生类中的函数也不会重载其基类中的成员**。和其他作用域一样，如果派生类(即内层作用域）的成员与基类（即外层作用域）的某个**成员同名**,则派生类将在其作用域内隐藏该基类成员。即**使派生类成员和基类成员的形参列表不一致，基类成员也仍然会被隐藏掉**。

     ```c++
     struct Base
     {
         int memfcn();
     }
     struct Derived : Base
     {
         int memfcn(int);		//隐藏基类的memfcn
     }
     Derived d; Base b;
     b.memfcn();		//调用Base::memfcn
     d.memfcn(10);	//调用Derived::memfcn
     d.memfcn();		//错误：参数列表为空的memfcn被隐藏了
     d.Base::memfcn();    
     ```

   - 为了解析这条调用语句，**编译器首先在 `Derived`中查找名字`memfcn`;因为 `Derived`确实定义了一个名为`memfcn` 的成员，所以查找过程终止。一旦名字找到，编译器就不再继续查找了。`Derived`中的`memfcn`版本需要一个`int`实参，而当前的调用语句无法提供任何实参，所以该调用语句是错误的。**

4. 虚函数与作用域

   ```c++
   class Base
   {
       public:
       virtual int fcn();
   };
   class D1 :public Base
   {
       public:
       //隐藏基类的fcn，这个fcn不是虚函数
       //D1继承了Base::fcn()的定义
       int fcn(int);		//形参列表与Base中的fcn不一致
       virtual void f2();	//新的虚函数
   };
   class D2:public D1
   {
       public:
       int fcn(int);		//隐藏了D1::fcn(int);
       int fcn();			//覆盖了Base的虚函数fcn
       void f2();			//覆盖了D1的虚函数f2
   }
   ```

5. 覆盖重载的函数

   ```c++
   class Base 
   {
   public:
       virtual void func(int x) { std::cout << "Base::func(int)" << std::endl; }
       virtual void func(double x) { std::cout << "Base::func(double)" << std::endl; }
   };
   
   class Derived : public Base 
   {
   public:
       // 派生类定义了一个新的 func 重载版本
       //using Base::func	// ✔️引入基类所有 func 重载版本
       void func(const char* s) 
       { std::cout << "Derived::func(const char*)" << std::endl;} 
       /*
       	void func(int x) override 
       	{ 	 // 选择性覆盖基类的 func(int)
          		 std::cout << "Derived::func(int)" << std::endl;
      		}
       */
   };
   
   int main() {
       Derived d;
       d.func(42);       // ❌ 错误：Base::func(int) 被隐藏
       d.func(3.14);     // ❌ 错误：Base::func(double) 被隐藏
       d.func("hello");  // ✔️ 正确：调用 Derived::func(const char*)
       return 0;
   }
   ```

   - 和其他函数一样，**成员函数无论是否是虚函数都能被重载**。派生类可以覆盖重载函数的0个或多个实例。**如果派生类希望所有的重载版本对于它来说都是可见的，那么它就需要==覆盖所有的版本==,==或者一个也不覆盖==**。

#### 构造函数与拷贝控制

1. 虚析构函数

   - 当我们`delete`一个动态分配的对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。例如,如果我们`delete`一个 `Quote*`类型的指针，则该指针有可能实际指向了一个 `Bulk_quote`类型的对象。如果这样的话，编译器就必须清楚它应该执行的是`Bulk_quote `的析构函数。和其他函数一样，我们通过**在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本**

     ```c++
     class Quote
     {
         public:
         //如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数
         virtual ~Quote()=default;		//动态绑定虚析构函数
     }
     ```

   - 如果一个类定义了析构函数，即使它通过=default的形式使用了合成的版本,编译器也不会为这个类合成移动操作。

2. 合成的拷贝控制与继承

   - 基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似:它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，这些**合成的成员还负责==使用直接基类中对应的操作==对一个对象的直接基类部分进行初始化、赋值或销毁操作**。

3. 派生类中删除的拷贝控制与基类的关系

   - 就像其他任何类的情况一样，基类或派生类也能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员定义成被删除的函数。此外，某些定义基类的方式也可能导致有的派生类成员成为被删除的函数:

     - 如果基类中的**默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问**，则**派生类中==对应的成员==将是被删除的**，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作。
     - 如果在**==基类==中有一个==不可访问或删除掉的析构函数==**，**则派生类中合成的默认和拷贝构造函数将是被删除的**，因为编译器无法销毁派生类对象的基类部分。
     - 和过去一样，**编译器将不会合成一个删除掉的移动操作**。当我们使用=default请求一个移动操作时，如果**基类中的对应操作是删除的或不可访问的**，**那么派生类中该函数将是被删除的**，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。

     ```c++
     class B
     {
         public:
         B();
         B(const B&)=delete;
         //其它成员，不含有移动构造函数
     };
     class D:public B
     {
         //没有声明任何构造函数
         
     };
     D d;		//D的合成默认构造函数使用B的默认构造函数
     D d2(d);	//D的合成拷贝构造函数是被删除的
     D d3(std::move(d));
     ```

   - 基类`B`含有一个**可访问的默认构造函数和一个==显式删除==的拷贝构造函数**。**因为我们定义了拷贝构造函数,所以编译器将不会为B合成一个移动构造函数。因此，我们既不能移动也不能拷贝B的对象**。如果B的派生类希望他自己的对象能被移动和拷贝，则派生类需要自定义相应版本的构造函数，当然，在这一过程中派生类还必须考虑如何移动和拷贝其基类部分的成员。在实际编程过程中，如果在基类中没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作。

4. 移动操作与继承

   - **大多数基类都会定义一个虚析构函数。因此在默认情况下，基类通常不含有合成的移动操作**，而且在**它的派生类中也没有合成的移动操作。因为==基类缺少移动操作会阻止派生类拥有自己的合成移动操作==，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。我们的`Quote`可以使用合成的版本。**

5. 派生类的拷贝控制成员

   - 派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分。因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。
   - 析构函数只负责销毁与自己相关的资源

   ```c++
   class Base{/**/};
   class D:public Base
   {
     	public:
       //默认情况下，基类的默认构造函数初始化对象的基类部分
   	//要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中显式地调用该构造函数
   	D(const D& d): Base (d)	//拷贝基类成员
   				/* D的成员的初始值*/{/* ...*/}
       
   	D(D& & d): Base(std::move(d))//移动基类成员
   			/* D的成员的初始值*/{/* ...*/ }
   
   };
   ```

   - **初始值`Base(d)`将一个`D`对象传递给基类构造函数。尽管从道理上来说，`Base`可以包含一个参数类型为D的构造函数，但是在实际编程过程中通常不会这么做**。相反，**Base (d)一般会匹配Base的拷贝构造函数==D类型的对象d==将被==绑定到该构造函数的Base&形参上==**。**Base的拷贝构造函数负责将d的基类部分拷贝给要创建的对象**。==**假如我们没有提供基类的初始值的话**==:

   ```c++
   //D这个拷贝构造函数很可能是不正确的定义，基类部分被默认初始化，而非拷贝
   D(const D&d)//成员初始化，但是没有提供基类初始值
   		{}
   ```

   - 在上面的例子中，**==Base 的默认构造函数将被用来初始化D对象的基类部分==。假如D的构造函数从d中拷贝了派生类成员，则这个新构建的对象的配置将非常奇怪:它的Base成员被赋予了默认值，而D成员的值则是从其他对象拷贝得来的**。

6. 派生类赋值运算符

   - ==**与拷贝和移动构造函数一样,派生类的赋值运算符也必须显式地为其基类部分赋值:**==

     ```c++
     //Base::operator=(const Base&) 不会被自动调用
     D &D::operator=(const D&rhs)
     {
         Base::operator=(rhs); //为基类部分赋值
         //按照过去的方式为派生类的成员赋值
         //酌情处理自赋值及释放已有资源等情况
         return *this;
     }
     ```

   - **无论基类的构造函数或赋值运算符是自定义的版本还是合成的版本，派生类队形的操作都能使用他们。**

7. 派生类析构函数

   - **派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后**

8. 在构造函数和析构函数中调用虚函数

   - **如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本**。

9. **继承的构造函数**

   - 在C++11新标准中，**派生类能够重用其==直接基类==定义的构造函数**。尽管如我们所知，这些构造函数并非以常规的方式继承而来，但是为了方便，我们不妨姑且称其为“继承”的。**一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数**。**类不能继承默认、拷贝和移动构造函数**。**如果派生类没有直接定义这些构造函数则编译器将为派生类合成它们**。

   - 派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的`using`声明语句。

     ```c++
     class Bulk_quote:public Disc_quote
     {
         public:
         using Disc_quote::Disc_quote; //继承Disc_quote的构造函数
     };
     ```

   - 通常情况下，`using`声明语句只是令某个名字在当前作用域内可见。而**当作用于构造函数时，`using`声明语句将令编译器产生代码**。**对于基类的==每个构造函数==**，编译器都生成一个与之对应的派生类构造函数。换句话说，**对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。**

     - `derived(parms):base(args){}`
     - `derived`是派生类的名字，`base`是基类的名字，`parms`是构造函数的形参列表，`args`将**派生类构造函数的形参传递给基类的构造函数**

     ```c++
     //继承的构造函数等价于
     Bulk_quote(const std::string& book,double price,
               std::size_t qty,double disc):
     		Disc_quote(book,price,qty,disc){}
     ```

10. 继承构造函数的特点

    - 和普通成员的`using`声明不一样，==**一个构造函数的using声明不会改变该构造函数的访问级别**==。例如，不管using声明出现在哪儿，基类的私有构造函数在派生类中还是一个私有构造函数;受保护的构造函数和公有构造函数也是同样的规则。而且，**一`using`声明语句不能指定`explicit`或`constexpr`**。如果基类的构造函数是`explicit`或者`constexpr`，则继承的构造函数也拥有相同的属性。
    - 当**一个基类构造函数含有默认实参时，这些实参并不被继承**。相反，**派生类将获得多个继承的构造函数**，**其中每个构造函数分别省略掉一个含有默认实参的形参**。**例如，如果基类有一个==接受两个形参的构造函数==，其中==二个形参含有默认实参,则派生类将获得两个构造函数:一个构造函数接受两个形参(没有默认实参)，另一个构造函数只接受一个形参，它对应于基类中最左侧的没有默认值的那个形参。==**
    - 如果基类含有几个构造函数，**则除了两个例外情况，大多数时候派生类会继承所有这些构造函数**。
      - **第一个例外是派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本**。如果==派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承==。定义在派生类中的构造函数将替换继承而来的构造函数。
      - 第二个例外是==默认、拷贝和移动构造函数不会被继承==。这些**构造函数按照正常规则被合成**。继承的构造函数不会被作为用户定义的构造函数来使用，因此，如果一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数。

#### 容器与继承

- 当我们使用容器存放继承体系中的对象时，通常必须采取间接存储的方式。因为不允许在容器中保存不同类型的元素，所以我们不能把具有继承关系的多种类型的对象直接存放在容器当中。

  ```c++
  vector<Quote> basket;
  basket.push_back(Quote("0-2-1-82470-1"),50);//只能把对象的Quote部分拷贝给basket
  basket.push_back(Bulk_quote("0-201-5447-8"),50,10,.25));
  				//派生类的部分被忽略掉
  ```

  - 当派生类对象被赋值给基类对象时,其中的派生类部分将被“切掉”,因此容器和存在继承关系的类型无法兼容。

- ==**在容器中放置（智能）指针而非对象**==

  - 当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针(更好的选择是智能指针)。和往常一样，这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型:

  ```c++
  vector<shared_ptr<Quote>> basket;
  basket.push_back(make_shared<Quote>("0-201-82470-1",50));
  basket.push_back(make_shared<Quote>("0-201-54848-8",50,10,.25));
  
  //调用Quote定义的版本，打印562.5
  cout<<basket.back()->net_price(15)<<endl;
  ```

- Basket类

#### 文本查询程序再探

- 链接错误

### 模板与泛型编程

#### 定义模板

1. 函数模板

   ```c++
   template<typename T>
   template<typename T,class T2> //在模板参数列表中，typename和class没有什么不同
   //以关键字template开始，后跟一个模板参数列表，这是一个逗号分隔的一个或多个模板参数的列表
   ```

   - 非类型模板参数

     - 模板中定义非类型参数`nontype parameter`)。**一个非类型参数表示一个==值==而非一个类型**。**我们通过==一个特定的类型名==**而非关键字`class`或`typename`来指定非类型参数。

     - 当一个模板被实例化时，非类型参数被一个**用户提供**的或**编译器推断出的值**所代替。**这些值必须是==常量表达式==**，从而允许编译器在==**编译**==时实例化模板。

     - 一个**非类型参数可以是一个==整型==**，或者**是一个指向对象或函数类型的==指针或（左值)引用==**。绑定到非类型整型参数的实参必须是一个常量表达式。绑定到**指针或引用非类型参数的实参必须具有==静态的生存期==**。**我们不能用一个普通(非`static`）局部变量或动态对象作为指针或引用非类型模板参数的实参**。指针参数也可以用`nullptr`或一个值为0的常量表达式来实例化。

     - `inline`和`constexpr`的函数模板
       - `inline`或`constexptr`说明符放在模板参数列表之后，返回类型之前。

   - 编写与类型无关代码

     ```c++
     //即使用于指针也能正确的`compare`版本
     template<typename T>
     int compare(const T&vl,const T&v2)
     {
         //只使用<运算符，降低了compare函数对要处理的类型的要求，这些类型必须支持<
         if(std::less<T>()(v1,v2)) return -1; 
         if(std::less<T>()(v2,v1)) return 1;
         return 0;
         //正确处理比较两个指针且两个指针未指向相同的数组
     }
     ```

   - 模板编译

     - **当编译器遇到一个模板定义时，它并不生成代码。==只有当我们实例化出模板的一个特定版本时，编译器才会生成代码==。当我们使用(而不是定义)模板时，编译器才生成代码，这一特性影响了我们如何组织代码以及错误何时被检测到。**
     - 为了生成一个实例化版本,编译器需要掌握函数模板或类模板成员函数的定义因此，与非模板代码不同，**模板的头文件通常既包括声明也包括定义**。
     - 模板和头文件
       - 模板包含两种名字:
         - 那些不依赖于模板参数的名字
         - 那些依赖于模板参数的名字
           - 当使用模板时，所有不依赖于模板参数的名字都必须是可见的,这是由模板的提供者来保证的。而且,模板的提供者必须保证,当模板被实例化时,模板的定义，包括类模板的成员的定义，也必须是可见的。
           - 用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须是可见的,这是由**模板的用户**来保证的。
           - 通过组织良好的程序结构，恰当使用头文件，这些要求都很容易满足。模板的设计者应该提供一个头文件,包含模板定义以及在类模板或成员定义中用到的所有名字的声明。模板的用户必须包含模板的头文件,以及用来实例化模板的任何类型的头文件。

   - **大多数编译错误在实例化期间报告**

     - 第一个阶段是**编译模板本身时**。在这个阶段，编译器通常不会发现很多错误。**编译器可以检查语法错误，例如忘记分号或者变量名拼错等**，但也就这么多了。
     - 第二个阶段是**编译器遇到模板使用时**。在此阶段，编译器仍然没有很多可检查的。**对于函数模板调用，编译器通常会检查实参数目是否正确。它还能检查参数类型是否匹配。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参**，但也仅限于此了
     - 第三个阶段是**模板实例化时**，**只有这个阶段才能发现类型相关的错误**,依赖于编译器如何管理实例化，这类错误可能在链接时才报告。
     - 当我们编写模板时，代码不能是针对特定类型的，**但模板代码通常对其所使用的类型有一些假设**。例如，我**们最初的`compare`函数中的代码就假定实参类型定义了`<`运算符。**

2. 类模板

   - 实例化类模板

     ```c++
     //实例化出两个不同的vector类型
     vector<int> vec;
     vector<char> vec2;
     //这两个会实例化出两个不同的类，vec的定义创建了一个vector类，每个T都被替换为int,vec2的定义生成了另一个Blob类，T被替换未double
     ```

   - 类模板的成员函数

     - 类模板的成员函数本身是一个普通函数。但是，**类模板的每个实例都有其自己版本的成员函数**。因此，类模板的成员函数具有和模板相同的模板参数。因而，定义在类模板之外的成员函数就必须以关键字`template`开始，后接类模板参数列表。

       ```c++
       template <typename T>
       ret-type Blob<T>::member-name(parm-list);
       ```

   - **类模板成员函数的实例化**

     - ==**如果一个成员函数没有被使用,则它不会被实例化。**==成员函数只有在被用到时才进行实例化，这一特性使得即使某种类型不能完全符合模板操作的要求，我们仍然能用该类型实例化类。
     - 默认情况下，**==对于一个实例化了的类模板，其成员只有在使用时才被实例化==**

   - 在类代码内**简化模板类名**的使用

     ```c++
     template<typename T>
     class BlobPtr
     {
       	public:
         
         BlobPtr& operator++(); //前置运算符
         BlobPtr& operator--();
     };
     //当我们处于一个类模板的作用域中时，编译器处理模板自身引用时就好像我们已经提供了与模板参数匹配的实参一样。即，就好像我们这样编写代码一样:
     BlobPtr<T>& operator++();
     BlobPtr<T>& operator--();
     ```

     - 当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外。**在类模板自己的作用域中，我们可以直接使用模板名而不提供实参**。

   - 在类模板外使用类模板名

     - **当我们在类模板外定义其成员时，必须记住，我们并不在类的作用域中，==直到遇到类名才表示进入类的作用域。==**

     ```c++
     //后置：递增/递减对象但返回原值
     template <typename T>
     BlobPtr<T> BlobPtr<T>::operator++(int)
     {
         BlobPtr ret = *this;
         ++*this;
         return ret;
     }
     ```

     - **由于返回类型位于类的作用域之外，我们必须指出返回类型是一个实例化的 `BlobPtr`**，它所用类型与类实例化所用类型一致。**在函数体内，我们已经进入类的作用域，因此在定义 `ret` 时无须重复模板实参**。==**如果不提供模板实参，则编译器将假定我们使用的类型与成员实例化所用类型一致。**==因此，`ret`的定义与如下代码等价:
       - `BlobPtr<T> ret = *this;`

   - 类模板和友元

     - 当一个类包含一个友元声明时，**类与友元各自是否是模板**是相互无关的。
       - 如果**一个类模板包含一个==非模板友无==**，**则==友元被授权可以访问所有==模板实例**。
       - 如果**友元自身是模板**，**类可以==授权给所有==友元模板实例,也可以只==授权给特定==实例。**

   - 一对一友好关系

     - 类模板与另一个（类或函数）模板间友好关系的最常见的形式是**建立对应实例及其友元间的友好关系**。

       ```c++
       //一个模板的声明包括模板参数列表
       template<typename> class BlobPtr;//在Blob中声明友元所需要的
       
       template<typename> class Blob;//运算符==中的参数所需要的
       template<typename T>
       bool operator==(const Blob<T>&,const Blob<T>&);
       
       template<typename T>
       class Blob
       {
           friend class BlobPtr<T>;
           
           //每个Blob实例将访问权限授予用相同类型实例化的BlobPtr和相等运算符
           friend bool operator==<T>
               (const Blob<T>&,const Blob<T>&);
       }
       ```

   - 通用和特定的模板友好关系

     ```c++
     //前置声明，在将模板的一个特定实例声明为友元时要用到
     template<typename T> class Pal;
     class C
     {
         friend class Pal<C>; //用类C实例化的Pal是C的一个友元
         
         //Pal2的所有实例都是C的友元，这种情况无序前置声明
         template<typename T> friend class Pal2;
         
     };
     template<typename T>
     class C2		//C2本身是一个类模板
     {
         friend class Pal<T>;//C2的每个实例将相同实例化的Pal声明为友元，Pal的模板声明必须在作用域之内
         
         template<typename X> friend class Pal2; //Pal2的所有实例都是C2的每个实例的友元，不需要前置声明
         
         friend class Pal3;//Pal3是一个非模板类，它是C2所有实例的友元，不需要Pal3的前置声明
         
     };
     ```

     - **为了让==所有实例成为友元==，友元声名中必须使用与==类模板本身不同==的模板参数**。

   -  令模板自己的类型参数成为友元

     ```c++
     template<typename Type>
     class Bar
     {
       	friend Type;	//将访问权限授予用来实例化Bar的类型  
     };
     ```

     - 我们将用来实例化`Bar`的类型声明为友元。因此，对于某个类型名`Foo`，`Foo`将成为`Bar<Foo>`的友元，`Sales_data`将成为`Bar<Sales_data>`的友元，依此类推。

   - 模板类型别名

     ```c++
     typedef Blob<string> StrBlob;//由于模板不是一个类型，我们不能定义一个`typedef`引用一个模板，即，无法定义一个`typedef`引用Blob<T>
     
     //新标准允许我们为类模板定义一个类型别名
     template<typename T> using twin = pair<T,T>
     twin<string> authors //authors是一个pair<string,string>
     
     //定义一个模板类型别名时，可以固定一个或多个模板参数
     template<typename T> using parNo = pair<T,unsigned>;
     parNo<string> books; //books是一个pair<string,unsigned>
     ```

   - 类模板的`static`成员

     ```c++
     template<typename T>
     class Foo
     {
       	public:
         static std::size_t count()	{return ctr;}
         private:
         static std::size_t ctr;
     };
     ```

     - 对任意给定类型`x`，都有一个` Foo<X>::ctr`和一个 `Foo<X>::count`成员。所有`Foo<x>`类型的对象共享相同的`ctr`对象和`count`的函数。

       ```c++
       Foo<string> fs;		//实例化static成员Foo<string>::ctr和Foo<string>::count
       Foo<int> fi,fi2,fi3;//所有三个对象共享相同的Foo<int>::ctr和Foo<int>::count成员
       ```

     - 模板类的每个`static`数据成员必须有且仅有一个定义。但是，**类模板的==每个实例==都有一个独有的`static`对象**。因此，与定义模板的成员函数类似，我们将`static`数据成员也定义为模板。

       ```C++
       template<typename T>
       size_T Foo<T>::ctr = 0;		//定义并初始化ctr
       //我们可以通过类类型对象来访问一个类模板的static成员，也可以使用作用域运算符直接访问成员。
       Foo<int> fi;		//实例化Foo<int>类和static数据成员ctr
       auto ct = Foo<int>::count();//实例化Foo<int>::count;
       ct = fi.count();			//使用Foo<int>::count;
       ct = Foo::count();			//错误：使用哪个模板实例的count
       ```
       
       - **一个static成员函数只有在使用时才会实例化**

3. 模板参数

   - 类似函数参数的名字，一个模板参数的名字也没有什么内在含义。我们通常将类型参数命名为`T`，但实际上我们可以使用任何名字。

   - 模板参数与作用域

     - **一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同名字。在==模板内不能重用模板参数名==:**

     ```c++
     typedef double A;
     template<typename A,typename B>
     void f(A a,B b)
     {
         A temp = a;	//temp的类型为模板参数A的类型，而非double
         double B;	//✖ 重声明模板参数B
     }
     //由于参数名不能重用，所以一个模板参数名在一个特定模板参数列表中只能出现一次
     //错误：非法重用模板参数名V
     template<typename V,template V>
     ```

   - 模板声明

     - **模板声明必须包含模板参数**
     - **一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置,出现于任何使用这些模板的代码之前**。

   - 使用类的类型成员

     - 默认情况下，**`C++`语言假定==通过作用域运算符访问的名字不是类型==**。因此，**如果我们希望使用一个==模板类型参数==的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过使用关键字`typename`来实现这一点:**

     ```c++
     template<typename T>
     typename T::value_type top(const T&c)
     {
         if(!c.empty())
             return c.back();
         else
             return typename T::value_type();
     }
     ```

     - **当我们希望通知编译器一个名字表示类型时，必须使用关键字`typename`，而不能使用`class`。**

   - 默认模板实参

     ```c++
     template<typename T,typename F = less<T>>
     int compare(const T&v1,const T&v2, F f = F())
     {
         if(f(v1,v2))return -1;
         if(f(v2,v1))return 1;
         return 0;
     }
     ```

     - 在新标准中，我们可以为函数和类模板提供默认实参，而更早的C++标准只允许为类模板提供默认实参。
     - 与函数默认实参一样,对于一个模板参数,只有当它右侧的所有参数都有默认实参时，它才可以有默认实参。

   - **模板默认实参与类模板**

     - **如果==一个类模板==为其所有模板参数都提供了默认实参，且我们==希望使用这些默认实参==，就必须在==模板名之后根一个空尖括号对==**

     ```c++
     template<class T = int>
     class Numbers
     {
         public:
         Numbers(T v = 0):val(v){}
         private:
         T val;
     }
     Numbers<> average_precision //空<>表示我们希望使用默认类型
     ```

4. 成员模板

   - **一个类(无论是普通类还是类模板〉可以包含本身是模板的成员函数。这种成员被称为成员模板（ member template)。==成员模板不能是虚函数。==**

   - 普通（非模板）类的成员模板

     ```c++
     class DebugDelete
     {
       	public:
         DebugDelete(std::ostream &s= std::serr):os(s){}
         
         //与任何函数模板相同，T的类型由编译器推断
         template<typename T> void operator()(T*p)const
         {
             os<<"deleting unique_ptr"<<std::endl; delete p;
         }
         private:
         std::ostream &os;
     };
     ```

   - 类模板的成员模板

     ```c++
     template<typename T> class Blob
     {
         template<typename It>Blob(It b,It e);//此构造函数有自己的模板类型参数It,作为他的两个函数参数的类型
         //...
     };
     template<typename T> //类的类型参数
     template<typename It>//构造函数的类型参数
     Blob<T>::Blob(It b,It e):data(std::make_shared<std::vecotr<T>>(b,e)){}
     ```

5. 控制实例化

   - **当模板被使用时才会进行实例化这一特性意味着，==相同的实例可能出现在多个对象文件中==。当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，==每个文件中就都会有该模板的一个实例。==**

   ```c++
   //实例化的声明与定义
   extern template class Blob<string>; //声明
   template int compare(const int &,const int&);//定义
   ```

   - **当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为extern就表示承诺在程序其他位置有该实例化的一个非extern声明(定义)。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。**
   - **由于编译器在使用一个模板时自动对其实例化，因此==extern声明必须出现在任何使用此实例化版本的代码之前==**:

   ```c++
   // Application.cc
   //这些模板类型必须在程序其他位置进行实例化
   extern template class Blob<string>;
   extern template int compare (const int&,const int&);
   
   Blob<string> sal, sa2;		//实例化会出现在其他位置
   
   Blob<int> al ={0,1,2,3,4,5,6,7,8,9};	// Blob<int>及其接受initializer_list的构造函数在本文件中实例化
   Blob<int> a2 (al); 						//拷贝构造函数在本文件中实例化
   
   int i = compare(a1[0]，a2 [0]);/ //实例化出现在其他位置
   ```

   - **文件`Application.o`将包含`Blob<int>`的实例及其接受`initializer_list`参数的构造函数和拷贝构造函数的实例**。而`compare<int>`函数和`Blob<string>`类将不在本文件中进行实例化。这些模板的定义必须出现在程序的其他文件中;

   ```c++
   // templateBuild.cC .....
   //实例化文件必须为每个在其他文件中声明为extern的类型和函数提供一个(非extern)的定义
   template int compare (const int& ,const int&) ;
   template class Blob<string>; //实例化类模板的所有成员
   ```

   - 当编译器遇到一个实例化定义(与声明相对）时，它为其生成代码。因此，文件`templateBuild.o`将会包含`compare`的`int`实例化版本的定义和`Blob<string>`类的定义。当我们编译此应用程序时，必须将`templateBuild.o`和 `Application.o`链接到一起。
   - **==一个类模板的实例化定义会实例化该模板的所有成员==，包括内联的成员函数。当编译器遇到一个实例化定义时，它不了解程序使用哪些成员函数。因此，与处理类模板的普通实例化不同，编译器会实例化该类的所有成员。即使我们不使用某个成员，它也会被实例化。因此，我们用来显式实例化一个类模板的类型，必须能用于模板的所有成员。**

6. 效率与灵活性

   - 

#### 模板实参推断

1. 类型转换与模板类型参数

   - `const` 转换:可以将一个非 `const`对象的引用（或指针）传递给一个`const` 的引用（或指针）形参。
   - **数组或函数指针转换**:如果==**函数形参不是引用类型**==，**则可以对==数组或函数类型的实参应用正常的指针转换==**。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针（参见4.11.2节，第143页)。
   - **其他类型转换,如算术转换派生类向基类的转换以及用户定义的转换都不能应用于函数模板。**

   ```c++
   template <typename T> Tfobj(T,T);				//实参被拷贝
   template <typename T> T fref(const T&,const T&);// 引用
   
   string s1 ("a value");
   const string s2("another value");
   fobj(s1, s2);//调用fobj(string, string); const被忽略
   fref(s1,s2);//调用fref(const string&,const string&)将sl转换为const是允许的
   
   int a[10],b[42];
   fobj(a, b);	//调用f(int*, int*)
   fref(a, b);	//错误:数组类型不匹配
   ```

   - **将实参传递给带模板类型的函数形参时,能够自动应用的类型转换只有`const`转换及数组或函数到指针的转换。**

2. 使用相同模板参数类型的函数形参

   - **一个模板类型参数可以用作多个函数形参的类型**由于只允许有限的几种类型转换因此传**递给这些形参的实参必须具有相同的类型**。

     - `compare(1.2f,1024)`不能实例化`compare(float,int)`

   - 希望允许对函数实参进行正常的类型转换，我们可以将函数模板定义为两个类型参数

     ```c++
     template<typename A,template B>
     int flexibleCompare(const A&v1,const B&v2);//实参类型可以不同，但必须兼容
     
     template<typename T> ostream &print(ostream &os,const T&obj);
     //如果函数参数类型不是模板参数，则对实参进行正常的类型转换,
     ```

3. **函数模板显示实参**

   ```c++
   //sum函数模板，它接受两个不同类型的参数。我们希望允许用户指定结果的类型.
   template<typename T1,typename T2,typename T3>
   T1 sum(T2,T3);
   
   //T1是显示指定的,T2和T3是从函数实参类型推断而来的
   auto val3 = sum<long long>(i,lng); //long long sum(int,long);
   ```

   - **显式模板实参**按**由左至右的顺序**与对应的模板参数匹配;第一个模板实参与第一个模板参数匹配，第二个实参与第二个参数匹配，依此类推。只有尾部（最右）参数的显式模板实参才可以忽略，而且前提是它们可以从函数参数推断出来。

   ```c++
   //糟糕的设计:用户必须指定所有三个模板参数
   template <typename T1, typename T2, typename T3>
   T3 alternative_sum(T2,T1);
   ```

4. 正常类型转换应用于显示指定的实参

   - **如果==显示指定模板类型参数==，就==可以进行正常类型转换==了**。

5. 尾置返回类型与类型转换

   ```c++
   //尾置返回允许我们在参数列表之后声明返回类型
   template<typename It>
   auto fcn(It beg,It end)->decltype(*beg)
   {
       //处理序列
       return *beg; //返回序列中一个元素的引用
   }
   ```

6. 进行类型转换的标准库模板类

   <img style="width: 1000px;height:800px" src="Image\type_traits.png">

   ```c++
   //使用模板参数的成员，必须使用typename
   template<typename It>
   auto fcn2(It beg,It end)->typename std::romve_reference<decltype(*beg)>::type
   {
       //处理序列
       return *beg; //返回序列中一个元素的拷贝
   }
   ```

   - **每个模板都有一个名为`type`的`public`成员，表示一个类型**。此类型与模板自身的模板类型参数相关，其关系如模板名所示。**如果不可能（或者不必要）转换模板参数，则type成员就是模板参数类型本身**。例如，如果T是一个指针类型，则`remove pointer<T>::type`是T指向的类型。如果T不是一个指针，则无须进行任何转换，从而`type`具有于`T`相同的类型。

7. 函数指针和实参推断

   - 当我们用**一个函数模板初始化一个函数指针或为一个函数指针赋值时**，**编译器使用==指针的类型==来推断模板实参**。

   ```c++
   template<typename T> int compare(const T&,const T&);
   int (*pf1)(const int&,const int&) = compare;// pf1指向实例int compare (const int&,const int&)
   
   //func的重载版本;每个版本接受一个不同的函数指针类型
   void func(int(*)(const string&, const string&));
   void func(int (*)(const int&, const int&) );
   func(compare); //错误:使用compare的哪个实例?
   
   //通过使用显示模板参数类消除func调用的歧义
   func(compare<int>); //传递compare(const int&,const int&);
   ```

8. 模板实参推断和引用

   - 从左值引用函数参数推断类型

     - 当**一个函数参数是模板类型参数**的一个==**左值引用时**==绑定规则告诉我们，只能传递给它一个左值。实参可以是`const`类型，也可以不是。如果实参是`const`的，**则T将被推断为const类型**:

     ```c++
     template<typename T> void f1(T&); //实参必须是一个左值
     f1(ci); //ci是一个const int;模板参数T是const int
     ```

     - 如果一个函数参数的类型是`const T&`，正常的绑定规则告诉我们可以传递给它任何类型的实参、一个临时对象或是一个字面常量值。**当==函数参数本身是`const`时==，==T的类型推断的结果不会是一个`const`类型==**。**`const`已经是函数参数类型的一部分;因此，==它不会也是模板参数类型==的一部分:**

     ```c++
     //f2中的参数是const&，实参中的const是无关的
     template<typename T> void f2(const T&);//可以接受一个右值
     f2(ci);//ci是一个const int,但模板参数T是int
     
     template<typename T> void f3(T&&);
     ```

   - 从右值引用函数参数推断类型：推断出的T的类型是该右值实参的类型。

   - 引用折叠和右值引用参数

     - 当我们将**一个左值**（如i）**传递给函数的右值引用参数**，**==且==此右值引用指向模板类型参数（如T&&）时**，**==编译器推断模板类型==参数为实参的左值引用类型**。因此，当我们调用`f3(i)`时，编译器推断T的类型为`int&`，而非`int`。
       - `T`被推断为`int&`看起来好像意味着`f3`的函数参数应该是一个类型`int&`的右值引用通常，我们不能定义一个引用的引用。但是，通过类型别名或通过模板类型参数间接定义是可以的。
     - **如果我们==间接创建==一个引用的引用，则这些引用形成了“折叠”。**在所有情况下（除了一个例外)，引用会折叠成一个普通的左值引用类型。在新标准中，折叠规则扩展到右值引用。**只在一种特殊情况下引用会折叠成右值引用:==右值引用的右值引用==。即，对于一个给定类型x**:
       - `X& &、X& &&`和`X&& &`都折叠成类型`X&`
       - 类型`X&& &&`折叠成`X&&`
     - 引用折叠只能应用于间接创建的引用的引用，如**类型别名或模板参数**。
     - **如果一个函数参数是指向模板参数类型的右值引用(如，T&& ),==则可以传递给它任意类型的实参。如果将一个左值传递给这样的参数,则函数参数被实例化为一个普通的左值引用(T&)。==**

   - 编写接受右值引用参数的模板函数

     ```c++
     //模板参数可以推断为一个引用类型，这一特性对模板内的代码可能有令人惊讶的影响
     template<typename T>
     void f3(T&& val)
     {
         T t = val;	//拷贝还是绑定一个引用
         t = fcn(t);	//赋值只改变t还是即改变t又改变val
         if(val==t){	}	//若T是引用类型，则一直尾true
     }
     ```

     - **==右值引用通常用于两种==情况：==模板转发其实参或模板被重载==**
     
     ```c++
     template<typename T> void f(T&&);
     template<typename T> void f(const T&);
     ```

9. 理解`std::move`

   ```c++
   template<typename T>
   typename remove_reference<T>::type&& move(T&& t)
   {
       return static_cast<typename remove_reference<T>::type&&>(t);
   }
   ```

   - 从一个左值`static_cast`到一个右值引用是允许的
     - **一条针对右值引用的特许规则**:虽然不能隐式地将一个左值转换为右值引用，但==我们可以用`static_cast`显式地将一个左值转换为一个右值引用==。
     - 虽然我们可以直接编写这种类型转换代码，但使用标准库`move`函数是容易得多的方式。而且，**统一使用`std: :move`使得我们在程序中查找潜在的截断左值的代码变得很容易**。

10. 转发

   - 定义能保持类型信息的函数参数

     - **通过将一个函数参数定义为一个指向==模板类型参数的右值引用==**，**我们可以保持其对应实参的所有类型信息**。而使用引用参数**(无论是左值还是右值)使得我们可以保持`const`属性**,因为在==引用类型中的`const`是底层的==。如果我们将函数参数定义为`T1& &`和 `T2&&`,通过引用折叠就可以保持翻转实参的左值/右值属性

     ```c++
     template<typename F,template T1,template T2>
     void flip2(F f,T1 &&t1,T2 &&t2)
     {
         f(t1,t2);
     }
     ```

     - 如果我们调用`flip2(f,j,42)`，**将传递给参数`t1`一个左值但是**，在`flip2`中，**推断出的`T1`的类型为`int &`**，**这意味着`t1`的类型会折叠为`int&`**由于是引用类型，`t1`被绑定到j上。当 `flip2`调用`f`时，`f`中的引用参数`v2`被绑定到`t1`，也就是被绑定到j。当`f`递增`v2`时，它也同时改变了`j`的值。

     - **这个版本的`flip2`解决了一半问题。它对于接受一个左值引用的函数工作得很好，但不能用于接受右值引用参数的函数。例如:**

       ```c++
       void g(int &&i,int &j)
       {
           std::cout<<i<<" "<<j<<std::endl;
       }
       flip2(g,i,42); //错误：不能从一个左值实例化int&&
       ```

     - **如果我们试图通过`flip2`调用`g`，则参数`t2`将被传递给`g`的右值引用参数。即使我们传递一个右值给`flip2`**

   - 在调用中使用`std::forward`保持类型信息

     - 类似`move`,`forward`定义在头文件`utility`中。与`move`不同, **`forward`必须通过显式模板实参来调用**。
     - **我们使用`forward` 传递那些定义为==模板类型参数==的==右值引用的函数参数==**。通过其返回类型上的引用折叠，`forward`可以保持给定实参的左值/右值属性:

     ```c++
     template <typename Type> 
     void intermediary(Type &&arg)
     {
     	finalFcn(std::forward<Type>(arg));
     }
     ```

     - 本例中我们使用`Type`作为 `forward` 的显式模板实参类型，它是从`arg`推断出来的,由于`arg`是一个模板类型参数的右值引用，`Type`将表示传递给`arg`的实参的所有类型信息。**如果实参是一个右值，则`Type`是一个普通（非引用）类型**，`forward<Type>`将返回`Type&&`。如果实参是一个左值，则通过引用折叠，`Type`本身是一个左值引用类型。在此情况下，返回类型是一个指向左值引用类型的右值引用。再次对`forward<Type>`的返回类型进行引用折叠，将返回一个左值引用类型。

#### 重载与模板

- 函数模板可以被另**一个模板**或**一个普通非模板函数重载**。与往常一样，名字相同的函数必须具有不同数量或类型的参数。

- 如果涉及函数模板，则函数匹配规则会在以下几个方面受到影响：

  - 对于一个调用，其候选函数**包括所有==模板实参推断成功的函数模板实例==**。
  - **候选的函数模板总是可行的**，**因为模板实参推断会排除任何不可行的模板**。
  - 与往常一样，可行函数（模板与非模板）按类型转换（如果对此调用需要的话)来排序。当然，可以用于==**函数模板调用的类型转换是非常有限**==的（参见16.2.1节，第601页)。
  - 与往常一样,如果恰有一个函数提供比任何其他函数都更好的匹配,则选择此函数。但是，如果有多个函数提供同样好的匹配，则:
    - **如果同样好的函数中只有一个是非模板函数，则选择此函数。**
    - 如果同样好的函数中没有非模板函数，而有多个函数模板，且**其中一个模板比其他模板**==**更特例化**==，则选择此模板。
    - 否则，此调用有歧义。

- 编写重载模板

  ```c++
  template <typename T> 
  string debug_rep(const T &t)
  {
  	ostringstream ret; 
  	ret << t; 			//使用T的输出运算符打印t的一个表示形式
      return ret.str();	//返回ret绑定的string的一个副本
  }
  //打印指针的值，后跟指针指向的对象
  //注意:此函数不能用于char*;参见16.3节（第617页)
  template <typename T> 
  string debug_rep(T *p)
  {
      ostringstream ret;
  	ret <<"pointer : " << p;		//打印指针本身的值
      if (p)
  		ret << " " << debug_rep(*p);//打印p指向的值
  	else
  		ret << " null pointer";		//或指出p为空
  	return ret.str();//返回ret绑定的string的一个副本
  }
  ```

  - **因为==IO库为`char*`值定义了一个<<版本==。此<<版本==假定指针表示一个空字符结尾的字符数组==，并打印数组的内容而非地址值**。

  ```c++
  string s("hi");
  cout<<debug_rep(s)<<endl;
  /*
  	对于这个调用，只有第一个版本的debug_rep是可行的。第二个debug_rep版本要求一个指针参数，但在此调用中我们传递的是一个非指针对象。因此编译器无法从**一个非指针实参实例化一个期望指针类型参数的函数模板**，因此实参推断失败。由于只有一个可行函数，所以此函数被调用。
  */
  cout<<debug_rep(&s)<<endl;
  /*
  	第二个版本的debug_rep的实例是此调用的精确匹配。第一个版本的实例需要进行普通指针到const指针的转换。正常函数匹配规则告诉我们应该选择第二个模板，实际上编译器确实选择了这个版本。
  */
  ```

- 多个可行模板

  ```c++
  const string *sp = &s;
  cout<<debug_rep(sp)<<endl;
  ```

  - `debug_rep(const string*&)`，由第一个版本的`debug_rep`实例化而来，T被绑定到`string*`。
  - `debug_rep(const string*)`，由第二个版本的 `debug_rep`实例化而来，T被绑定到`const string`。
  - 在此情况下，正常函数匹配规则无法区分这两个函数。我们可能觉得这个调用将是有歧义的。但是，根据重载函数模板的特殊规则，此调用被解析为`debug_rep(T*)`，**即，更特例化的版本**。
  - 设计这条规则的原因是，没有它，将无法对一个`const`的指针调用指针版本的`debug_rep`。问题在于模板`debug_rep(const T&)`本质上可以用于任何类型，包括指针类型。此模板比`debug_rep(T*)`更通用，后者只能用于指针类型。没有这条规则，传递`const`的指针的调用永远是有歧义的。

- 非模板和模板重载

  ```c++
  string debug_rep(const string &s)
  {
      return '"'+s+'"';
  }
  string s("hi");
  std::cout<<debug_rep(s)<<endl;
  ```

  - 当存在多个同样好的函数模板时，编译器选择最特例化的版本，出于相同的原因，一个非模板函数比一个函数模板更好。

- 重载模板和类型转换

  ```c++
  cout << debug_rep("hi world!")<< endl;//调用debug_rep(T*)
  //本例中所有三个debug_rep版本都是可行的:
  debug_rep(const T&），	//T被绑定到char[10]。
  debug_rep(T*)，			 //T被绑定到const char。
  debug_rep(const string&)，//要求从const char*到string 的类型转换。
  ```

  - 对给定实参来说，**两个模板都提供精确匹配**——**第二个模板需要进行一次（许可的）数组到指针的转换**，而对于函数匹配来说，**这种转换被认为是精确匹配**（参见6.6.1节，第219页)。**非模板版本是可行的，但需要进行一次用户定义的类型转换，因此它没有精确匹配那么好**，**所以两个模板成为可能调用的函数**。与之前一样，`T*`版本更加特例化，编译器会选择它。

  ```c++
  //将字符指针转换为string，并调用string版本的debug_reg
  string debug_rep(char *p);
  string dobug_rep(const char *p);
  ```

- 缺少声明可能导致程序行为异常

  - **在定义任何函数之前,记得声明所有重载的函数版本。这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本**

#### 可变参数模板

- 可变数目的参数被称为**参数包**( parameter packet)。存在两种参数包:**模板参数**包( template parameter packet)，表示零个或多个模板参数;**函数参数包**(function paramepacket)，表示零个或多个函数参数。

  ```c++
  // Args是一个模板参数包;rest是一个函数参数包
  // Args表示零个或多个模板类型参数
  // rest表示零个或多个函数参数
  template <typename T, typename...Args>
  void foo(const T &t,const Args&...rest);
  ```

  - `Args`的模板参数包。这个包表示零个**或多个额外的==类型参数==**

  ```c++
  int i= 0; double d = 3.14; string s = "how now brown cow";
  foo(i, s,42，d);//包中有三个参数
  foo(s,42，"hi");//包中有两个参数
  foo(d,s);		//包中有一个参数
  foo("hi");		//空包
  
  //编译器会为foo 实例化出四个不同的版本:
  void foo (const int&, const string&,const int&,const double& );
  void foo (const string&, const int&, const char[3]&);
  void foo (const double&, const string& ) ;
  void foo (const char[3]&);
  ```

- `sizeof...`运算符

  ```c++
  template<typename...Args>void g(Args...args)
  {
      cout<<sizeof...(Args)<<endl;//类型参数的数目
      cout<<sizeof...(args)<<endl;//函数参数的数目
  }
  ```

- 编写可变参数函数模板

  - **可变参数函数通常是递归的**（参见6.3.2节，第204页)。**第一步调用处理包中的第个实参，然后用剩余实参调用自身**。我们的print函数也是这样的模式，**每次递归调用将第二个实参打印到第一个实参表示的流中**。为了终止递归，我们还需要定义一个非可变参数的print函数，它接受一个流和一个对象:

  ```c++
  template<typename T>
  ostream &print(ostream &os,const T &t){return os<<t;}//最后一个参数不分割
  template<typename T,typename...Args>
  ostream& print(ostream&os,const T&t,const Args&...rest)
  {
      os<<t<<", ";			//打印第一个实参
      return print(os,rest...);//递归调用，打印其它实参
  }
  ```

  - `rest`中的第一个实参被绑定到`t`剩余实参形成下一个`print`调用的参数包。因此，**在每个调用中，包中的第一个实参被移除**，成为绑定到`t`的实参。
  - 对于最后一个调用，两个函数提供同样好的匹配。但是，非可变参数模板比可变参数模板更特例化，因此编译器选择非可变参数版本。

  <img style="width: 1000px;height:300px" src="Image\函数可变实参.png">

  - 对于最后一个调用，两个函数提供同样好的匹配。但是，非可变参数模板比可变参数模板更特例化，因此编译器选择非可变参数版本。
  - **当非可变参数版本不在作用域时，还会继续扩展为`print(cout)`，这就无法与任何模板匹配了，从而产生编译错误**

- 包扩展

  - 对于一个参数包，除了获取其大小外，我们能对它做的唯一的事情就是**扩展**（expand）它。**当扩展一个包时，我们还要提供用于每个扩展元素的==模式==**(pattern)。**扩展一个包就是将它==分解为构成的元素==，对每个元素应用==模式==**，获得扩展后的列表。我们通过在模式右边放一个省略号(...)来触发扩展操作。
  - 第一个扩展操作扩展**模板参数包**，**为`print`生成函数参数列表**、**第二个扩展操作出现在对`print`的调用中。此模式为`print`调用生成实参列表。**
  - 对`Args`的扩展中，编译器将**模式`const Arg&`**应用到模板参数包`Args`中的每个元素

- 理解包扩展

  ```c++
  template<typename...Args>
  ostream&errorMsg(ostream &os,const Args&...rest)
  {
      //print(os,debug_rep(a1),debug_rep(a2),...,debug_rep(an))
      return print(os,debug_rep(rest)...);
  }
  //将包传递给debug rep; print (os，debug rep(a1,a2， ..., an))
  print (os,debug_rep(rest. . .));//错误:此调用无匹配函数
  
  ```

- 转发参数包

  ```c++
  class StrVec
  {
      public:
      template<class...Args> void emplace_back(Args&&...args)
      {
          chk_n_alloc();//如果需要的话从新分配StrVec内存空间
          alloc.construct(first_free++,std::forward<Args>(args)...);
      }
  }
  ```

  - `construct`调用中的扩展为`std::forward<Args>(args)...`**==它既扩展了模板参数包`Args`，也扩展了函数参数包`args`==。此模式生成如下形式的元素**。std::forward<T~i~>(t~i~)

#### 模板特例化

- 在某些情况下，**通用模板的定义对==特定类型是不适合的==;通用定义可能编译失败或做得不正确。其他时候，我们也可以利用某些特定知识来编写更高效的代码，而不是从通用模板实例化。==当我们不能（或不希望）使用模板版本时==，可以定义类或函数模板的==一个特例化版本==**。

  ```c++
  //我们希望compare通过调用strcmp比较两个字符指针而非比较指针值
  template<typename T>int compare(const T&,const T&); //比较任意两个类型
  template<size_t N,size_t M>//处理字符串字面常量
  int compare(const char(&)[N],const char(&)[M]);
  ```

- 问题：只有当我们传递给`compare`**一个字符串字面常量或者一个数组时**，**编译器才会调用接受两个非类型模板参数的版本**。如果我们传递给它字符指针，就会调用第一个版

- **为了处理字符指针(而不是数组)，可以为第一个版本的compare定义一个模板特例化( template specialization）版本。==一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型==。**

- 定义函数模板特例化

  - **当我们特例化一个函数模板时，==必须为原模板中的每个模板参数都提供实参==。为了指出我们正在实例化一个模板，应使用关键字template后跟一个空尖括号对(<>)。==空尖括号指出我们将为原模板的所有模板参数提供实参==:**

  ```c++
  template<> int compare(const char*const&p1,const char*const&p2)	
  //const (const char*) &  →  const char* const &
  {return strcmp(p1,p2);}
  ```

  - 我们希望定义此函数的一个特例化版本，其中`T`为`const char*`。我们的函数要求==**一个指向此类型`const`版本的引用**。==一个指针类型的`const`版本是一个常量指针而不是指向`const`类型的指针（参见2.4.2节，第56页)。我们需要在特例化版本中使用的类型是`const char * const &`，即一个指向`const char`的`const` 指针的引用。

- 函数重载与模板特例化

  - **特例化的本质是实例化一个模板，而非重载它。因此,特例化不影响函数匹配**。
  - 我们将一个特殊的函数定义为一个特例化版本还是一个独立的非模板函数，**会影响到函数匹配**
  - **当一个非模板函数提供与函数模板同样好的匹配时，编译器会选择非模板版本。**
  - **==模板及其特例化版本应该声明在同一个头文件中==。所有==同名模板的声明应该放在前面==,然后是这些模板的特例化版本。**

- 类模板特例化

  - 无序容器使用`hash<key_type>`来组织其元素为了**让我们自己的数据类型也能使用这种默认组织方式，必须定义hash模板的一个特例化版本**。一个特例化`hash`类必须定义:
    - **一个重载的调用运算符**，它接受一个容器关键字类型的对象，返回一个`size_t`。
    - **两个类型成员**，`result_type`和 `argument_type`，分别调用运算符的返回类型和参数类型。
    - **默认构造函数和拷贝赋值运算符**（可以隐式定义，参见13.1.2节，第443页)。

  ```c++
  namespace std//打开std命名空间，以便特例化std::hash
  {
  	template<>//我们正在定义一个特例化版本，模板参数为Sales_data
  	struct hash<Sales_data>
  	{
          //用来散列一个无序容器的类型必须要定义下列类型
  		typedef size_t result_type;
  		typedef Sales_data argument_type;
  		size_t operator()(const Sales_data& s) const;
  	};
  	size_t hash<Sales_data>::operator()(const Sales_data& s)const
  	{
  		return hash<string>()(s.bookNo)^
  			   hash<unsigned>()(s.units_sold)^
  			   hash<double>()(s.revenue);
  	}
  }
  ```

  - `template<>`指出我们正在定义**一个全特例化的模板**。我们正在特例化的模板名为`hash`,而**特例化版本为 `hash<sales_data>`。**
  - 重载的调用运算符必须为给定类型的值定义一个哈希函数。==**对于一个给定值,任何时候调用此函数都应该返回相同的结果**==。一个好的哈希函数对不相等的对象(几乎总是)应该产生不同的结果。
  - 我们使用一个（未命名的)`hash<string>`对象来生成`bookNo` 的哈希值，用一个 `hash<unsigned>`对象来生成`units_sold`的哈希值，用一个`hash<double>`对象来生成`revenue` 的哈希值。我们将这些结果进行异或运算形成给定sales_data对象的完整的哈希值。
  - 由于`hash<sales_data>`使用`sales_data`的私有成员，我们必须将它声明为`Sales_data`的友元
  - 为了让 `Sales_data`的用户能使用`hash`的特例化版本，我们应该在`sales_data`的头文件中定义该特例化版本

- 类模板**部分特例化**

  - 与函数模板不同，类模板的特例化不必为所有模板参数提供实参。我们可以**只指定部分而非所有模板参数**，或是参数的**一部分而非全部特性**。**一个==类模板的部分特例化==( partial specialization)==本身是一个模板==，使用==它时用户还必须为那些在特例化版本中未指定的模板参数提供实参==。**

    - ==**我们只能部分特例类模板，而不能部分特例化函数模板**==

    ```c++
    //原始的最通用的版本
    template<typename T>
    struct remove_reference{ typedef T type;}
    //部分特例化版本，将用于左值引用和右值引用
    template<class T> struct remove_reference<T&>//左值引用
    {typedef T type;}
    template<class T> struct remove_reference<T&&>//右值引用
    {typedef T type;}
    ```

- 特例化成员而不是类

  ```c++
  template<typename T>
  struct Foo
  {
    	Foo(const T&t = T()):mem(t){}
      void Bar(){}
      T mem;
      //Foo的其它成员
  };
  template<>		//我们正在特例化一个模板
  void Foo<int>::Bar()//我们正在特例化Foo<int>的成员Bar
  {
      //进行应用于int的特例化处理
  }
  Foo<int> fi;//实例化Foo<int>::Foo();
  fi.Bar() 	//使用我们特例化版本的Foo<int>::Bar();
  ```

  - 当我们用`int`之外的任何类型使用`Foo`时,其**成员像往常一样进行实例化**。当我们用`int`使用`Foo`时，`Bar`**之外的成员**像往常一样进行实例化。**如果我们使用`Foo<int>`的成员Bar，则会使用我们定义的特例化版**本。

### 特殊标准库设施

#### `tuple`类型

- `tuple`类型的成员类型可不相同，一个`tuple`可以有任意数量的成员。每个确定的`tuple`类型的成员数目是固定的，但一个`tuple`类型的成员数目可以与另一个`tuple`类型不同。

  <img style="width: 1000px;height:700px" src="Image\tuple.png">

  1. 定义和初始化`tuple`

     ```c++
     tuple<string,vector<double>,int,list<int>> someVal("constants",{3,14,2.718},42,{1,2,3,4,5});
     //tuple的这个构造函数是explicit的，因此我们必须使用直接初始化语法
     tuple<size_t,size_t,size_t> threeD = {1,2,3};//错误
     tuple<size_t,size_t,size_t> threeD{1,2,3};//正确
     
     auto item = make_tuple("0-999-78345-X",3,20.00);
     ```

  2. 访问`tuple`的成员

     - `tuple`的成员都是未命名的。要访问一个`tuple`的成员，就要使用一个名为`get`的**标准库函数模板**。为了使用`get`，我们必须指定一个**显式模板实参**，它指出我们想要访问第几个成员。我们传递给`get`一个`tuple`对象，它返回指定成员的引用。
     - **尖括号中的值必须是一个整形常量表达式**

  3. 关系和相等运算符

     - 这些运算符**逐对比较左侧tuple和右侧tuple的成员。==只有两个tuple具有相同数量的成员时==，我们才可以比较它们**。而且，为了使用`tuple` 的相等或不等运算符，**对每对成员使用`==`运算符必须都是合法的**;为了使用关系运算符，**对每对成员使用<必须都是合法的**。

#### `BITSET`类型

<img style="width: 1000px;height:700px" src="Image\bitset.png">

1. 定义和初始化`bitset`

   - `bitset<32> bitvec(1U)` 32位，低位为1，其他位为0。大小必须是一个常量表达式。**编号从0开始**的二进制被称为**低位**，**编号到`31`结束**的二进制位被称为**高位**。
   - 如果`bitset`的大小**大于**一个`unsigned long long` 中的二进制位数**，则剩余的高位被置为`0`。**如果`bitset`的大小**小于**一个`unsigned long long` 中的二进制位数，则只使用给定值中的低位，**超出`bitset`大小的高位被丢弃**:

2. 从一个`string`初始化`bitset`

   - `string`的下标编号习惯与`bitset`恰好相反:**`string`中下标最大的字符最右字符)用来初始化`bitset`中的低位(下标为0的二进制位)。**当你用一个`string`初始化一个`bitset`时,要记住这个差别。

   ```c++
   string str ( "1111111000000011001101");
   bitset<32> bitvec5(str，5，4);		//从str[5]开始的四个二进制位，1100
   bitset<32> bitvec6(str,str.size()-4);//使用最后四个字符
   ```

   <img style="width: 1000px;height:400px" src="Image\bitset初始化过程.png">

3. `bitset`操作

   - `bitset`类支持我们在位运算符。这些运算符用于`bitset`对象的含义与内置运算符用于`unsigned`运算对象相同。

   <img style="width: 1000px;height:600px" src="Image\bitset操作.png">

   - **下标运算符对`const`属性进行了重载**。`const`版本的下标运算符在指定位==**置位**==时返回`true`，否则返回`false`。**非 `const`版本返回`bitset`定义的一个特殊类型，它允许我们操纵指定位的值。**

4. 提取`bitset`的值

   - `to_ulong`和`to_ullong`操作如果`bitset`中的值不能放入给定类型中,则这两个操作会抛出一个`overflow_error`异常。

5. `bitset`的IO运算符

   - 输入运算符从一个输入流读取字符，保存到一个临时的`string`对象中。直到读取的字符数达到对应`bitset`的大小时，或是遇到不是1或0的字符时，或是遇到文件尾或输入错误时，读取过程才停止。随即用临时string对象来初始化`bitset`。如果读取的字符数小于`bitset`的大小，则与往常一样，高位将被置为`0`。

#### 正则表达式

<img style="width: 1000px;height:300px" src="Image\regex.png">

<img style="width: 1000px;height:300px" src="Image\regex_search.png">

- 函数`regex_match`和`regex_search`确定一个给定**字符序列**与一个给定**的`regex`是否匹配**。如果==**整个输入序列与表达式匹配**==，则`regex_match` 函数返回`true`;如果输入序列中**==一个子串与表达式匹配，则`regex_search`函数返回 `true`。==**
- 这些函数都返回`bool`值，且都被重载了:其中一个版本==**接受一个类型为`smatch` 的附加参数**==。如果匹配成功，这些函数将**成功匹配的相关信息保存在给定的`smatch`对象中**。

1. 使用正则表达式库

   ```c++
   string pattern("[^c]ei");
   pattern = "[[:alpha:]]*"+pattern+"[[:alpha:]]*";
   
   regex r("[[:alnum:]]+\\.(cpp|cxx|cc)$",regex::icase)
   ```

   - `[^c]`表示匹配任意不是`'c'`的字符。`[^c]ei`匹配这种字符后接`ei`的字符串
   - `[[::alpha:]]`匹配任意字母。是 C++11 中引入的 `Unicode` 风格的字符类，匹配任意一个 `Unicode`字母字符
   - `+`一个或多个
   - `*`零个或多个
   - 字符`.`通常匹配任意字符，于C++一样，在字符之间放置一个反斜线去掉其特殊含义。
   - 函数`regex_search`在输入序列中==**只要找到一个匹配的子串就会停止查找**。==

2. 指定`regex`对象的选项

   <img style="width: 1000px;height:700px" src="Image\regex选项.png">

3. 指定或使用正则表达式时的错误

   - 我们可以将正则表达式本身看作用一种简单程序设计语言编写的“程序”。这种语言不是由C++编译器解释的。**正则表达式是在运行时，当一个regex对象被初始化或被赋予一个新模式时，==才被“编译”的==**。
   - 如果我们编写的**正则表达式存在错误**，则在运行时标准库会抛出一个类型为**`regex_error`的异常**。`regex_error`有一个`what`操作来描述发生了什么错误。`regex_error`还有一个名为 **`code` 的成员，用来返回某个错误类型对应的数值编码**。**code返回的值是由具体实现定义的。RE库能抛出的标准错误如表17.7所示**。

   <img style="width: 1000px;height:500px" src="Image\正则表达式错误类型.png">

   - `code`成员，返回表17.7的**错误类型的编号，编号从0开始**。
   - 避免创建不必要的正则表达式
     - 一个正则表达式所表示的“程序”是在运行时而非编译时编译的。正则表达式的编译是一个非常慢的操作，特别是在你使用了扩展的正则表达式语法或是复杂的正则表达式时。

4. 正则表达式类和输入序列类型

   - 我们可以搜索多种类型的==**输入序列**==。**输入可以是普通`char`数据或`wchar_t`数据字符可以保存在标准库`string` 中或是 `char`数组中(或是宽字符版本，`wstring`或`wchar_t`数组中)。**RE为这些不同的输入序列类型都定义了对应的类型。

   - `wregex`类保存类型`wchar_t`，其操作于`regex`完全相同。

   - **匹配和迭代器类型**更为特殊。**这些类型的差异不仅在于字符类型，还在于序列是在标准库`string`中还是在数组中:** 

     - `smatch`表示`string`类型的输入序列;`cmatch`表示字符数组序列;
     - `wsmatch`表示宽字符串（`wstring`）输入;而`wcmatch`表示宽字符数组。

     <img style="width: 1000px;height:200px" src="Image\正则表达式库类.png">

     ```c++
     std::regex r("[[:alpha:]]+\\.(cpp|cxx|cc)$", std::regex::icase);
     std::smatch result;
     if (std::regex_search("main.cpp", result, r)) //错误：main.cpp是const char[]
         std::cout<< result.str()<<std::endl;
     ```

     

5. 匹配于Regex迭代器类型

   <img style="width: 1000px;height:200px" src="Image\sregex_iterator1.png">

   <img style="width: 1000px;height:300px" src="Image\sregex_iterator2.png">

   - `sregex_iterator`来获得所有匹配。`regex`迭代器是一种迭代器适配器,**被绑定到一个输入序列和一个regex对象上**。**每种==不同输入序列类型==都有对应的特殊`regex`迭代器类型**。
   - 当我们将一个`sregex_iterator`绑定到一个`string`和一个`regex`对象时，迭代器自动定位到给定`string` 中第一个匹配位置。即，`sregex_iterator`构造函数对给定`string`和 `regex`调用`regex_search`。当我们==解引用迭代器时，会得到一个对应最近一次搜索结果的`smatch`对象==。当我们递增迭代器时，它调用`regex_search`在输入`string`中查找下一个匹配。

   ```c++
   for(sregex_iterator it(file.begin(),file.end(),r),end_it;
      						it!=end_it;++it)
   {
       auto pos = it->prefix().lenght();//前置的大小
       pos = pos>40?pos-40:0;			//我们想要最多40个字符
       
       cout<<it->prefix().str().substr(pos)	//前置的最后一部分
           <<"\n\t\t>>>"<<it->str()<<"<<<\n"	//匹配的单词
           <<it->suffix().str().substr(0,40)	//后缀的第一部分
           <<endl;
   }
   ```

   - 除了允许打印输入字符串中匹配的部分之外，**匹配结果类还提供了有关匹配结果的更多细节信息**。表17.10和表17.11列出了这些类型支持的操作。

   - **他们允许我们获得匹配的上下文**，匹配类型有==**两个名为`prefix`和`suffix`的成员**==，分别返回表示输入序列中**当前匹配之前和之后部分**的 ==`ssub_match`==对象。**一个`ssub_match`对象有两个名为`str`和 `length`的成员**，分别返回匹配的 `string` 和该`string`的大小。

     <img style="width: 1000px;height:600px" src="Image\smatch炒作.png">

6. 使用子表达式

   - 正则表达式中的模式通常包含**一个或多个子表达式**(subexpression)。一个子表达式是模式的一部分，本身也具有意义。正则表达式语法通常用括号表示子表达式。

     ```c++
     //r有两个子表达式:第一个是点之前表示文件名的部分，第二个表示文件扩展名
     regex r("([[:alnum:]]+)\\.(cpp|cxx|cc)$",regex::icase);
     
     if(regex_search(filename,results,r))
         cout<<results.str(1)<<endl;//打印与第一个子表达式匹配的部分
     ```

   - **匹配对象除了提供匹配整体的相关信息外，还提供访问模式中每个子表达式的能力。子匹配是按位置来访问的。第一个子匹配位置为0，表示整个模式对应的匹配，随后是每个子表达式对应的匹配。**因此，本例模式中第一个子表达式，即表示文件名的子表达式，其位置为1，而文件扩展名对应的子表达式位置为2。

     - 例如，如果文件名为`foo.cpp`，则 `results.str(0)`将保存`foo.cpp` ;`results.str(1)`将保存`foo`;而`results.str(2)`将保存`cpp`。

7. 子表达用于数据验证

   - `\{d}`表示单个数字而`\{d}{n}`则表示一个`n`个数字的序列。(如，`\{d){3}`匹配三个数字的序列。)

   - 在**方括号中的字符集合表示匹配这些字符中任意一个**。(如，`[-. ]`匹配一个短横线或一个点或一个空格。注意,点在括号中没有特殊含义。)

   - 后接`'?'`的组件是可选的。(如，\{d}{ 3}[-.  ]?\{d} {4}匹配这样的序列:开始是三个数字，后接一个可选的短横线或点或空格，然后是四个数字。此模式可以匹配555-0132或555.0132或555 0132或5550132。)

   - 类似C++，ECMAScript 使用**反斜线表示一个字符本身而不是其特殊含义**。由于我们的模式包含括号，而**括号是ECMAScript 中的特殊字符,**因此我们必须用`\(`（和`\)`**来表示括号是我们的模式的一部分而不是特殊字符**。

     ```c++
     //整个正则表达式包含七个子表达式:( ddd )分隔符ddd分隔符dddd
     //子表达式1、3、4和6是可选的;2、5和7保存号码
     "(\\()?(\\d{3})(\\))?([-. ])?( \\d{3})([-. ]?)(\\d{4})";
     ```

     - `(\\()?`表示区号部分可选的左括号
     - `(\\d{3})`表示区号
     - `(\\))?`表示区号部分可选的右括号
     - `([-. ])?`表示区号部分可选的分隔符
     - `(\\d{3})`表示号码的下三位数字
     - `([-. ])?`表示可选的分隔符
     - `(\\d{4})`表示号码的最后四位数字

8. 使用子匹配操作

   ```c++
   	std::string phone = "(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ]?)(\\d{4})";
   	std::regex r(phone);
   	std::smatch m;
   	std::string s;
   	while (std::getline(std::cin, s))
   	{
   		for (std::sregex_iterator beg(s.begin(), s.end(), r), end_it; beg != end_it; ++beg)
   		{
   			if (valid(*it))cout << "valid:" << it->str() << endl;
   			else cout << "not valid:" << it->str() << endl;
   		}
   	}
   ```

   - 每个`smatch`对象会包含八个`ssub_match`元素。位置`[0]`的元素表示整个匹配;元素`[1]...[7]`表示每个对应的子表达式。当**调用`valid` 时，我们知道已经有一个完整的匹配，但不知道每个==可选的子表达式是否是匹配的一部分==**。**如果一个子表达式是完整匹配的一部分，则其对应的`ssub_match`对象的`matched`成员为`true`。**

   <img style="width: 1000px;height:400px" src="Image\子匹配操作.png">

   ```c++
   bool valid(const smatch &m)
   {
       //如果区号前有一个左括号
       if(m[1].matched)
           //则区号后必须有一个右括号，之后紧跟剩余号码或一个空格
           return m[3].matched&&(m[4].matched==0||m[4].str()==" ");
       else
           //否则，区号后不能有右括号
           //令两个组成部分间的分隔符必须匹配
           return !m[3].matched&&m[4].str()==m[6].str();
   }
   ```

9. 使用`regex_replace`

   <img style="width: 1000px;height:500px" src="Image\正则表达式替换.png">

   - 我们用一个符号`$`后跟子表达的索引号来表示一个特定的子表达式
     - `string fmt = "$2.$5.$7";`将号码格式改为`ddd.ddd.dddd`

10. 只替换输入序列的一部分

    - **正确匹配的会被替换**，没有匹配的不会替换

11. 用来控制匹配和格式的标准

    - 这些值都定义在名为`regex_constants`的命名空间中，`std::regex_constants::`

    <img style="width: 1000px;height:440px" src="Image\匹配标准.png">

    - 默认情况下，`regex replace`输出整个输入序列。未与正则表达式匹配的部分会原样输出;匹配的部分按格式字符串指定的格式输出。我们可以通过在`regex_replace`调用中指定`format no_copy`来改变这种默认行为:

    ```c++
    //通知regex_replace只拷贝它替换的文本
    cout<<regex_replace(s,r,fmt2,format_no_copy)<<endl;
    ```

#### 随机数 

1. 随机数引擎和分布

   <img style="width: 1000px;height:220px" src="Image\随机数引擎操作.png">

   - `default_random_engine e`生成随机无符号数

   - 分布类型和引擎

     - `uniform_int_distribution<unsigend> u(0,9)` 0到9之间均匀分布的随机数

       ```c++
       uniform_int_distribution<unsigned> u(0,9);
       default_random_engine e;
       for(size_t i =0;i<10;++i)
           //将u作为随机数源
       	//每个调用返回在指定范围内并服从均匀分布的值
           cout<<u(e)<<" ";
       ```

     - 类似引擎类型，**分布类型也是函数对象类**。分布类型**定义了一个调用运算符，它接受一个随机数引擎作为参数**。分布对象**使用它的引擎参数生成随机数，并将其映射到指定的分布**。

   - 比较随机数引擎和`rand`函数

     - 调用一个`default_random_engine`对象的输出类似`rand`的输出。随机数引擎生成的`unsigned`整数在一个系统定义的范围内，而`rand` 生成的数的范围在`0`到`RAND_MAX`之间。一个引擎类型的范围可以通过调用该类型对象的`min`和 `max`成员来获得:

   - 引擎生成一数值序列

     - 一个给定的随机数发生器一直会生成相同的随机数序列。**一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象)定义为static的。否则,每次调用函数都会生成相同的序列**。

   - 设置随机数发生器种子

     ```c++
     default_random_engine e1,e2(214),e3,e4(32767);
     e3.seed(32767);//调用seed设置一个新种子值
     ```

     - `e1`和`e2`的种子不同，因此生成不同的序列。`e3`和`e4`有相同的种子，他们将生成相同的序列。
     - 常用的方法是调用系统函数`time`。这个函数定义在头文件 `ctime` 中，**它返回从一个特定时刻到当前经过了多少秒**。**函数`time`接受单个指针参数,它指向用于写入时间的数据结构**。如果此指针为空，则函数简单地返回时间;
     - `default_random_engine e1(time(0));`稍微随机些的种子
     - **如果程序作为一个自动过程的一部分反复运行,将time的返回值作为种子的方式就无效了;它可能多次使用的都是相同的种子。**

2. 其它随机数分布

   - 生成**随机实数**

     - `uniform_real_distribution<double> u(0,1);`

     <img style="width: 1000px;height:220px" src="Image\分布类型的操作.png">

   - 使用分布的默认结果类型

     - **每个分布模板都有一个默认模板实参**。生成浮点值的分布类型默认生成`double`值，而生成整型值的分布默认生成`int`值。
     - `uniform_real_distribution<> u(0,1);`

   - 生成非均匀分布的随机数

     - `normal_distribution`生成浮点值，正太分布的值的序列

     - `cmatch`中的`lround`函数将每个数舍入到最接近的整数。

       ```c++
       default_random_engine e;
       normal_distribution<> n(4,1.5);//均值以4为中心，标准差为1.5
       vector<unsigned> vals(9);
       for(size_t i =0;i!=200;++i)
       {
           unsigned v = lround(n(e));	//舍入到最接近的整张
           if(v<vals.size())			//如果结果在范围内
       		++vals[v];				//统计每个数出现了多少次
       }
       for(size_t j = 0;j!=vals.size();++j)
           cout<<j<<": "<<string(vals[j],'*')<<endll;
       ```

   - `bernoulli_distribution`类

     - `bernoulli_distribution`，因为它是一个普通类，而非模板。此分布总是返回一个`bool`值。它返回`true`的概率是一个常数，此概率的默认值是`0.5`。
     - 由于引擎返回相同的随机数序列,所以我们必须在循环外声明引擎对象。否则，每步循环都会创建一个新引擎，从而每步循环都会生成相同的值。类似的，分布对象也要保持状态，因此也应该在循环外定义。
     - `bernulli_distribution`允许我们调整选择先行一方的概率
       - `bernulli_distribution b(.55);` 给程序一微小的优势

#### IO库再探

1. 格式化输入与输出

   - 标准库定义了一组**操纵符**来修改流的格式状态。一个操纵符是**一个函数或是一个对象，会影响流的状态**，**并能用作输入或输出运算符的运算对象**。类似输入和输出运算符，**操纵符也返回它所处理的流对象，因此我们可以在一条语句中组合操纵符和数据**。

     - `endl`：输出一个换行符并刷新缓冲区

   - 很多操作符改变格式状态

     - 操纵符用于**两大类输出控制**:**控制数值的输出形式**以及**控制补白的数量和位置**。大多数改变格式状态的操纵符都是**设置**/**复原**成对的;一个操纵符用来将格式状态设置为个新值，而另一个用来将其复原，恢复为正常的默认格式。
       - **当操作符改变流的格式状态时，通常改变后的状态对所有后续IO都生效。**

   - 控制布尔值的格式

     - `boolaphal`操作符：一个`true`值输出为整数`1`而`false`输出为`0`
     - `noboolalpha`将流恢复到初始状态

   - 指定整形值的进制

     - `hex`，`oct`和`dec`将流设置为十六进制，八进制或者改回十进制。这些操作符影响下一个和随后所有的整形输出，直至另一个操作符又改变了格式为止。
     - **操纵符hex、oct 和dec只影响整型运算对象,浮点值的表示形式不受影响。**

   - 在输出中指出进制

     - 当对流使用`showbase` 操纵符时，会在输出结果中显示进制，它遵循与整型常量中指定进制相同的规范:
       - 前导Ox表示十六进制。
       - 前导0表示八进制。
       - 无前导字符串表示十进制。
     - `std::cout<<std::showbase`
       - `noshowbase`恢复`cout`的状态
     - `uppercase`输出大写的`X`并将十六进制数字`a-f`以大写输出。
       - `nouppercase`重置流的状态

   - 控制浮点数格式

     - 我们可以控制**浮点数输出三个种格式**:
       - 以多**高精度（多少个数字）打印浮点值**
       - 数值是打印为**十六进制**、**定点十进制**还是**科学记数法形式**
       - 对于没有**小数部分的浮点值是否打印小数点**
     - **默认情况下**，浮点值按六位数字精度打印;如果浮点值没有小数部分，则不打印小数点;根据浮点数的值选择打印成定点十进制或科学记数法形式。标准库会选择一种可读性更好的格式:非常大和非常小的值打印为科学记数法形式，其他值打印为定点十进制形式。

   - 指定打印精度

     - 浮点值按当前精度舍入而非截断

     ```c++
     cout.precision();//返回当前精度值
     cout.precision(10);//将精度设置为此值，并返回旧精度值
     
     cout<<setprecision(3); //设置精度为3
     ```

     - 操纵符`setprecision`和其**他接受参数的操纵符都定义在头文件 `iomanip`中。**

     <img style="width: 1000px;height:220px" src="Image\操纵符.png">

     <img style="width: 1000px;height:700px" src="Image\操纵符2.png">

   - 指定浮点数记数法

     - `defaultfloat`将流恢复到默认状态，**根据要打印的值选择记数法**。
     - 执行`scientific`，`fixed`或`hexfloat`后，**精度值控制的是==小数点后面的数字位数==**，而**默认情况下精度值指定的是数字的总位数**——既包括小数点之后的数字也包括小数点之前的数字。

   - 打印小数点

     - 默认情况下，**当一个浮点值的小数部分为0时，不显示小数点**。`showpoint`操纵符强制打印小数点:
     - `noshowpoint`恢复默认行为。

   - 输出补白

     - `setw`指定下一个数字或字符串值的最小空间。
     - `left`表示左对齐输出。
     - `right`表示右对齐输出，**右对齐是默认格式。**
     - `internal`控制负数的符号的位置，它左对齐符号，右对齐值，用空格填满所有中间空间。
     - `setfill`允许指定一个字符代替默认的空格来补白输出。

     ```c++
     	int i = -16;
     	double d = 3.14159;
     	//补白第一列，使用输出中最小12个位置
     	cout <<"i: "<< setw(12) << i << " next col" <<'\n'
     		 <<"d: "<< setw(12) << d << " next col" <<'\n';//补白第一列，左对齐所有列
     	cout << left
     		<< "i: "<< setw(12)<< i << " next col" <<'\n' 
     		<< "d: "<< setw(12)<< d << " next col" <<'\n' << right;//恢复正常对齐
     		//补白第一列，右对齐所有列
     	cout << right
     		<< "i: " << setw(12) << i << " next col" << '\n'
     		<< "d: " << setw(12) << d << " next col" << '\n';//补白第一列，但补在域的内部
     	cout << internal
     		<< "i: " << setw(12) << i << " next col" << '\n'
     		<< "d: " << setw(12) << d << " next col" << '\n';//补白第一列，用#作为补白字符
     	cout << setfill('#')
     		<< "i: " << setw(12)<< i << " next col" << '\n'
     		<< "d: " << setw(12) << d << " next col" << '\n'
     		<< setfill(' ');//恢复正常的补白字符
     
     ```

   <img style="width: 1000px;height:220px" src="Image\iomanip.png">

   - 控制输入格式
     - **默认情况下，输入运算符会忽略空白符(空格符、制表符、换行符、换纸符和回车符)。**
     - `noskipws`令输入运算符读取空白符、`skipws`恢复默认行为

2. 未格式化的输入/输出操作

   - 单字节操作

     ```c++
     char ch;
     while(cin.get(ch))
         cout.put(ch);
     ```

     - 此程序**保留输入中的空白符**，其输出与输入完全相同。它的执行过程与前一个使用`noskipws`的程序完全相同。

     <img style="width: 1000px;height:220px" src="Image\单字节的底层IO操作.png">

   - 将字符放回输入流

     - `peek` 返回输入流中下一个字符的副本，但不会将它从流中删除，`peek`返回的值仍然留在流中。
     - `unget` 使得输入流向后移动，从而最后读取的值又回到流中。即使我们不知道最后从流中读取什么值，仍然可以调用`unget`。
       - **不需要指定字符**，它会自动把**上一次读取的字符**放回流。
     - `putback`是更特殊版本的`unget`:它退回从流中读取的最后一个值，**但它接受一个参数，此参数必须与最后读取的值相同。**

   - 从输入操作返回的`int`值

     - 函数`peek`和无参的`get`版本都以`int`类型从输入流返回一个字符。
     - ==**返回`int`的函数将它们要返回的字符先转换为`unsigned char`，然后再将结果提升到 `int`**。==因此，即使字符集中有字符映射到负值，这些操作返回的`int`也是正值。而==**标准库使用负值表示文件尾，这样就可以保证与任何合法字符的值都不同。头文件 `cstdio`定义了一个名为`EOF`的`const`，我们可以用它来检测从`get`返回的值是否是文件尾**，==而不必记忆表示文件尾的实际数值。

     ```c++
     int ch;
     while((ch=cin.get())!=EOF)
         cout.put(ch);
     ```

   - 多字节操作

     

     <img style="width: 1000px;height:120px" src="Image\多字节IO操作2.png">

     - **一个常见的错误是本想从流中删除分隔符，但却忘了做**
     - `getline`：若读取的字符数达到指定上限时仍未遇到分节符，则`getline`会将流的状态置为`fail`

   - 确定读取了多少个字符

     - 应该在任何**后续**未格式化**输入**操作之前调用`gcount`。特别是，将字符退回流的单字符操作也属于未格式化输入操作。

       - 如果在调用`gcount`之前调用了`peek`、 `unget`或`putback`，则`gcount`的返回值为`0`。

       ```c++
       	char buffer[16]{};
       	std::ifstream in("D:\\Project\\VS\\C&C++\\C++Primer\\main\\words.txt");
       	if (!in.is_open())	std::cerr<<"open file failed"<<std::endl;
       	while (!in.eof())
       	{
       		in.getline(buffer, sizeof buffer);//默认dilm是'\n'
       		std::cout << buffer;
       
       		if (!in.good())//缓冲区读满，也没读到'\n'
       		{
       			if (in.gcount() == sizeof buffer - 1)//最后一个字符存放\0
       				in.clear();
       			else
       				break;
       		}
       		else std::cout.put('\n');//缓冲区没满，说明读完了当前行
       	}
       ```

3. 随机流访问

   - **==随机IO本质上是依赖于系统的==。为了理解如何使用这些特性，你必须查询系统文档。**

   - 虽然标准库为所有流类型都定义了`seek`和`tell`函数，但它们是否会做有意义的事情依赖于流绑定到哪个设备。在大多数系统中，绑定到`cin`、`cout`、`cerr`和`clog`的流不支持随机访问---毕竟，当我们向`cout`直接输出数据时，类似向回跳十个位置这种操作是没有意义的。对这些流我们可以调用`seek`和`tell`函数，但在运行时会出错，将流置于一个无效状态。

   - **由于`istream`和 `ostream`类型通常不支持随机访问，所以本节剩余内容只==适用于`fstream`和` sstream`类型。==**

   - `seek`和`tell`函数

     - 为了支持随机访问,**IO 类型维护一个标记来确定==下一个读写操作==要在哪里进行**。**它们还提供了两个函数:一个函数通过将标记`seek` 到一个给定位置来重定位它:另一个函数`tell`我们标记的当前位置**。标准库实际上定义了两对`seek`和`tell`函数,如表17.21所示。**一对用于输入流，另一对用于输出流**。输入和输出版本的差别在于名字的后缀是`g`还是`p`。`g`版本表示我们正在“获得”(读取）数据，而`p`版本表示我们正在“放置”(写入）数据

     <img style="width: 1000px;height:420px" src="Image\seek和tell函数.png">

     - 从逻辑上讲，我们只能对`istream`和派生自`istream`的类型`ifstream`和`istringstream`使用`g`版本，
     - 同样只能对`ostream`和派生自`ostream` 的类型`ofstream`和 `ostringstream`使用`p`版本。
     - 一个 `iostream`、`fstream`或`stringstream`既能读又能写关联的流，因此对这些类型的对象既能使用g版本又能使用p版本。

   - 只有一个标准

     - **由于只有单一的标记,因此只要我们在读写操作间切换,就必须进行`seek` 操作来重定位标记。**

   - 重定位标记

     ```c++
     //将标记移动到一个固定位置
     seekg(new_position);//将读标记移动到指定的pos_type类型的位置
     seekp(new_position);//将写标记移动到指定的pos_type类型的位置
     
     //移动到给定起始点之前或之后指定的偏移位置
     seekg(offset,from);//将读标记移动到距from偏移量为offset的位置
     seekp(offset,from);//将写标记移动到距from偏移量为offset的位置
     ```

     - `new_position`类型为`pos_type`，头文件`istream`，表示一个文件位置
     - `offset`类型为`off_type`，头文件`ostream`，而`off_type`表示距当前位置的一个偏移量。一个`off_type`类型的值可以是正的也可以是负的，即，我们可以在文件中向前移动或向后移动。

   - 访问标记

     - **函数`tellg`和`tellp`返回一个`pos_type`值，表示流的当前位置。`tell`函数通常用来记住一个位置，以便稍后再定位回来。**

   - 读写同一个文件

     - 第一行的偏移总是从位置0开始。统计偏移量时必须包含每行末尾不可见的换行符。


### 用于大型程序的工具

#### 异常处理

1. 抛出异常

   - 栈展开过程中对象被自动销毁

     - 如果**异常发生在构造函数中，则当前的对象可能只构造了一部分。有的成员已经初始化了，而另外一些成员在异常发生前也许还没有初始化。即使某个对象只构造了一部分，我们也要确保已构造的成员能被正确地销毁**。

     - 类似的，**异常也可能发生在数组或标准库容器的元素初始化过程中。与之前类似,如果在异常发生前已经构造了一部分元素，则我们应该确保这部分元素被正确地销毁。**

   - 析构函数与异常

     - 出于栈展开可能使用析构函数的考虑，析构函数不应该抛出不能被它自身处理的异常。换句话说，**如果析构函数需要执行某个可能抛出异常的操作，则该操作应该被放置在一个try语句块当中，并且在析构函数内部得到处理。**
     - 在实际的编程过程中，因为析构函数仅仅是释放资源，所以它不太可能抛出异常。所有标准库类型都能确保它们的析构函数不会引发异常。

   - 异常对象

     - 异常对象是一种特殊的对象，编译器使用**异常抛出表达式来对异常对象进行拷贝初始化**。因此，`throw`**语句中的表达式必须拥有完全类型**（参见7.3.3节，第250页)。而且如果该**表达式是类类型**的话，则相应的类必须含有一个**可访问的析构函数和一个可访问的拷贝或移动构造函数**。如果**该表达式是数组类型或函数类型，则表达式将被转换成与之对应的指针类型**。
     - **异常对象位于由编译器管理的空间中**，编译器确保无论最终调用的是哪个`catch`子句都能访问该空间。当异常处理完毕后，异常对象被销毁。
     - 当一个异常被抛出时，沿着调用链的块将依次退出直至找到与异常匹配的处理代码。如果退出了某个块，则同时释放块中局部对象使用的内存。因此，**抛出一个指向局部对象的指针几乎肯定是一种错误的行为**。出于同样的原因，从函数中返回指向局部对象的指针也是错误的。如果指针所指的对象位于某个块中，而该块在`catch`语句之前就已经退出了，则意味着在执行`catch` 语句之前局部对象已经被销毁了。
     - 当我们抛出一条表达式时，该表达式的**==静态编译时类型==决定了异常对象的类型**。**读者必须牢记这一点**，**因为很多情况下程序抛出的表达式类型来自于某个继承体系**。**如果一条`throw`表达式解引用一个基类指针，而该指针实际指向的是派生类对象，则抛出的对象将被切掉一部分**，只有基类部分被抛出。

2. 捕获异常

   - `catch`子句中的异常声明看起来像是只包一个形参的函数形参列表。像在形参列表中一样，如果 `catch` 无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。
     - 声明的类型决定了处理代码所能捕获的异常类型。**这个类型必须是完全类型，它可以是左值引用**，但不能是右值引用。
     - 如果`catch`的**参数类型是非引用类型**,**则该参数是异常对象的一个副本**，在`catch`语句内改变该参数实际上改变的是局部副本而非异常对象本身，相反，**如果参数是引用尖型，则和其他引用参数一样，该参数是异常对象的一个别名**，比时改变参数也就是改变异常对象。
     - `catch` 的参数还有一个特性也与函数的参数非常类似如果`catch`的**参数是基类类型**，**则我们可以使用其派生类类型的异常对象对其进行例始化**。**此时，如果`catch`的参数是非引用类型，则异常对象将被切掉于部分**，这与将派生类对象以值传递的方式传给一个普通函数差不多，另一方面**，如果 `catch` 的参数是基类的引用,则该参数将以常规方式绑定到异常对象上**。
       - 参数是引用也只能访问基类部分。
   - 查找匹配的处理代码
     - **在搜寻catch 语句的过程中，我们最终找到的catch未必是异常的最佳匹配。相反,挑选出来的应该是第一个与异常匹配的catch语句。==因此、越是专门的catch 越应该置于整个catch列表的前端==**
     - **因为 catch语句是==按照其出现的顺序逐一进行匹配的==，所以当程序使用具有继承关系的多个异常时必须对catch语句的顺序进行组织和管理，使得派生类异常的处理代码出现在基类异常的处理代码之前**。
     - 与实参和形参的匹配规则相比，**异常和 catch异常声明的匹配规则受到更多限制。此时，绝大多数类型转换都不被允许，除了一些极细小的差别之外，要求异常的类型和catch声明的类型是精确匹配的**:
       - **允许从非常量向常量的类型转换**，也就是说，一条非常量对象的throw语句可以匹配一个接受常量引用的catch 语句。
       - **允许从派生类向基类的类型转换**。
       - **数组被转换成指向数组(元素)类型的指针，函数被转换成指向该函数类型的指针**。
   - 重新抛出
     - 

#### 命名空间

#### 多重继承与虚继承







