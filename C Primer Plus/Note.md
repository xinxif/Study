### C语言的概述

语言与命名规则

以前的C语言，还要求把变量声明在块的顶部，其它语句不能放在任何声明的前面。

```c
  int main()
    {
        int doors;//旧规则
        int dogs;
        doors=5
        dogs=3;
      	//其它语句
      
      	//c99和c11遵循c++的惯例，可以把声明放在块中的任何位置。
    }
```

C99和C11允许使用更长的**标识符名**， 但是**编译器只识别前63个字符**。对于**外部标识符**（参阅第12章）， 只允许使用**31个字符**。实际上， 你可以使用更长的字符， 但是编译器会忽略超出的字符。**小写字母、 大写字母、 数字和下划线（＿）来==命名==**。 而且， 名称的**第1个字符必须是字符或下划线**， ==不能是数字== 。操作系统和C库经常使用以一个或两个下划线字符开始的标识符（如， `＿kcab`)，因此最好避免在自己 的程序中使用这种名称。C语言的名称区分大小写。

C语言关键字中，**粗体表示的是C90标准新增的关键字**，**斜体**表示的C99标准新增的关键字，**粗斜体**表示的是C11标准新增的关键字

|    auto     |   extern   |     short      |         while          |
| :---------: | :--------: | :------------: | :--------------------: |
|   `break`   |  `floa`t   |  **`signed`**  |    ***`_Alignas`***    |
|   `case`    |   `for`    |    `sizeof`    |    ***`_Alignof`***    |
|   `char`    |   `goto`   |    `static`    |    ***`_Atomic`***     |
| **`const`** |    `if`    |    `struct`    |     ***`_Bool`***      |
| `continue`  |  `inline`  |    `switch`    |    ***`_Complex`***    |
|  `default`  |   `int`    |   `typedef`    |    ***`_Generic`***    |
|    `do`     |   `long`   |    `union`     |   ***`_Imaginary`***   |
|  `double`   | `register` |   `unsigned`   |   ***`_Noreturn`***    |
|   `else`    | `restrict` |     `void`     | ***`_static_assert`*** |
| **`enum`**  |  `return`  | **`volatile`** | ***`_Thread_local`***  |

----

### 数据和C



1. 数据类型和关键字

   - 在`printf()`中使用**`%f`**来**处理浮点值**。%.2f中的**.2 用于精确控制输出**，指定输出的浮点数只显示小数点后面两位。
   - `char`类型也可以表示较小的整数。
   - `_Bool`类型表示布尔值（`true`或`false`），`_complex`和`_Imaginary`分别表示复数和虚数。

2. 整数和浮点数

   - ==注意==，在一个值后面加上一个小数点，该值就成为一个浮点值。

   - 对于一些算术运算（如，两个很大的数相减），**浮点数损失的精度更多** 因为在**任何区间内**（如，1.0 到 2.0 之间）**都存在无穷多个实数**，所以计算机的**浮点数不能表示区间内所有的值**。浮点数通常只是实际值的近似值。例如，7.0可能被储存为浮点值6.99999。
     
   - C 初始化变量的三种方式

     ```c
  int erns;
     int hogs, cows, goats;
     cows = 112;
     
     //通过函数（如，scanf()）获得值。
     
     int hogs = 21;
     int cows = 32, goats = 14;
     int dogs, cats = 94; /* 有效，但是这种格式很糟糕 */
     ```
   
   - 声明为变量创建和标记存储空间，初始化则是为变量赋值，没有初始化的变量的值将会是未定义的垃圾值。

   - 0x或0X前缀表示十六进制值，0前缀表示八进制，**十进制**显示数字，使用`%d`，**八进制**显示数字，使用`%o`，以**十六进制**显示数字，使用`%x`。**显示**各进制数的**前缀**0、0x和0X，必须分别使用`%#o、%#x、%#X`

3. 其它整数类型

   - `short int`类型（或者简写为`short`）的存储空间可能比`int`类型少
   - `long int`或`long`占用的存储空间可能比`int`多
   - `long long int`或`long long`占用的储存空间可能比`long`多，该类型至少占64位。
   - `unsigned int`或`unsigned`只用于非负值的场合
   - 在**C90标准**中，添加了`unsigned long int`或`unsigned long`和`unsigned in`t或`unsigned short`类型。C99标准又添加了`unsigned long long int`或`unsigned long long`。
   - 在任何**有符号类型前**面添加关键字**`signed`**，可**强调使用有符号类型**的意
     图
   - C语言只规定了`short`占用的**存储空间不能多**于`int`，`long`占用的**存储空间不能少于**`int`。
   - **对于那些`long`占用的空间比`int`大的系统，使用`long`类型会减慢运算速度。**如果在**`long`类型和`int`类型占用空间相同的机器上编写代码**，当确实需要32位的整数时，**应使用`long`类型而不是`int`类型**，以便把程序移植到16位机后仍然可以正常工作。
   - 如果在`int`设置为32位的系统中要使用16位的值，应使用short类型以节省存储空间。通常，只有当程序使用相对于系统可用内存较大的整型数组时，才需要重点考虑节省空间的问题。使用short类型的另一个原因是，计算机中某些组件使用的硬件寄存器是16位。
   - 要把一个较小的**常量作为long类型**对待，值的**末尾加上l（小写的L）或L后缀**。也可用于**八进制和十六进制**整数，如*020L和0x10L*。支持`long long`类型的系统中，也可以使用**ll或LL**后缀来表示long long类型的值，如3LL。另外，**u或U后缀**表示`unsigned long long`，如5llu、10LLU、6LLU或9Ull。

4. 打印`short`、`long`.`long long`和`unsigned`类型

   - 打印`unsigned int %u`
   - 打印`long %ld `
   - 在`x`和`o`前面可以使用`l`前缀，`%lx`表示以十六进制格式打印`long`类型整数，`%lo`表示以八进制格式打印`long`类型整数。**转换说明中只能用小写**。
   - 打印`short %hd`表示以**十进制**显示`short`类型，`%ho`表示以**八进制**显示short类型。`h`和`l`前缀都可以和`u`一起使用，用于表示无符号类型。例如，`%lu`表示打印`unsigned long`。对于支持`long long`类型的系统，`%lld`和`%llu`分别表示有符号和无符号类型
   - 必须**确保转换说明**的==数量==和**待打印值的数量相同**，**须根据待打印值的类型使用正确的转换说明**。

5. `char`类型

   - 字符常量初始化`char grade = 'A'`;C语言中，用**单引号**括起来的**单个字符**被称为**字符常量**。**字符是以数值形式储存的**，所以也可使用数字代码值来赋值`char grade = 65`;
   - C语言将**字符常量视为int类型而非char类型**字符常量的这种特性，可以定义一个字符常量'FATE'，即把4个独立的8位ASCII码储存在一个32位存储单元中如果把这样的字符常量赋给char类型变量grade，只有最后8位有效。
   - 把**转义序列赋给字符变量**时，必须用**单引号把转义序列括起来**`char nerf = '\n';`

   | 转义序列 | 含义                                                    |
   | -------- | ------------------------------------------------------- |
   | `\a`     | 警报                                                    |
   | `\b`     | 退格                                                    |
   | `\f`     | 换页                                                    |
   | `\n`     | 换行                                                    |
   | `\r`     | 回车                                                    |
   | `\t`     | 水平制表符                                              |
   | `\v`     | 垂直制表符                                              |
   | `\\`     | 反斜杠(\)                                               |
   | `\'`     | 单引号                                                  |
   | `\"`     | 双引号                                                  |
   | `\?`     | 问号                                                    |
   | `\0oo`   | 八进制值(`oo`为有效的八进制值，每个o表示一个数值) `007` |
   | `\xhh`   | 十六进制(`hh`为有效的十六进制值，每个o表示一个数值)     |

   - `printf()`函数用==`%c`指明待打印的字符==。
   - `_Bool` 布尔值，即逻辑值`true`和`false`

6. 可移植类型 `stdint.h inttypes.h`

   - C99 新增了两个头文件`stdint.h`和`inttypes.h`，以确保C语言的类型在各系统中的功能相同。
   - C语言为现有类型创建了更多类型名。类型名定义在`stdint.h`,`int32_t`表示32位的有符号整数类型。***int32_t表示整数类型的宽度正好是32位。但是，计算机的底层系统可能不支持***
   - **最小宽度类型**。`int_least8_t`是**可容纳8位有符号整数值的类型中宽度最小的类型的一个别名**
   - 最快最小宽度类型`int_fast8_t`被定义为系统中对8位有符号值而言运算最快的整数类型的别名。
   - 最大的有符号整数类型`intmax_t`，`unitmax_t`表示最大的无符号整数类型
   - 打印`int32_t`类型的值，`inttypes.h`头文件中定义了`PRId32`字符串宏，代表打印32位有符号值的合适转换说明

7. `float double long double`

   - 1.0e9表示1.0x10^9^
   - C只保证long double类型至少与double类型的精度相同。
   - **浮点数的声明**：`2.87e-3`。==可以没有小数点==（如，2E5）==或指数部分==（如，19.28），但是**不能同时省略两者**。**不要在浮点型常量中间加空格**。
   - **编译器**假定**浮点型常量**是**double**类型的精度。加上**f或F后缀可覆盖默认设置**。使用l或L后缀使得数字成为long double类型
   - C99 标准添加十六进制表示浮点型常量 `0xa.1fp10`  **用p和P分别代替e和E**

8. `long` 打印浮点值

   - `printf()`函数使用`%f `打印十进制记数法的`float`和`double`，`%e`打印指数记数法的浮点数，如果系统支持十六进制格式的浮点数，可用`a`和`A`分别代替`e`和`E`，打印`long double`类型要使用`%Lf`、`%Le`或`%La`。
   - **未在函数原型中**显式**说明参数类型**的函数**传递参**数时，**C编译器**会把**float**类型的值**自动转换成double**类型
   - 特殊的浮点值`NaN`（not a number的缩写）

9. 复数和虚数

   - 3种复数类型：`float_Complex`、`double_Complex`和`long double _Complex`。
   - 3种虚数类型：`float_Imaginary`、`double _Imaginary`和`long double _Imaginary`
   - 包含`complex.h`头文件，便可用`complex`代替`_Complex`，用`imaginary`代替`_Imaginary`，还可以用`I`代替`-1`的平方根

10. 缓冲区刷新

    - 标准明确规定了**何时把缓冲区**中的内容**发送到屏幕**：**当缓冲区
      满**、遇到**换行字符**或需要**输入**，`fflush()`主动刷新缓冲区

### 格式化输入输出

1. `string.h` 提供`strlen()`函数的原型，==**使用%s转换说明来处理字符串的输入和输出**==。*双引号*仅告知编译器它括起来的是*字符串*，正如*单引号*用于标识*单个字符*一样。**根据`%s`转换说明，`scanf()`只会读取字符串中的一个单词**，而不是一整句。

2. C中的**字符串**一定以**空字符结束**，其ASCII码值是（或等价于）0，**数组的容量必须至少比待存储字符串中的字符数多1**。

3. `strlen()`得出字符串中的字符数(不包括空字符)

4. `sizeof `使用圆括号，圆括号的使用时机否取决于运算对象是**类型**(`sizeof(char)`)还是**特定量**(`sizeof name`)

5. 常量和C预处理器

   - `#define TAXRATE 0.015` 编译程序时，程序中所有的TAXRATE都会被替换成0.015。这一过程被称为编译时替换。这样定义的常量也称为**明示常量**。

6. ==%1.2f表明，结果被四舍五入为两位小数输出==

7. C头文件`limits.h`和`float.h`分别提供了与**整数类型**和**浮点类型大小限制相**
   **关的详细信息。**

   | 明示常量       | 含义                                            |
   | -------------- | ----------------------------------------------- |
   | CHAR_BIT       | char类型的位数                                  |
   | SCHAR_MAX      | signed char类型的最大值                         |
   | UCHAR_MIN      | unsigned char类型的最小值                       |
   | USHRT_MAX      | unsigned short类型的最大值                      |
   | FLT_MANT_DIG   | float类型的尾数位数                             |
   | FLT_DIG        | float类型的最少有效数字位数                     |
   | FLT_MIN_10_EXP | 带全部有效数字的float类型的最小负指数(以10为底) |
   | FLT_MAX_10_EXP | float类型的最大正指数(以10为底)                 |
   | FLT_MIN        | 保留全部精度的float类型最小正数                 |
   | FLT_MAX        | float类型的最大正数                             |
   | FLT_EPSILON    | 1.00和比1.00大的最小float类型值之间的差距       |

   明示常量名中的**FLT**分别替**换成DBL和LDBL**，即可分别表示**double和long double类型对应的明示常量**。

8. 转换说明及其打印的输出结果

   | 转换说明      | 输出                                                         |
   | ------------- | ------------------------------------------------------------ |
   | `%a/%A`       | 浮点数，十六进制数和p记数法（c99/c11）                       |
   | `%c`          | 单个字符                                                     |
   | `%d`          | 有符号十进制数                                               |
   | `%e/%E`       | 浮点数E计数法                                                |
   | `%g/%G`       | 根据值的不同，自动选着`%`f或`%e/%E`,`%e/%E`格式用于指数小于-4或者大于或等于精度时 |
   | `%i`          | 有符号的十进制数                                             |
   | `%p`          | 指针                                                         |
   | `%s`          | 字符串                                                       |
   | `%u`          | 无符号十进制数                                               |
   | `%x/%X`       | 无符号十六进制数，使用十六进制数0f/0F                        |
   | `%%`          | 打印一个百分号                                               |
   | 标记          | + - 空格 #和0 可以不适应标记或使用多个标记 `%-10d`           |
   | ==**数字**==  | ==最小字段宽度==，如果改字不能容纳待打印的数字或字符串，系统会使用更宽的字段`%4d` |
   | ==**.数字**== | ==精度== 。对于**`%e`，`%E`和`%`f**转换，表示**小数点右边数字的位数**。对于**`%g`和`%G`**转换，表示**有效数字最大位数**。==对于**`%s`**转换==，表示代**打印字符的最大数量**，对于**整型转换**，表示代**打印数字的最小位数**，==如有必要，使用前导0来到达这个位数==。**只使用.表示其后跟随一个0**，所以`$.f`和`%。0f`相同。`%5.2f`打印一个浮点数，字段宽度为5字符，其中小数点后有两位数字。 |
   | `h`           | 表示`short int`或`unsigned short`类型的值                    |
   | `hh`          | `signed char`或`unsigned char `类型的值 `%hhu`               |
   | `j`           | 表示`intmax_t`或`uintmax_t`类型的值                          |
   | `l`           | 表示`long int`或`unsigned int` 类型的值 `%8lu`               |
   | `ll`          | 表示` long long int` 或`unsigned long long int`的值          |
   | `L`           | 表示long double类型的值                                      |
   | `t`           | 表示`ptrdiff_t`类型的值。`ptrdiff_t`是两个指针插值的类型     |
   | z             | 表示`size_t`类型的值。`size_t`是`sizeof`返回的类型           |
   | `-`           | 待打印项左对齐                                               |
   | `+`           | 有符号值若为正，则在值前面显示加号；若为负，则在值前面显示减号 |
   | 空格          | 有符号值若为正，则在值的前面显示前导空格（不显示任何字符）；若为负，则在值前面显示减号。+覆盖一个空格 |
   | `#`           | 把结果转换为另一个形式。如果是`%o`格式，则以`0`开始；如果是`%x`或`%X`格式，则以`0`x或`0X`开始；对于所有的浮点格式，`#`保证了即使后面没有任何数字，也打印一个小数点字符。对于`%`g和`%G`格式，#防止结果后面的`0`被删除 |
   | `0`           | 对于数字格式，用前导0代替空格填充字段宽度。对于**整数格式**，如果**出现-标记**或**指定精度**，**==则忽略该标记==** |

9. **`size_t`**定义成系统使用`sizeof`返回的类型这被称为底层类型

10. 转换说明的含义

    - 转换说明把**以二进制格式储存在计算机中的值转换成一系列字符**（字符串）以便于显示。例如，数字76在计算机内部的存储格式是二进制数01001100。`%d`转换说明将其转换成字符7和6，并显示为76；`%d`的意思是“把给定的值翻译成十进制整数文本并打印出来”。

11. `printf()`函数也有一个返回值，它**返回打印字符的个数**。如果有输出错误，
    `printf()`则返回一个负值（`printf()`的旧版本会返回不同的值）。==**计算针对所有字符数，包括空格和不可见的换行符（\n）。**==

    - ```c
      //不能在双引号括起来的字符串中间断行
      	printf("The printf() function printed %d
      			characters.\n", rv);
      /*C编译器会报错：字符串常量中有非法字符。在字符串中，可以使用\n
      来表示换行字符，但是不能通过按下Enter（或Return）键产生实际的换行
      符。*/
          printf("Here's another way to print a \
      long string.\n");
                 /*用反斜杠（\）和Enter（或Return）键组合来断行。这使得光标移至下一行，而且字符串中不会包含换行符。其效果是在下一行继续输出。但是，下一行代码必须和程序清单中的代码一样从最左边开始。如果缩进该行，比如缩进5个空格，那么这5个空格就会成为字符串的一部分。*/
          printf("Hello, young "　　 "lovers" ", wherever you are.");//：ANSI C引入的字符串连接。在两个用双引号括起来的字符串之
      //间用空白隔开，C编译器会把多个字符串看作是一个字符串
                
      ```

12. `scanf()`

    - ![image-20240908233305446](C:\Users\fate_\AppData\Roaming\Typora\typora-user-images\image-20240908233305446.png)

    - ![image-20240908233331850](C:\Users\fate_\AppData\Roaming\Typora\typora-user-images\image-20240908233331850.png)

    - ![image-20240908233354970](C:\Users\fate_\AppData\Roaming\Typora\typora-user-images\image-20240908233354970.png)

    - 假设`scanf()`根据一个`%d`转换说明读取一个整数。**`scanf()`函数每次读取一个字符**，**跳过所有的空白字符**，直至遇到第1个非空白字符才开始读取。如果下一个**字符是数字**，它便**保存**该数字并读取下一个字符如果遇到一个**非数字字符**，它便**认为读到了整数的末尾**。==然后，`scanf()`把非数字字符放回输入。==

    - 如果使用**字段宽度**，`scanf()`会在**字段结尾或第1个空白字符处停止读取**。如果第1个非空白字符是A而不是数字，会发生什么情况？`scanf()`将停在那里，并把A放回输入中，不会把值赋给指定变量。程序在下一次读取输入时，首先读到的字符是A。如果程序只使用%d转换说明，` scanf()`就一直无法越过A读下一个字符。如果使用带多个转换说明的`scanf()`，**C规定在第1个出错处停止读取输入**。

    - **使用%s 转换说明**，`scanf()`会读取除空白以外的所有字符。`scanf()`跳
      过空白开始读取第 1 个非空白字符，**并保存非空白字符直到再次遇到空白。**
      
    - `scanf()`函数允许把普通字符放在格式字符串中。除空格字符外的普通字符必须与输入字符串严格匹配。`scanf("%d,%d", &n, &m);` 用户必须输入 88,121

    - 格式字符串中的空白意味着跳过下一个输入项前面的所有空白

    - **对于%c，在格式字符串中添加一个空格字符会有所不同**。例如，如果把%c放在格式字符串中的空格后面，`scanf()`便会跳过空格，从第1个非空白字符开始读取。也就是说，`scanf("%c", &ch)`从输入中的第1个字符开始读取，`scanf(" %c", &ch)`则从第1个非空白字符开始读取。

    - `scanf()`函数返回**成功读取的项数**。没有读取任何项且需要读取一
      个数字而用户却输入一个非数值字符串，`scanf()`便返回0。当`scanf()`检测到“文件结尾”时，会返回EOF（`EOF`是`stdio.h`中定义的特殊值，通常用`#define`指令把`EOF`定义为`-1`）

      - ```c
        	int n;
        	printf("Please enter three integers:\n");
        	scanf("%*d %*d %d", &n);//把*放在%和转换字符之间时，会使得scanf()跳过相应的输出项
        	printf("The last integer was %d\n", n);
        ```

13. **字符串**，无论是表示成字符常量还是储存在字符数组中，==**都以一个叫做空字符的隐藏字符结尾。**==

### 运算符，表达式和语句

1. C 的标准**数学库**提供了一个`pow()`函数用于指数运算。例如，`pow(3.5,
   2.2)`返回3.5的2.2次幂）。==**混合整数和浮点数计算的结果是浮点数**==。
2. **求模运算符只能用于整数，不能用于浮点数**。**如果第1个运算对象是负数，那么求模的结果为负数；如果第1个运算对象是正数，那么求模的结果也是正数**。无论何种情况，只要`a`和`b`都是整数值，便可通过**a - (a/b)*b**来计算`a%b`。
3. **递增运算符**和**递减运算符**都有**很高的结合优先级**，只有圆括号的优先级
   比它们高。
4. 在C语言中，**编译器可以自行选择先对函数中的哪个参数求值**。这样做
   提高了编译器的效率，但是如果在函数的参数中使用了递增运算符，就会有
   一些问题。
5. 类型转换
   - 当类型转换出现在表达式时，都是从较小类型转换为较大类型。
   - 在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。
   - 当浮点类型被降级为整数类型时，原来的浮点值会被截断。
   - 强制类型转换运算符`(type)`，例如`(int)1.6`。

### 控制语句：循环

1. 关系运算符也可用来比较浮点数，但是要注意：**比较浮点数时，尽**
   **量只使用<和>**。因为浮点数的舍入误差会导致在逻辑上应该相等的两数却
   不相等。**使用**`fabs()`**函数**（声明在`math.h`头文件中）**可以方便地比较浮点数，**该函数返回一个浮点值的绝对值（即，没有代数符号的值）。

2. 在构建比较是否相等的表达式时，都习惯把常量放在左侧。

3. **关系运算符的优先级比算术运算符（包括+和-）低，比赋值运算符高。**

   - 高优先级组： < <= > >=
   - 低优先级组： == !=
   - 关系运算符的结合律也是从左往右。例，`ex != wye == zee与(ex != wye) == zee`

4. **C99**提供了`stdbool.h`头文件，**该头文件让bool成为_Bool的别名**，而且还
   **把true和false分别定义为1和0的符号常量**。包含该头文件后，写出的代码可
   以与C++兼容，因为C++把bool、true和false定义为关键字。

5. `for`

   ```c
   for (1;2;4)
   {
       3//1仅执行一次 之后的循环为2，3，4
        //可以省略一个或多个表达式（但是不能省略分号），只要在循环中包含能结束循环的语句即可。
        //省略第2个表达式被视为真
        //第1个表达式不一定是给变量赋初值，也可以使用printf()。
   }
   ```

   - **逗号运算符扩展了for循环的灵活性，以便在循环头中包含更多的表达**
   - `for　(ounces　=　1,　cost　=　FIRST_OZ;　ounces　<=　16;　
     ounces++,cost　+=　NEXT_OZ);`

6. `x *= 3 * y + 12 与 x = x * (3 * y + 12) `相同。以上提到的赋值运算符与=的优先级相同，即比+或*优先级低。

7. **逗号运算符**

   - 首先，==它保证了被它分隔的表达式从左往右求值。==（换言之，逗号是一个序列点，所以**逗号左侧项的所有副作用都在程序执行逗号右侧项之前发生**）

8. 可以把字符串储存在char类型的数组中。**如果**`char`**类型的数组末尾包含一个表示字符串末尾的空字符**`\0`，**则该数组中的内容就构成了一个字符串**。

9. 如果把`power()`函数的定义置于`main()`的文件顶部，**就可以省略前置声明**，因为编译器在执行到`main()`之前已经知道power()的所有信息。**但是，这不是C的标准风格。**

### 分支和跳转

1. `getchar()`函数不带任何参数，它从输入队列中返回下一个字符。`putchar()`函数打印它的参数。**只处理字符**。这两个函数通常定义在 `stdio.h`头文件中

2. if else：对于编译器的限制范围，**C99标准要求编译器**最少==**支持127层嵌套**==

3. `ctype.h`头文件中的**字符测试函数**

   | 函数名         | 如果是下列参数时，返回值为真                                 |
   | -------------- | ------------------------------------------------------------ |
   | `isalnum()`    | 字母数字（字母或数字)                                        |
   | `isalpha ( )`  | 字母                                                         |
   | `isblank ()`   | 标准的空白字符（空格、水平制表符或换行符）或任何其他本地化指定为空白的字符 |
   | `iscntrl ()`   | 控制字符，如Ctrl+B                                           |
   | `isdigit ()`   | 数字                                                         |
   | `isgraph ( )`  | 除空格之外的任意可打印字符                                   |
   | `islower ()`   | 小写字母                                                     |
   | `isprint ()`   | 可打印字符                                                   |
   | `ispunct ()`   | 标点符号（除空格或字母数字字符以外的任何可打印字符)          |
   | `isspace()`    | 空白字符（空格、换行符、换页符、回车符、垂直制表符、水平制表符或其他本地化定义的字符） |
   | `isupper()`    | 大写字母                                                     |
   | `isxdigit ( )` | 十六进制数字符                                               |

   | 函数名       | 行为                                                      |
   | ------------ | --------------------------------------------------------- |
   | `tolower ()` | 如果参数是大写字符，该函数返回小写字符;否则，返回原始参数 |
   | `toupper ()` | 如果参数是小写字符，该函数返回大写字符;否则，返回原始参数 |

4. **逻辑运算符的备选拼写**

   | 传统写法 | iso646.h |
   | -------- | -------- |
   | &&       | and      |
   | \|\|     | or       |
   | !        | not      |

   - `!`**运算符的优先级很高**，**比乘法运算符还高**，**与递增运算符的优先级相**
     **同**，**只比圆括号的优先级低**。`&&`**运算符的优先级比**`||`**运算符高**，**但是两者的优先级都比关系运算符低，比赋值运算符高**。
   - ==**`C`保证逻辑表达式的求值顺序是从左往右**==。&&和||运算符都是序列点，所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效。而且，C 保证一旦发现某个元素让整个表达式无效，便立即停止求值。

5. 条件表达式

   - `expression1 ? expression2 : expression3`
   - 如果 expression1 为真，那么整个条件表达式的值与 expression2的值相同；如果expression1为假，那么整个条件表达式的值与expression3的值相同。

6.  `continue`

   - 执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代。如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环。

     ```c
     for (count = 0; count < 10; count++)
     {
     	ch = getchar();
     	if (ch == '\n')
     		continue;
     	putchar(ch);
         //对于for循环，执行continue后的下一个行为是对更新表达式求值，然后是对循环测试表达式求值。
         //执行完continue后，首先递增count，然后将递增后的值和10作比较。
     }
     ```

   - 如果`switch`**语句在一个循环中**，**`continue`便可作为`switch`语句的一部分。**这种情况下，就像在其他循环中一样，continue让程序跳出循环的剩余部分，包括switch语句的其他部分。

   - `expression`和`case`标签都必须是整数值（包括char类型），标签必须是常量或完全由常量组成的表达式。

7. `go to` 

   ```c
   part: a = 10;
   goto part;
   //C程序员可以接受一种goto的用法——出现问题时从一组嵌套循环中跳出（一条break语句只能跳出当前循环）
   
   ```
   



### 字符输入/输出和输入验证

1. 缓冲区
   - 缓冲分为两类：**完全缓冲I/O**和**行缓冲I/O**。完全缓冲输入指的是当缓冲
     区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入
     中。缓冲区的大小取决于系统，常见的大小是 512 字节和 4096字节。行缓冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区。
   - 为支持==**无缓冲输入**==提供一系列特殊的函数，其原型都在**`conio.h`**头文件中。
     - ANSI C和后续的C标准都规定==**输入是缓冲的**==。
     - **回显无缓冲输入**的`getche()`函数和用于**无回显无缓冲输入**的`getch()`函数（回显输入意味着用户输入的字符直接显示在屏幕上，**无回显输入意味着击键后对应的字符不显示**）
     - **UNIX系统使用另一种不同的方式控制缓冲**。在UNIX系统中，可以使用`ioctl`()函数（该函数属于UNIX库，但是不属于C标准）指定待输入的类型，然后用`getchar()`执行相应的操作。
     - **ANSI没有提供调用无缓冲输入的标准方式**
   - 无论操作系统实际使用何种方法**检测文件结尾**，在C语言中，用`getchar()`读取文件检测到文件结尾时将返回**一个特殊的值**，即==**EOF**==（end of file的缩写）。`scanf()`函数检测到文件结尾时也返回EOF。`#define EOF (-1)`
     - 为什么是-1？因为`getchar()`函数的返回值通常都介于0～127，这些值对**应标准字符集**。但是，如果系统能识别扩展字符集，该函数的返回值可能在0～255之间。无论哪种情况，**-1都不对应任何字符，所以，该值可用于标记文件结尾。**
   - `echo_eof < words  <`符号是UNIX和DOS/Windows的重定向运算符。该运算符使words文件与stdin流相关联，把文件中的内容导入`echo_eof`程序。
   - 通常，==**系统使用行缓冲输入**==，即**当用户按下 Enter 键后输入才被传送给程序**。==**按下Enter键也传送了一个换行符**==，编程时要注意处理这个换行符。
   - 通过标准I/O包中的一系列函数，`getchar()`和` scanf()`函数也属于这一系列。当检测到文件结尾时，这两个函数都返回 EOF

### 函数

1. ANSI C**要求在每个变量前都声明其类型**。也就是说，不能像普通变量声明那样使用同一类型的变量列表。`void dubs(int x, int y, int z)`

   - 接受ANSI C之前的形式，但是将其视为废弃不用的形式：

     ```c
     void dibs(x,y,z)
     int x,y,z;
     {
         //当前的标准正逐渐淘汰 ANSI 之前的形式。读者应对此有所了解，以便能看懂以前编写的程序。
         //ANSI C也接受过去的声明函数形式，即圆括号内没有参数列表：void show_n_char();这种形式最终会从标准中剔除。
     }
     ```

   - 当函数接受参数时，函数原型用逗号分隔的列表指明参数的数量和类型。==**根据个人喜好，你也可以省略变量名**==。

   - `return;`**这条语句会导致终止函数，并把控制返回给主调函数。**因为 return 后面没有任何表达式，所以没有返回值，**只有在void函数中才会用到这种形式。**

   - 我们把函数的前置声明放在主调函数外面。当然，也可以放在主调函数里面。

   - `#include "hotels.h"`指令中的双引号表明被包含的文件位于当前目录中（通常是包含源代码的目录）

2. 声明指针

   ```c
   int *pi; // pi是指向int类型变量的指针
   		 //星号（*）表明声明的变量是一个指针。int * pi;声明的意思是pi是一个指针，*pi是int类型
   ```


### 数组和指针

1. 数组的初始化
   - `int powers[8] = {1,2,4,6,8,16,32,64};`**不支持ANSI的编译器**会
     把这种形式的初始化识别为**语法错误**，在数组声明前加上关键字static可解
     决此问题。
   - 当初始化列表中的**值少于数组**元素个数时，==编译器会把剩余的元素都初始化为0==。
   - 可以**省略方括号中数字**，让**编译器自动匹配数组大小和初始化列表中的项数**。

2. 指定初始化器
   - `int arr[6] = {0,0,0,0,0,212}; // 传统的语法`
   - 而==**C99规定**==，可以在初始化列表中使用带方括号的下标指明待初始化的元素：`int arr[6] = {[5] = 212}; // 把arr[5]初始化为212`
   - 指定初始化器的**两个重要特性**：
     - 如果指定初始化器后面有更多的值，[4] = 31,30,31，那么后面这些值将被用于初始化指定元素后面的元素。
     - 如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化。

3. 声明数组时只能在方括号中使用**整型常量表达式**。所谓整型常量表达式，是由整型常量构成的表达式。==**`sizeof`表达式被视为整型常量**==但是（与C++不同）**==`const`值不是。==**

   ```c
       const float rain[YEARS][MONTHS] =
           {
               {4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6},
               {8.5,8.2,1.2,1.6,2.4,0.0,5.2,0.9,0.3,0.9,1.4,7.3},
               {9.1,8.5,6.7,4.3,2.1,0.8,0.2,0.2,1.1,2.3,6.1,8.4},
               {7.2,9.9,8.4,3.3,1.2,0.8,0.4,0.0,0.6,1.7,4.3,6.2},
               {7.6,5.6,3.8,2.8,3.8,0.2,0.0,0.0,0.0,1.3,2.6,5.2}
           };
   ```

   - 如果第1个列表中只有10个数，则只会初始化数组第1行的前10个元素，而最后两个元素将被默认初始化为0。

4. **在C中，指针加1指的是增加一个存储单元**。对数组而言，这意味着把加1后的地址是下一个元素的地址，而不是下一个字节的地址。

5. `int *ar`形式和`int ar[]`形式都表示ar是一个指向int的指针。但是，`int ar[]`只能用于声明形式参数。第2种形式（`int ar[]`）提醒读者指针`ar`指向的不仅仅
   一个`int`类型值，还是一个`int`类型数组的元素。

6. ==**C保证在给数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。**==虽然C保证了`marbles + SIZE`有效，但是对`marbles[SIZE]`（即储存在**该位置上**的
   值）**未作任何保证**。

7. 一元运算符***和++的优先级相同**，但==**结合律是从右往左**==，指针与整数相加:可以使用+运算符把指针与整数相加，或整数与指针相加。无论哪种情况，**整数都会和指针所指向类型的大小(以字节为单位)相乘,然后把结果与初始地址相加。**

8. `const`

   1. 指向` const `的指针通常用于函数形参中，表明该**函数不会使用指针改变数据**。只能把非`const`数据的地址赋给普通指针。C标准规定，使用==**非**==`const`标识符修改`const`数据导致的结果是未定义的。
   2. `const`还有其他的用法。例如，可以声明并初始化一个不能指向别处的指针。
   3. 把`const`指针赋给非`const`指针不安全，因为这样==**可以使用新的指针改变`const`指针指向的数据。**==编译器在编译代码时，可能会给出警告，执行这样的代码是未定义的。
   4. C和C++中`const`的用法很相似，但是并不完全相同。**区别之一是，C++允许在声明数组大小时使用`const`整数**，而C却不允许。区别之二是，C++的指针赋值检查更严格。**C++不允许把`const`指针赋给非`const` 指针**。而C则允许这样做，但是如果通过`pl`更改`y`，其行为是未定义的。

9. ==**指向多维数组的指针**==

   1. `int (* pz)[2];//pz指向一个内含两个int类型值的数组`。`pz`声明为**指向一个数组的指针**，该数组内含两个`int`类型值。

   2. `int * pax[2];//pax是一个内含两个指针元素的数组，每个元素都指 向int的指针`

   3. 由于`[]`优先级高，先与`pax`结合，所以`pax`成为一个内含两个元素的数 组。然后*表示`pax`数组内含两个指针。最后，`int`表示`pax`数组中的指针都指向`int`类型的值。因此，这行代码声明了两个指向`int`的指针。而前面有圆括号的版本，*先与`pz`结合，因此声明的是一个指向数组（内含两个`int`类型的值）的指针。

   4. 可以用数组表示法或指针表示法来表示一个数组元素，既可以使用数组 名，也可以使用指针名：

      `zippo[m][n] == *(*(zippo + m) + n)` `pz[m][n] == *(*(pz + m) + n)`

10. 函数和多维数组

   - ```c
     void sum_rows(int ar[][COLS],int rows);
     void sum_cols(int [][COLS],int);
     void sum2d(int(*ar)[COLS],int rows);
     ```

   - 一般而言，声明一个指向N维数组的指针，**只能省略最左边方括号中的值**。`int sum4d(int ar[][12][20][30])`

   - 变长数组

     - ```c
       int quarters=4;
       int regions=5;
       double sales[regions][quarters]; //一个变长数组且变长数组必须是自动储存类别
       int sum2d(int rows,int cols,int ar[rows][cols]);
       //因为ar的声明要使用rows和cols，所以在形参列表中必须在声明ar之前声明这两个形参。
       int sum2d(int,int,int ar[*][*]);
       //c99和c11标准规定，可以省略原型中的形参名，但是在这种情况下，必须使用星号来代替省略的维度。
       ```

     - ==**不能在声明中初始化它们**==。最终，**C11把变长数组作为一个可选特性**，而不是必须强制实现的特性。

     - 变长数组中的变不是指可以修改已创建数组的大小。一旦创建了变长数组，他的大小则保持不变。这里的变指的是：**在创建数组时，可以使用变量指定数组的维度。**

     - 需要注意的是，在**函数定义的形参列表**中声明的**变长数组并未实际创建数组**。和传统的语法类似，变长数组名实际上是一个指针。这说明带变长数组形参的函数实际上是在原始数组中处理数组，因此可以修改传入的数组。

     - ==**C99/C11** 标准==允许在声明变长数组时使用 `const `变量。所以该数组的定
       义必须是声明在块中的自动存储类别数组。

11. 复合字面量

    - `(int [2]){10, 20}`复合字面量也可以省略大小。

### 字符串和字符串函数

1. 

   

   

   

   

   



