### C语言的概述

语言与命名规则

以前的C语言，还要求把变量声明在块的顶部，其它语句不能放在任何声明的前面。

```c
  int main()
    {
        int doors;//旧规则
        int dogs;
        doors=5
        dogs=3;
      	//其它语句
      
      	//c99和c11遵循c++的惯例，可以把声明放在块中的任何位置。
    }
```

C99和C11允许使用更长的**标识符名**， 但是**编译器只识别前63个字符**。对于**外部标识符**（参阅第12章）， 只允许使用**31个字符**。实际上， 你可以使用更长的字符， 但是编译器会忽略超出的字符。**小写字母、 大写字母、 数字和下划线（＿）来==命名==**。 而且， 名称的**第1个字符必须是字符或下划线**， ==不能是数字== 。操作系统和C库经常使用以一个或两个下划线字符开始的标识符（如， `＿kcab`)，因此最好避免在自己 的程序中使用这种名称。C语言的名称区分大小写。

C语言关键字中，**粗体表示的是C90标准新增的关键字**，**斜体**表示的C99标准新增的关键字，**粗斜体**表示的是C11标准新增的关键字

|    auto     |   extern   |     short      |         while          |
| :---------: | :--------: | :------------: | :--------------------: |
|   `break`   |  `floa`t   |  **`signed`**  |    ***`_Alignas`***    |
|   `case`    |   `for`    |    `sizeof`    |    ***`_Alignof`***    |
|   `char`    |   `goto`   |    `static`    |    ***`_Atomic`***     |
| **`const`** |    `if`    |    `struct`    |     ***`_Bool`***      |
| `continue`  |  `inline`  |    `switch`    |    ***`_Complex`***    |
|  `default`  |   `int`    |   `typedef`    |    ***`_Generic`***    |
|    `do`     |   `long`   |    `union`     |   ***`_Imaginary`***   |
|  `double`   | `register` |   `unsigned`   |   ***`_Noreturn`***    |
|   `else`    | `restrict` |     `void`     | ***`_static_assert`*** |
| **`enum`**  |  `return`  | **`volatile`** | ***`_Thread_local`***  |

----

### 数据和C



1. 数据类型和关键字

   - 在`printf()`中使用**`%f`**来**处理浮点值**。%.2f中的**.2 用于精确控制输出**，指定输出的浮点数只显示小数点后面两位。
   - `char`类型也可以表示较小的整数。
   - `_Bool`类型表示布尔值（`true`或`false`），`_complex`和`_Imaginary`分别表示复数和虚数。

2. 整数和浮点数

   - ==注意==，在一个值后面加上一个小数点，该值就成为一个浮点值。

   - 对于一些算术运算（如，两个很大的数相减），**浮点数损失的精度更多** 因为在**任何区间内**（如，1.0 到 2.0 之间）**都存在无穷多个实数**，所以
     计算机的**浮点数不能表示区间内所有的值**。浮点数通常只是实际值的近似
     值。例如，7.0可能被储存为浮点值6.99999。

   - C 初始化变量的三种方式

     ```c
     int erns;
     int hogs, cows, goats;
     cows = 112;
     
     //通过函数（如，scanf()）获得值。
     
     int hogs = 21;
     int cows = 32, goats = 14;
     int dogs, cats = 94; /* 有效，但是这种格式很糟糕 */
     ```

   - 声明为变量创建和标记存储空间，初始化则是为变量赋值，没有初始化的变量的值将会是未定义的垃圾值。

   - 0x或0X前缀表示十六进制值，0前缀表示八进制，**十进制**显示数字，使用`%d`，**八进制**显示数字，使用`%o`，以**十六进制**显示数字，使用`%x`。**显示**各进制数的**前缀**0、0x和0X，必须分别使用`%#o、%#x、%#X`

3. 其它整数类型

   - `short int`类型（或者简写为`short`）的存储空间可能比`int`类型少
   - `long int`或`long`占用的存储空间可能比`int`多
   - `long long int`或`long long`占用的储存空间可能比`long`多，该类型至少占64位。
   - `unsigned int`或`unsigned`只用于非负值的场合
   - 在**C90标准**中，添加了`unsigned long int`或`unsigned long`和`unsigned in`t或`unsigned short`类型。C99标准又添加了`unsigned long long int`或`unsigned long long`。
   - 在任何**有符号类型前**面添加关键字**`signed`**，可**强调使用有符号类型**的意
     图
   - C语言只规定了`short`占用的**存储空间不能多**于`int`，`long`占用的**存储空间不能少于**`int`。
   - **对于那些`long`占用的空间比`int`大的系统，使用`long`类型会减慢运算速度。**如果在**`long`类型和`int`类型占用空间相同的机器上编写代码**，当确实需要32位的整数时，**应使用`long`类型而不是`int`类型**，以便把程序移植到16位机后仍然可以正常工作。
   - 如果在`int`设置为32位的系统中要使用16位的值，应使用short类型以节省存储空间。通常，只有当程序使用相对于系统可用内存较大的整型数组时，才需要重点考虑节省空间的问题。使用short类型的另一个原因是，计算机中某些组件使用的硬件寄存器是16位。
   - 要把一个较小的**常量作为long类型**对待，值的**末尾加上l（小写的L）或L后缀**。也可用于**八进制和十六进制**整数，如*020L和0x10L*。支持`long long`类型的系统中，也可以使用**ll或LL**后缀来表示long long类型的值，如3LL。另外，**u或U后缀**表示`unsigned long long`，如5llu、10LLU、6LLU或9Ull。

4. 打印`short`、`long`.`long long`和`unsigned`类型

   - 打印`unsigned int %u`
   - 打印`long %ld `
   - 在`x`和`o`前面可以使用`l`前缀，`%lx`表示以十六进制格式打印`long`类型整数，`%lo`表示以八进制格式打印`long`类型整数。**转换说明中只能用小写**。
   - 打印`short %hd`表示以**十进制**显示`short`类型，`%ho`表示以**八进制**显示short类型。`h`和`l`前缀都可以和`u`一起使用，用于表示无符号类型。例如，`%lu`表示打印`unsigned long`。对于支持`long long`类型的系统，`%lld`和`%llu`分别表示有符号和无符号类型
   - 必须**确保转换说明**的==数量==和**待打印值的数量相同**，**须根据待打印值的类型使用正确的转换说明**。

5. `char`类型

   - 字符常量初始化`char grade = 'A'`;C语言中，用**单引号**括起来的**单个字符**被称为**字符常量**。**字符是以数值形式储存的**，所以也可使用数字代码值来赋值`char grade = 65`;
   - C语言将**字符常量视为int类型而非char类型**字符常量的这种特性，可以定义一个字符常量'FATE'，即把4个独立的8位ASCII码储存在一个32位存储单元中如果把这样的字符常量赋给char类型变量grade，只有最后8位有效。
   - 把**转义序列赋给字符变量**时，必须用**单引号把转义序列括起来**`char nerf = '\n';`

   | 转义序列 | 含义                                                    |
   | -------- | ------------------------------------------------------- |
   | `\a`     | 警报                                                    |
   | `\b`     | 退格                                                    |
   | `\f`     | 换页                                                    |
   | `\n`     | 换行                                                    |
   | `\r`     | 回车                                                    |
   | `\t`     | 水平制表符                                              |
   | `\v`     | 垂直制表符                                              |
   | `\\`     | 反斜杠(\)                                               |
   | `\'`     | 单引号                                                  |
   | `\"`     | 双引号                                                  |
   | `\?`     | 问号                                                    |
   | `\0oo`   | 八进制值(`oo`为有效的八进制值，每个o表示一个数值) `007` |
   | `\xhh`   | 十六进制(`hh`为有效的十六进制值，每个o表示一个数值)     |

   - `printf()`函数用==`%c`指明待打印的字符==。
   - `_Bool` 布尔值，即逻辑值`true`和`false`

6. 可移植类型 `stdint.h inttypes.h`

   - C99 新增了两个头文件`stdint.h`和`inttypes.h`，以确保C语言的类型在各系统中的功能相同。
   - C语言为现有类型创建了更多类型名。类型名定义在`stdint.h`,`int32_t`表示32位的有符号整数类型。***int32_t表示整数类型的宽度正好是32位。但是，计算机的底层系统可能不支持***
   - **最小宽度类型**。`int_least8_t`是**可容纳8位有符号整数值的类型中宽度最小的类型的一个别名**
   - 最快最小宽度类型`int_fast8_t`被定义为系统中对8位有符号值而言运算最快的整数类型的别名。
   - 最大的有符号整数类型`intmax_t`，`unitmax_t`表示最大的无符号整数类型
   - 打印`int32_t`类型的值，`inttypes.h`头文件中定义了`PRId32`字符串宏，代表打印32位有符号值的合适转换说明

7. `float double long double`

   - 1.0e9表示1.0x10^9^
   - C只保证long double类型至少与double类型的精度相同。
   - **浮点数的声明**：`2.87e-3`。==可以没有小数点==（如，2E5）==或指数部分==（如，19.28），但是**不能同时省略两者**。**不要在浮点型常量中间加空格**。
   - **编译器**假定**浮点型常量**是**double**类型的精度。加上**f或F后缀可覆盖默认设置**。使用l或L后缀使得数字成为long double类型
   - C99 标准添加十六进制表示浮点型常量 `0xa.1fp10`  **用p和P分别代替e和E**

8. `long` 打印浮点值

   - `printf()`函数使用`%f `打印十进制记数法的`float`和`double`，`%e`打印指数记数法的浮点数，如果系统支持十六进制格式的浮点数，可用`a`和`A`分别代替`e`和`E`，打印`long double`类型要使用`%Lf`、`%Le`或`%La`。
   - **未在函数原型中**显式**说明参数类型**的函数**传递参**数时，**C编译器**会把**float**类型的值**自动转换成double**类型
   - 特殊的浮点值`NaN`（not a number的缩写）

9. 复数和虚数

   - 3种复数类型：`float_Complex`、`double_Complex`和`long double _Complex`。
   - 3种虚数类型：`float_Imaginary`、`double _Imaginary`和`long double _Imaginary`
   - 包含`complex.h`头文件，便可用`complex`代替`_Complex`，用`imaginary`代替`_Imaginary`，还可以用`I`代替`-1`的平方根

10. 缓冲区刷新

    - 标准明确规定了**何时把缓冲区**中的内容**发送到屏幕**：**当缓冲区
      满**、遇到**换行字符**或需要**输入**，`fflush()`主动刷新缓冲区

### 格式化输入输出

1. `string.h` 提供`strlen()`函数的原型，==**使用%s转换说明来处理字符串的输入和输出**==。*双引号*仅告知编译器它括起来的是*字符串*，正如*单引号*用于标识*单个字符*一样。**根据`%s`转换说明，`scanf()`只会读取字符串中的一个单词**，而不是一整句。

2. C中的**字符串**一定以**空字符结束**，其ASCII码值是（或等价于）0，**数组的容量必须至少比待存储字符串中的字符数多1**。

3. `strlen()`得出字符串中的字符数(不包括空字符)

4. `sizeof `使用圆括号，圆括号的使用时机否取决于运算对象是**类型**(`sizeof(char)`)还是**特定量**(`sizeof name`)

5. 常量和C预处理器

   - `#define TAXRATE 0.015` 编译程序时，程序中所有的TAXRATE都会被替换成0.015。这一过程被称为编译时替换。这样定义的常量也称为**明示常量**。

6. ==%1.2f表明，结果被四舍五入为两位小数输出==

7. C头文件`limits.h`和`float.h`分别提供了与**整数类型**和**浮点类型大小限制相**
   **关的详细信息。**

   | 明示常量       | 含义                                            |
   | -------------- | ----------------------------------------------- |
   | CHAR_BIT       | char类型的位数                                  |
   | SCHAR_MAX      | signed char类型的最大值                         |
   | UCHAR_MIN      | unsigned char类型的最小值                       |
   | USHRT_MAX      | unsigned short类型的最大值                      |
   | FLT_MANT_DIG   | float类型的尾数位数                             |
   | FLT_DIG        | float类型的最少有效数字位数                     |
   | FLT_MIN_10_EXP | 带全部有效数字的float类型的最小负指数(以10为底) |
   | FLT_MAX_10_EXP | float类型的最大正指数(以10为底)                 |
   | FLT_MIN        | 保留全部精度的float类型最小正数                 |
   | FLT_MAX        | float类型的最大正数                             |
   | FLT_EPSILON    | 1.00和比1.00大的最小float类型值之间的差距       |

   明示常量名中的**FLT**分别替**换成DBL和LDBL**，即可分别表示**double和long double类型对应的明示常量**。

8. 转换说明及其打印的输出结果

   | 转换说明      | 输出                                                         |
   | ------------- | ------------------------------------------------------------ |
   | `%a/%A`       | 浮点数，十六进制数和p记数法（c99/c11）                       |
   | `%c`          | 单个字符                                                     |
   | `%d`          | 有符号十进制数                                               |
   | `%e/%E`       | 浮点数E计数法                                                |
   | `%g/%G`       | 根据值的不同，自动选着`%`f或`%e/%E`,`%e/%E`格式用于指数小于-4或者大于或等于精度时 |
   | `%i`          | 有符号的十进制数                                             |
   | `%p`          | 指针                                                         |
   | `%s`          | 字符串                                                       |
   | `%u`          | 无符号十进制数                                               |
   | `%x/%X`       | 无符号十六进制数，使用十六进制数0f/0F                        |
   | `%%`          | 打印一个百分号                                               |
   | 标记          | + - 空格 #和0 可以不适应标记或使用多个标记 `%-10d`           |
   | ==**数字**==  | ==最小字段宽度==，如果改字不能容纳待打印的数字或字符串，系统会使用更宽的字段`%4d` |
   | ==**.数字**== | ==精度== 。对于**`%e`，`%E`和`%`f**转换，表示**小数点右边数字的位数**。对于**`%g`和`%G`**转换，表示**有效数字最大位数**。==对于**`%s`**转换==，表示代**打印字符的最大数量**，对于**整型转换**，表示代**打印数字的最小位数**，==如有必要，使用前导0来到达这个位数==。**只使用.表示其后跟随一个0**，所以`$.f`和`%。0f`相同。`%5.2f`打印一个浮点数，字段宽度为5字符，其中小数点后有两位数字。 |
   | `h`           | 表示`short int`或`unsigned short`类型的值                    |
   | `hh`          | `signed char`或`unsigned char `类型的值 `%hhu`               |
   | `j`           | 表示`intmax_t`或`uintmax_t`类型的值                          |
   | `l`           | 表示`long int`或`unsigned int` 类型的值 `%8lu`               |
   | `ll`          | 表示` long long int` 或`unsigned long long int`的值          |
   | `L`           | 表示long double类型的值                                      |
   | `t`           | 表示`ptrdiff_t`类型的值。`ptrdiff_t`是两个指针插值的类型     |
   | z             | 表示`size_t`类型的值。`size_t`是`sizeof`返回的类型           |
   | `-`           | 待打印项左对齐                                               |
   | `+`           | 有符号值若为正，则在值前面显示加号；若为负，则在值前面显示减号 |
   | 空格          | 有符号值若为正，则在值的前面显示前导空格（不显示任何字符）；若为负，则在值前面显示减号。+覆盖一个空格 |
   | `#`           | 把结果转换为另一个形式。如果是`%o`格式，则以`0`开始；如果是`%x`或`%X`格式，则以`0`x或`0X`开始；对于所有的浮点格式，`#`保证了即使后面没有任何数字，也打印一个小数点字符。对于`%`g和`%G`格式，#防止结果后面的`0`被删除 |
   | `0`           | 对于数字格式，用前导0代替空格填充字段宽度。对于**整数格式**，如果**出现-标记**或**指定精度**，**==则忽略该标记==** |

9. **`size_t`**定义成系统使用`sizeof`返回的类型这被称为底层类型

10. 转换说明的含义

    - 转换说明把**以二进制格式储存在计算机中的值转换成一系列字符**（字符串）以便于显示。例如，数字76在计算机内部的存储格式是二进制数01001100。`%d`转换说明将其转换成字符7和6，并显示为76；`%d`的意思是“把给定的值翻译成十进制整数文本并打印出来”。

11. `printf()`函数也有一个返回值，它**返回打印字符的个数**。如果有输出错误，
    `printf()`则返回一个负值（`printf()`的旧版本会返回不同的值）。==**计算针对所有字符数，包括空格和不可见的换行符（\n）。**==

    - ```c
      //不能在双引号括起来的字符串中间断行
      	printf("The printf() function printed %d
      			characters.\n", rv);
      /*C编译器会报错：字符串常量中有非法字符。在字符串中，可以使用\n
      来表示换行字符，但是不能通过按下Enter（或Return）键产生实际的换行
      符。*/
          printf("Here's another way to print a \
      long string.\n");
                 /*用反斜杠（\）和Enter（或Return）键组合来断行。这使得光标移至下一行，而且字符串中不会包含换行符。其效果是在下一行继续输出。但是，下一行代码必须和程序清单中的代码一样从最左边开始。如果缩进该行，比如缩进5个空格，那么这5个空格就会成为字符串的一部分。*/
          printf("Hello, young "　　 "lovers" ", wherever you are.");//：ANSI C引入的字符串连接。在两个用双引号括起来的字符串之
      //间用空白隔开，C编译器会把多个字符串看作是一个字符串
                
      ```

12. `scanf()`

    - ![image-20240908233305446](C:\Users\fate_\AppData\Roaming\Typora\typora-user-images\image-20240908233305446.png)

    - ![image-20240908233331850](C:\Users\fate_\AppData\Roaming\Typora\typora-user-images\image-20240908233331850.png)

    - ![image-20240908233354970](C:\Users\fate_\AppData\Roaming\Typora\typora-user-images\image-20240908233354970.png)

    - 假设`scanf()`根据一个`%d`转换说明读取一个整数。**`scanf()`函数每次读取一个字符**，**跳过所有的空白字符**，直至遇到第1个非空白字符才开始读取。如果下一个**字符是数字**，它便**保存**该数字并读取下一个字符如果遇到一个**非数字字符**，它便**认为读到了整数的末尾**。==然后，`scanf()`把非数字字符放回输入。==

    - 如果使用**字段宽度**，`scanf()`会在**字段结尾或第1个空白字符处停止读取**。如果第1个非空白字符是A而不是数字，会发生什么情况？`scanf()`将停在那里，并把A放回输入中，不会把值赋给指定变量。程序在下一次读取输入时，首先读到的字符是A。如果程序只使用%d转换说明，` scanf()`就一直无法越过A读下一个字符。如果使用带多个转换说明的`scanf()`，**C规定在第1个出错处停止读取输入**。

    - **使用%s 转换说明**，`scanf()`会读取除空白以外的所有字符。`scanf()`跳
      过空白开始读取第 1 个非空白字符，**并保存非空白字符直到再次遇到空白。**
      
    - `scanf()`函数允许把普通字符放在格式字符串中。除空格字符外的普通字符必须与输入字符串严格匹配。`scanf("%d,%d", &n, &m);` 用户必须输入 88,121

    - 格式字符串中的空白意味着跳过下一个输入项前面的所有空白

    - **对于%c，在格式字符串中添加一个空格字符会有所不同**。例如，如果把%c放在格式字符串中的空格后面，`scanf()`便会跳过空格，从第1个非空白字符开始读取。也就是说，`scanf("%c", &ch)`从输入中的第1个字符开始读取，`scanf(" %c", &ch)`则从第1个非空白字符开始读取。

    - `scanf()`函数返回**成功读取的项数**。没有读取任何项且需要读取一
      个数字而用户却输入一个非数值字符串，`scanf()`便返回0。当`scanf()`检测到“文件结尾”时，会返回EOF（`EOF`是`stdio.h`中定义的特殊值，通常用`#define`指令把`EOF`定义为`-1`）

      - ```c
        	int n;
        	printf("Please enter three integers:\n");
        	scanf("%*d %*d %d", &n);//把*放在%和转换字符之间时，会使得scanf()跳过相应的输出项
        	printf("The last integer was %d\n", n);
        ```

13. **字符串**，无论是表示成字符常量还是储存在字符数组中，==**都以一个叫做空字符的隐藏字符结尾。**==

### 运算符，表达式和语句

1. C 的标准**数学库**提供了一个`pow()`函数用于指数运算。例如，`pow(3.5,
   2.2)`返回3.5的2.2次幂）。==**混合整数和浮点数计算的结果是浮点数**==。
2. **求模运算符只能用于整数，不能用于浮点数**。**如果第1个运算对象是负数，那么求模的结果为负数；如果第1个运算对象是正数，那么求模的结果也是正数**。无论何种情况，只要`a`和`b`都是整数值，便可通过**a - (a/b)*b**来计算`a%b`。
3. **递增运算符**和**递减运算符**都有**很高的结合优先级**，只有圆括号的优先级
   比它们高。
4. 在C语言中，**编译器可以自行选择先对函数中的哪个参数求值**。这样做
   提高了编译器的效率，但是如果在函数的参数中使用了递增运算符，就会有
   一些问题。
5. 类型转换
   - 当类型转换出现在表达式时，都是从较小类型转换为较大类型。
   - 在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。
   - 当浮点类型被降级为整数类型时，原来的浮点值会被截断。
   - 强制类型转换运算符`(type)`，例如`(int)1.6`。

