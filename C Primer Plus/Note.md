### C语言的概述

语言与命名规则

以前的C语言，还要求把变量声明在块的顶部，其它语句不能放在任何声明的前面。

```c
  int main()
    {
        int doors;//旧规则
        int dogs;
        doors=5
        dogs=3;
      	//其它语句
      
      	//c99和c11遵循c++的惯例，可以把声明放在块中的任何位置。
    }
```

C99和C11允许使用更长的**标识符名**， 但是**编译器只识别前63个字符**。对于**外部标识符**（参阅第12章）， 只允许使用**31个字符**。实际上， 你可以使用更长的字符， 但是编译器会忽略超出的字符。**小写字母、 大写字母、 数字和下划线（＿）来==命名==**。 而且， 名称的**第1个字符必须是字符或下划线**， ==不能是数字== 。操作系统和C库经常使用以一个或两个下划线字符开始的标识符（如， `＿kcab`)，因此最好避免在自己 的程序中使用这种名称。C语言的名称区分大小写。

C语言关键字中，**粗体表示的是C90标准新增的关键字**，**斜体**表示的C99标准新增的关键字，**粗斜体**表示的是C11标准新增的关键字

|    auto     |   extern   |     short      |         while          |
| :---------: | :--------: | :------------: | :--------------------: |
|   `break`   |  `float`   |  **`signed`**  |    ***`_Alignas`***    |
|   `case`    |   `for`    |    `sizeof`    |    ***`_Alignof`***    |
|   `char`    |   `goto`   |    `static`    |    ***`_Atomic`***     |
| **`const`** |    `if`    |    `struct`    |     ***`_Bool`***      |
| `continue`  |  `inline`  |    `switch`    |    ***`_Complex`***    |
|  `default`  |   `int`    |   `typedef`    |    ***`_Generic`***    |
|    `do`     |   `long`   |    `union`     |   ***`_Imaginary`***   |
|  `double`   | `register` |   `unsigned`   |   ***`_Noreturn`***    |
|   `else`    | `restrict` |     `void`     | ***`_static_assert`*** |
| **`enum`**  |  `return`  | **`volatile`** | ***`_Thread_local`***  |

----

### 数据和C

1. 数据类型和关键字

   - 在`printf()`中使用**`%f`**来**处理浮点值**。`%.2f`中的**.2 用于精确控制输出**，指定输出的浮点数只显示小数点后面两位。
   - `char`类型也可以表示较小的整数。
   - `_Bool`类型表示布尔值（`true`或`false`），`_complex`和`_Imaginary`分别表示复数和虚数。

2. 整数和浮点数

   - ==注意==，在一个值后面加上一个小数点，该值就成为一个浮点值。

   - 对于一些算术运算（如，两个很大的数相减），**浮点数损失的精度更多** 因为在**任何区间内**（如，1.0 到 2.0 之间）**都存在无穷多个实数**，所以计算机的**浮点数不能表示区间内所有的值**。浮点数通常只是实际值的近似值。例如，7.0可能被储存为浮点值6.99999。
     
   - C 初始化变量的三种方式

     ```c
   int erns;
     int hogs, cows, goats;
     cows = 112;
     
     //通过函数（如，scanf()）获得值。
     
     int hogs = 21;
     int cows = 32, goats = 14;
     int dogs, cats = 94; /* 有效，但是这种格式很糟糕 */
     ```
   
   - 声明为变量创建和标记存储空间，初始化则是为变量赋值，没有初始化的变量的值将会是未定义的垃圾值。

   - 0(**数字零**)x或0X前缀表示十六进制值，0前缀表示八进制，**十进制**显示数字，使用`%d`，**八进制**显示数字，使用`%o`，以**十六进制**显示数字，使用`%x`。**显示**各进制数的**前缀**0、0x和0X，必须分别使用`%#o、%#x、%#X`

3. 其它整数类型

   - `short int`类型（或者简写为`short`）的存储空间可能比`int`类型少
   - `long int`或`long`占用的存储空间可能比`int`多
   - `long long int`或`long long`占用的储存空间可能比`long`多，该类型至少占64位。
   - `unsigned int`或`unsigned`只用于非负值的场合
   - 在**C90标准**中，添加了`unsigned long int`或`unsigned long`和`unsigned in`t或`unsigned short`类型。C99标准又添加了`unsigned long long int`或`unsigned long long`。
   - 在任何**有符号类型前**面添加关键字**`signed`**，可**强调使用有符号类型**的意图
   - C语言只规定了`short`占用的**存储空间不能多**于`int`，`long`占用的**存储空间不能少于**`int`。
   - **对于那些`long`占用的空间比`int`大的系统，使用`long`类型会减慢运算速度。**如果在**`long`类型和`int`类型占用空间相同的机器上编写代码**，当确实需要32位的整数时，**应使用`long`类型而不是`int`类型**，以便把程序移植到16位机后仍然可以正常工作。
   - 如果在`int`设置为32位的系统中要使用16位的值，应使用short类型以节省存储空间。通常，只有当程序使用相对于系统可用内存较大的整型数组时，才需要重点考虑节省空间的问题。使用short类型的另一个原因是，计算机中某些组件使用的硬件寄存器是16位。
   - 要把一个较小的**常量作为long类型**对待，值的**末尾加上l（小写的L）或L后缀**。也可用于**八进制和十六进制**整数，如*020L和0x10L*。支持`long long`类型的系统中，也可以使用**ll或LL**后缀来表示long long类型的值，如3LL。另外，**u或U后缀**表示`unsigned long long`，如5llu、10LLU、6LLU或9Ull。
   
4. 打印`short`、`long`.`long long`和`unsigned`类型

   - 打印`unsigned int %u`
   - 打印`long %ld `
   - 在`x`和`o`前面可以使用`l`前缀，`%lx`表示以十六进制格式打印`long`类型整数，`%lo`表示以八进制格式打印`long`类型整数。==**转换说明中只能用小写**。==
   - 打印`short %hd`表示以**十进制**显示`short`类型，`%ho`表示以**八进制**显示short类型。`h`和`l`前缀都可以和`u`一起使用，用于表示无符号类型。例如，`%lu`表示打印`unsigned long`。对于支持`long long`类型的系统，`%lld`和`%llu`分别表示有符号和无符号类型
   - 必须**确保转换说明**的==数量==和**待打印值的数量相同**，**须根据待打印值的类型使用正确的转换说明**。

5. `char`类型

   - 字符常量初始化`char grade = 'A'`;C语言中，用**单引号**括起来的**单个字符**被称为**字符常量**。**字符是以数值形式储存的**，所以也可使用数字代码值来赋值`char grade = 65`;
   - C语言将**字符常量视为int类型而非char类型**字符常量的这种特性，可以定义一个字符常量'FATE'，即把4个独立的8位ASCII码储存在一个32位存储单元中如果把这样的字符常量赋给char类型变量grade，只有最后8位有效。
   - 把**转义序列赋给字符变量**时，必须用**单引号把转义序列括起来**`char nerf = '\n';`

   | 转义序列 | 含义                                                    |
   | -------- | ------------------------------------------------------- |
   | `\a`     | 警报                                                    |
   | `\b`     | 退格                                                    |
   | `\f`     | 换页                                                    |
   | `\n`     | 换行                                                    |
   | `\r`     | 回车                                                    |
   | `\t`     | 水平制表符                                              |
   | `\v`     | 垂直制表符                                              |
   | `\\`     | 反斜杠(\)                                               |
   | `\'`     | 单引号                                                  |
   | `\"`     | 双引号                                                  |
   | `\?`     | 问号                                                    |
   | `\0oo`   | 八进制值(`oo`为有效的八进制值，每个o表示一个数值) `007` |
   | `\xhh`   | 十六进制(`hh`为有效的十六进制值，每个o表示一个数值)     |

   - `printf()`函数用==`%c`指明待打印的字符==。
   - `_Bool` 布尔值，即逻辑值`true`和`false`（需包含头文件`stdbool.h`)

6. 可移植类型 `stdint.h inttypes.h`

   - C99 新增了两个头文件`stdint.h`和`inttypes.h`，以确保C语言的类型在各系统中的功能相同。
   - C语言为现有类型创建了更多类型名。类型名定义在`stdint.h`,`int32_t`表示32位的有符号整数类型。***int32_t表示整数类型的宽度正好是32位。但是，计算机的底层系统可能不支持***
   - **最小宽度类型**。`int_least8_t`是**可容纳8位有符号整数值的类型中宽度最小的类型的一个别名**
   - 最快最小宽度类型`int_fast8_t`被定义为系统中对8位有符号值而言运算最快的整数类型的别名。
   - 最大的有符号整数类型`intmax_t`，`unitmax_t`表示最大的无符号整数类型
   - 打印`int32_t`类型的值，`inttypes.h`头文件中定义了`PRId32`**字符串宏**，代表打印32位有符号值的合适转换说明

7. `float double long double`

   - 1.0e9表示1.0x10^9^
   - C只保证long double类型至少与double类型的精度相同。
   - **浮点数的声明**：`2.87e-3`。==可以没有小数点==（如，2E5）==或指数部分==（如，19.28），但是**不能同时省略两者**。**不要在浮点型常量中间加空格**。
   - **编译器**假定**浮点型常量**是**double**类型的精度。加上**f或F后缀可覆盖默认设置**。使用l或L后缀使得数字成为long double类型
   - C99 标准添加十六进制表示浮点型常量 `0xa.1fp10`  **用p和P分别代替e和E**

8. 打印浮点值

   - `printf()`函数使用`%f `打印十进制记数法的`float`和`double`，`%e`打印指数记数法的浮点数，如果系统支持十六进制格式的浮点数，可用`a`和`A`分别代替`e`和`E`，打印`long double`类型要使用`%Lf`、`%Le`或`%La`。
   - **未在函数原型中**显式**说明参数类型**的函数**传递参**数时，**C编译器**会把**float**类型的值**自动转换成double**类型
   - 特殊的浮点值`NaN`（not a number的缩写）

9. 复数和虚数

   - 3种复数类型：`float_Complex`、`double_Complex`和`long double _Complex`。
   - 3种虚数类型：`float_Imaginary`、`double _Imaginary`和`long double _Imaginary`
   - 包含`complex.h`头文件，便可用`complex`代替`_Complex`，用`imaginary`代替`_Imaginary`，还可以用`I`代替`-1`的平方根

10. 缓冲区刷新

    - 标准明确规定了**何时把缓冲区**中的内容**发送到屏幕**：**当缓冲区满**、遇到**换行字符**或需要**输入**，`fflush()`主动刷新缓冲区

### 格式化输入输出

1. `string.h` 提供`strlen()`函数的原型，==**使用%s转换说明来处理字符串的输入和输出**==。*双引号*仅告知编译器它括起来的是*字符串*，正如*单引号*用于标识*单个字符*一样。**根据`%s`转换说明，`scanf()`只会读取字符串中的一个单词**，而不是一整句。

2. C中的**字符串**一定以**空字符结束**，其ASCII码值是（或等价于）0，**数组的容量必须至少比待存储字符串中的字符数多1**。

3. `strlen()`得出字符串中的字符数==**(不包括空字符)**==

4. `sizeof `圆括号的使用时机否取决于运算对象是**类型**(`sizeof(char)`)还是**特定量**(`sizeof name`)

5. 常量和C预处理器

   - `#define TAXRATE 0.015` 编译程序时，程序中所有的TAXRATE都会被替换成0.015。这一过程被称为编译时替换。这样定义的常量也称为**明示常量**。

6. C头文件`limits.h`和`float.h`分别提供了与**整数类型**和**浮点类型大小限制相**
   **关的详细信息。**

   | 明示常量       | 含义                                            |
   | -------------- | ----------------------------------------------- |
   | CHAR_BIT       | char类型的位数                                  |
   | SCHAR_MAX      | signed char类型的最大值                         |
   | UCHAR_MIN      | unsigned char类型的最小值                       |
   | USHRT_MAX      | unsigned short类型的最大值                      |
   | FLT_MANT_DIG   | float类型的尾数位数                             |
   | FLT_DIG        | float类型的最少有效数字位数                     |
   | FLT_MIN_10_EXP | 带全部有效数字的float类型的最小负指数(以10为底) |
   | FLT_MAX_10_EXP | float类型的最大正指数(以10为底)                 |
   | FLT_MIN        | 保留全部精度的float类型最小正数                 |
   | FLT_MAX        | float类型的最大正数                             |
   | FLT_EPSILON    | 1.00和比1.00大的最小float类型值之间的差距       |

   明示常量名中的**FLT**分别替**换成DBL和LDBL**，即可分别表示**double和long double类型对应的明示常量**。

7. 转换说明及其打印的输出结果

   | 转换说明      | 输出                                                         |
   | ------------- | ------------------------------------------------------------ |
   | `%a/%A`       | 浮点数，十六进制数和p记数法（c99/c11）                       |
   | `%c`          | 单个字符                                                     |
   | `%d`          | 有符号十进制数                                               |
   | `%e/%E`       | 浮点数E计数法                                                |
   | `%g/%G`       | 根据值的不同，自动选着`%`f或`%e/%E`,`%e/%E`格式用于指数小于-4或者大于或等于精度时 |
   | `%i`          | 有符号的十进制数                                             |
   | `%p`          | 指针                                                         |
   | `%s`          | 字符串                                                       |
   | `%u`          | 无符号十进制数                                               |
   | `%x/%X`       | ==**无符号**==十六进制数，使用十六进制数0f/0F                |
   | `%%`          | 打印一个百分号                                               |
   | 标记          | + - 空格 #和0 可以不适应标记或使用多个标记 `%-10d`           |
   | ==**数字**==  | ==最小字段宽度==，如果该字不能容纳待打印的数字或字符串，系统会使用更宽的字段`%4d` |
   | ==**.数字**== | ==精度== 。对于**`%e`，`%E`和`%`f**转换，表示**小数点右边数字的位数**。对于**`%g`和`%G`**转换，表示**有效数字最大位数**。==对于**`%s`**转换==，表示代**打印字符的最大数量**，对于**整型转换**，表示代**打印数字的最小位数**，==如有必要，使用前导0来到达这个位数==。**只使用.表示其后跟随一个0**，所以`$.f`和`%.0f`相同。`%5.2f`打印一个浮点数，字段宽度为5字符，其中小数点后有两位数字。 |
   | `h`           | 表示`short int`或`unsigned short`类型的值                    |
   | `hh`          | `signed char`或`unsigned char `类型的值 `%hhu`               |
   | `j`           | 表示`intmax_t`或`uintmax_t`类型的值                          |
   | `l`           | 表示`long int`或`unsigned int` 类型的值 `%8lu`               |
   | `ll`          | 表示` long long int` 或`unsigned long long int`的值          |
   | `L`           | 表示long double类型的值                                      |
   | `t`           | 表示`ptrdiff_t`类型的值。`ptrdiff_t`是两个指针插值的类型     |
   | z             | 表示`size_t`类型的值。`size_t`是`sizeof`返回的类型           |
   | `-`           | 待打印项左对齐                                               |
   | `+`           | 有符号值若为正，则在值前面显示加号；若为负，则在值前面显示减号 |
   | 空格          | 有符号值若为正，则在值的前面显示前导空格（不显示任何字符）；若为负，则在值前面显示减号。+覆盖一个空格 |
   | `#`           | 把结果转换为另一个形式。如果是`%o`格式，则以`0`开始；如果是`%x`或`%X`格式，则以`0`x或`0X`开始；对于所有的浮点格式，`#`保证了即使后面没有任何数字，也打印一个小数点字符。对于`%`g和`%G`格式，#防止结果后面的`0`被删除 |
   | `0`           | 对于数字格式，用前导0代替空格填充字段宽度。对于**整数格式**，如果**出现-标记**或**指定精度**，**==则忽略该标记==** |

8. **`size_t`**定义成系统使用`sizeof`返回的类型这被称为底层类型

9. 转换说明的含义

   - 转换说明把**以二进制格式储存在计算机中的值转换成一系列字符**（字符串）以便于显示。例如，数字76在计算机内部的存储格式是二进制数01001100。`%d`转换说明将其转换成字符7和6，并显示为76；`%d`的意思是“把给定的值翻译成十进制整数文本并打印出来”。

10. `printf()`函数也有一个返回值，它**返回打印字符的个数**(实际显示在屏幕上的字符)。如果有输出错误，`printf()`则返回一个负值（`printf()`的旧版本会返回不同的值）。==**计算针对所有字符数，包括空格和不可见的换行符（\n）。**==

    - ```c
      //不能在双引号括起来的字符串中间断行
      	printf("The printf() function printed %d
      			characters.\n", rv);
      /*C编译器会报错：字符串常量中有非法字符。在字符串中，可以使用\n
      来表示换行字符，但是不能通过按下Enter（或Return）键产生实际的换行
      符。*/
          printf("Here's another way to print a \
      long string.\n");
                 /*用反斜杠（\）和Enter（或Return）键组合来断行。这使得光标移至下一行，而且字符串中不会包含换行符。其效果是在下一行继续输出。但是，下一行代码必须和程序清单中的代码一样从最左边开始。如果缩进该行，比如缩进5个空格，那么这5个空格就会成为字符串的一部分。*/
          printf("Hello, young "　　 "lovers" ", wherever you are.");//：ANSI C引入的字符串连接。在两个用双引号括起来的字符串之
      //间用空白隔开，C编译器会把多个字符串看作是一个字符串
                
      ```

11. `scanf()`

    - | 转换说明       | 含义                                                         |
      | -------------- | ------------------------------------------------------------ |
      | %c             | 把输入解释成字符                                             |
      | %d             | 把输入解释成有符号十进制整数                                 |
      | %e，%f，%g，%a | 把输入解释成浮点数(C99 标准新增了%a)                         |
      | %E，%F，%G，%A | 把输入解释成浮点数(C99标准新增了%A)                          |
      | %i             | 把输入解释成有符号十进制整数                                 |
      | %o             | 把输入解释成有符号八进制整数                                 |
      | %p             | 把输入解释成指针(地址)                                       |
      | %s             | 把输入解释成字符串。从第1个非空白字符开始，到下一个空白字符之前的所有字符 |
      | %u             | 把输入解释成无符号十进制整数                                 |
      | %x，%X         | 把输入解释成有符号十六进制整数                               |
      | *              | 抑制赋值(详见后面解释)示例: "8*d"                            |
      | 数字           | 最大字段宽度。输入达到最大字段宽度处，或第1次遇到空白字符时停止。示例: "号10s" |
      | hh             | 把整数作为signed char或unsigned char 类型读取。示例: ":hhd"、 ":hhu" . |
      | ll             | 把整数作为long long 或unsigned long long 类型读取(C99)       |

    - ![image-20240908233354970](C:\Users\fate_\AppData\Roaming\Typora\typora-user-images\image-20240908233354970.png)
    - 假设`scanf()`根据一个`%d`转换说明读取一个整数。**`scanf()`函数每次读取一个字符**，**跳过所有的空白字符**，直至遇到第1个非空白字符才开始读取。如果下一个**字符是数字**，它便**保存**该数字并读取下一个字符如果遇到一个**非数字字符**，它便**认为读到了整数的末尾**。==然后，`scanf()`把非数字字符放回输入。==
    - 如果使用**字段宽度**，`scanf()`会在**字段结尾或第1个空白字符处停止读取**(%3d)最多读取3个字符作为整数。如果第1个非空白字符是A而不是数字，会发生什么情况？`scanf()`将停在那里，并把A放回输入中，不会把值赋给指定变量。程序在下一次读取输入时，首先读到的字符是A。如果程序只使用%d转换说明，` scanf()`就一直无法越过A读下一个字符。如果使用带多个转换说明的`scanf()`，**C规定在第1个出错处停止读取输入**。
    - **使用%s 转换说明**，`scanf()`会读取除空白以外的所有字符。`scanf()`跳过空白开始读取第 1 个非空白字符，**并保存非空白字符直到再次遇到空白。**
    - `scanf()`函数允许把普通字符放在格式字符串中。==**除空格字符外的普通字符**==必须与输入字符串严格匹配。`scanf("%d,%d", &n, &m);` 用户必须输入 88,121
    - 格式字符串中的空白意味着跳过下一个输入项前面的所有空白
    - **对于%c，在格式字符串中添加一个空格字符会有所不同**。例如，如果把%c放在格式字符串中的空格后面，`scanf()`便会跳过空格，从第1个非空白字符开始读取。也就是说，`scanf("%c", &ch)`从输入中的第1个字符开始读取，`scanf(" %c", &ch)`则从第1个非空白字符开始读取。
    - `scanf()`函数返回**成功读取的项数**。没有读取任何项且需要读取一个数字而用户却输入一个非数值字符串，`scanf()`便返回0。当`scanf()`检测到“文件结尾”时，会返回EOF（`EOF`是`stdio.h`中定义的特殊值，通常用`#define`指令把`EOF`定义为`-1`）

12. **抑制赋值**

    - ```c
      /*
      不想预先指定字段宽度，希望通过程序来指定，那么可以用*修
      饰符代替字段宽度。但还是要用一个参数告诉函数，字段宽度应该是多少。
      也就是说，如果转换说明是%*d，那么参数列表中应包含*和d对应的值。
      */
      printf("Weight = %*.*f\n", width, precision, weight);
      
      
      int n;
      printf("Please enter three integers:\n");
      scanf("%*d %*d %d", &n);//把*放在%和转换字符之间时，会使得scanf()跳过相应的输出项
      printf("The last integer was %d\n", n);
      ```

13. **字符串**，无论是表示成字符常量还是储存在字符数组中，==**都以一个叫做空字符的隐藏字符结尾。**==

### 运算符，表达式和语句

1. C 的标准**数学库**提供了一个`pow()`函数用于指数运算。例如，`pow(3.5,2.2)`返回3.5的2.2次幂）。==**混合整数和浮点数计算的结果是浮点数**==。
2. **求模运算符只能用于整数，不能用于浮点数**。**如果第1个运算对象是负数，那么求模的结果为负数；如果第1个运算对象是正数，那么求模的结果也是正数**。无论何种情况，只要`a`和`b`都是整数值，便可通过**a - (a/b)*b**来计算`a%b`。
3. **递增运算符**和**递减运算符**都有**很高的结合优先级**，只有圆括号的优先级比它们高。
4. 在C语言中，**编译器可以自行选择先对函数中的哪个参数求值**。这样做提高了编译器的效率，但是如果在函数的参数中使用了递增运算符，就会有一些问题。
5. 类型转换
   - 当类型转换出现在表达式时，都是从较小类型转换为较大类型。
   - 在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。
   - 当浮点类型被降级为整数类型时，原来的浮点值会被截断。
   - 强制类型转换运算符`(type)`，例如`(int)1.6`。

### 控制语句：循环

1. 关系运算符也可用来比较浮点数，但是要注意：**比较浮点数时，尽量只使用<和>**。因为浮点数的舍入误差会导致在逻辑上应该相等的两数却不相等。**使用**`fabs()`**函数**（声明在`math.h`头文件中）**可以方便地比较浮点数，**该函数返回一个浮点值的绝对值（即，没有代数符号的值）。
   
2. 在构建比较是否相等的表达式时，都习惯把常量放在左侧。

3. **关系运算符的优先级比算术运算符（包括+和-）低，比赋值运算符高。**

   - 高优先级组： < <= > >=
   - 低优先级组： == !=
   - 关系运算符的结合律也是从左往右。例，`ex != wye == zee与(ex != wye) == zee`

4. **C99**提供了`stdbool.h`头文件，**该头文件让bool成为_Bool的别名**，而且还**把true和false分别定义为1和0的符号常量**。包含该头文件后，写出的代码可以与C++兼容，因为C++把bool、true和false定义为关键字。
   
5. `for`

   ```c
   for (1;2;4)
   {
       3//1仅执行一次 之后的循环为2，3，4
        //可以省略一个或多个表达式（但是不能省略分号），只要在循环中包含能结束循环的语句即可。
        //省略第2个表达式被视为真
        //第1个表达式不一定是给变量赋初值，也可以使用printf()。
   }
   ```

   - **逗号运算符扩展了for循环的灵活性，以便在循环头中包含更多的表达**
   - `for　(ounces　=　1,cost　=　FIRST_OZ;ounces　<=　16;ounces++,cost　+=　NEXT_OZ);`
   
6. `x *= 3 * y + 12 与 x = x * (3 * y + 12) `相同。以上提到的赋值运算符与=的优先级相同，即比+或*优先级低。

7. **逗号运算符**

   - 首先，==它保证了被它分隔的表达式从左往右求值。==（换言之，逗号是一个序列点，所以**逗号左侧项的所有副作用都在程序执行逗号右侧项之前发生**）

8. 可以把字符串储存在char类型的数组中。**如果**`char`**类型的数组末尾包含一个表示字符串末尾的空字符**`\0`，**则该数组中的内容就构成了一个字符串**。

9. 如果把`power()`函数的定义置于`main()`的文件顶部，**就可以省略前置声明**，因为编译器在执行到`main()`之前已经知道power()的所有信息。**但是，这不是C的标准风格。**

### 分支和跳转

1. `getchar()`函数不带任何参数，它从输入队列中返回下一个字符。`putchar()`函数打印它的参数。**只处理字符**。这两个函数通常定义在 `stdio.h`头文件中

2. if else：对于编译器的限制范围，**C99标准要求编译器**最少==**支持127层嵌套**==

3. `ctype.h`头文件中的**字符测试函数**

   | 函数名         | 如果是下列参数时，返回值为真                                 |
   | -------------- | ------------------------------------------------------------ |
   | `isalnum()`    | 字母数字（字母或数字)                                        |
   | `isalpha ( )`  | 字母                                                         |
   | `isblank ()`   | 标准的空白字符（空格、水平制表符或换行符）或任何其他本地化指定为空白的字符 |
   | `iscntrl ()`   | 控制字符，如Ctrl+B                                           |
   | `isdigit ()`   | 数字                                                         |
   | `isgraph ( )`  | 除空格之外的任意可打印字符                                   |
   | `islower ()`   | 小写字母                                                     |
   | `isprint ()`   | 可打印字符                                                   |
   | `ispunct ()`   | 标点符号（除空格或字母数字字符以外的任何可打印字符)          |
   | `isspace()`    | 空白字符（空格、换行符、换页符、回车符、垂直制表符、水平制表符或其他本地化定义的字符） |
   | `isupper()`    | 大写字母                                                     |
   | `isxdigit ( )` | 十六进制数字符                                               |

   | 函数名       | 行为                                                      |
   | ------------ | --------------------------------------------------------- |
   | `tolower ()` | 如果参数是大写字符，该函数返回小写字符;否则，返回原始参数 |
   | `toupper ()` | 如果参数是小写字符，该函数返回大写字符;否则，返回原始参数 |

4. **逻辑运算符的备选拼写**

   | 传统写法 | iso646.h |
   | -------- | -------- |
   | &&       | and      |
   | \|\|     | or       |
   | !        | not      |

   - `!`**运算符的优先级很高**，**比乘法运算符还高**，**与递增运算符的优先级相同**，**只比圆括号的优先级低**。`&&`**运算符的优先级比**`||`**运算符高**，**但是两者的优先级都比关系运算符低，比赋值运算符高**。
   - ==**`C`保证逻辑表达式的求值顺序是从左往右**==。&&和||运算符都是序列点，所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效。而且，C 保证一旦发现某个元素让整个表达式无效，便立即停止求值。
   
5. 条件表达式

   - `expression1 ? expression2 : expression3`
   - 如果 expression1 为真，那么**整个条件表达式的值与** expression2的值相同；如果expression1为假，那么整个条件表达式的值与expression3的值相同。

6.  `continue`

   - 执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代。如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环。

     ```c
     for (count = 0; count < 10; count++)
     {
     	ch = getchar();
     	if (ch == '\n')
     		continue;
     	putchar(ch);
         //对于for循环，执行continue后的下一个行为是对更新表达式求值，然后是对循环测试表达式求值。
         //执行完continue后，首先递增count，然后将递增后的值和10作比较。
     }
     ```

   - 如果`switch`**语句在一个循环中**，**`continue`便可作为`switch`语句的一部分。**这种情况下，就像在其他循环中一样，continue让程序跳出循环的剩余部分，包括switch语句的其他部分。

   - `expression`和`case`标签都必须是整数值（包括char类型），标签必须是常量或完全由常量组成的表达式。

7. `goto` 

   ```c
   part: a = 10;
   goto part;
   //C程序员可以接受一种goto的用法——出现问题时从一组嵌套循环中跳出（一条break语句只能跳出当前循环）
   ```
   

### 字符输入/输出和输入验证

1. 缓冲区
   - 缓冲分为两类：**完全缓冲I/O**和**行缓冲I/O**。完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入中。缓冲区的大小取决于系统，常见的大小是 512 字节和 4096字节。行缓冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区。
   - 为支持==**无缓冲输入**==提供一系列特殊的函数，其原型都在**`conio.h`**头文件中。
     - ANSI C和后续的C标准都规定==**输入是缓冲的**==。
     - **回显无缓冲输入**的`getche()`函数和用于**无回显无缓冲输入**的`getch()`函数（回显输入意味着用户输入的字符直接显示在屏幕上，**无回显输入意味着击键后对应的字符不显示**）
     - **UNIX系统使用另一种不同的方式控制缓冲**。在UNIX系统中，可以使用`ioctl`()函数（该函数属于UNIX库，但是不属于C标准）指定待输入的类型，然后用`getchar()`执行相应的操作。
     - **ANSI没有提供调用无缓冲输入的标准方式**
   - 无论操作系统实际使用何种方法**检测文件结尾**，在C语言中，用`getchar()`读取文件检测到文件结尾时将返回**一个特殊的值**，即==**EOF**==（end of file的缩写）。`scanf()`函数检测到文件结尾时也返回EOF。`#define EOF (-1)`
     - 为什么是-1？因为`getchar()`函数的返回值通常都介于0～127，这些值对**应标准字符集**。但是，如果系统能识别扩展字符集，该函数的返回值可能在0～255之间。无论哪种情况，**-1都不对应任何字符，所以，该值可用于标记文件结尾。**
   - `echo_eof < words  <`符号是UNIX和DOS/Windows的重定向运算符。该运算符使words文件与stdin流相关联，把文件中的内容导入`echo_eof`程序。
   - 通常，==**系统使用行缓冲输入**==，即**当用户按下 Enter 键后输入才被传送给程序**。==**按下Enter键也传送了一个换行符**==，编程时要注意处理这个换行符。
   - 通过标准I/O包中的一系列函数，`getchar()`和` scanf()`函数也属于这一系列。当检测到文件结尾时，这两个函数都返回 EOF

### 函数

1. ANSI C**要求在每个变量前都声明其类型**。也就是说，不能像普通变量声明那样使用同一类型的变量列表。`void dubs(int x, int y, int z)`

   - 接受ANSI C之前的形式，但是将其视为废弃不用的形式：

     ```c
     void dibs(x,y,z)
     int x,y,z;
     {
         //当前的标准正逐渐淘汰 ANSI 之前的形式。读者应对此有所了解，以便能看懂以前编写的程序。
         //ANSI C也接受过去的声明函数形式，即圆括号内没有参数列表：void show_n_char();这种形式最终会从标准中剔除。
     }
     ```

   - 当函数接受参数时，函数原型用逗号分隔的列表指明参数的数量和类型。==**根据个人喜好，你也可以省略变量名**==。

   - `return;`**这条语句会导致终止函数，并把控制返回给主调函数。**因为 return 后面没有任何表达式，所以没有返回值，**只有在void函数中才会用到这种形式。**

   - 我们把函数的前置声明放在**主调函数**外面。当然，也可以放在主调函数里面。

   - `#include "hotels.h"`指令中的双引号表明被包含的文件位于当前目录中（通常是包含源代码的目录）

2. 声明指针

   ```c
   int *pi; // pi是指向int类型变量的指针
   		 //星号（*）表明声明的变量是一个指针。int * pi;声明的意思是pi是一个指针，*pi是int类型
   ```


### 数组和指针

1. 数组的初始化
   - `int powers[8] = {1,2,4,6,8,16,32,64};`**不支持ANSI的编译器**会把这种形式的初始化识别为**语法错误**，在数组声明前加上关键字static可解决此问题。
   - 当初始化列表中的**值少于数组**元素个数时，==编译器会把剩余的元素都初始化为0==。
   - 可以**省略方括号中数字**，让**编译器自动匹配数组大小和初始化列表中的项数**。
   
2. 指定初始化器
   - `int arr[6] = {0,0,0,0,0,212}; // 传统的语法`
   - 而==**C99规定**==，可以在初始化列表中使用带方括号的下标指明待初始化的元素：`int arr[6] = {[5] = 212}; // 把arr[5]初始化为212`
   - 指定初始化器的**两个重要特性**：
     - 如果指定初始化器后面有更多的值，[4] = 31,30,31，那么后面这些值将被用于初始化指定元素后面的元素。
     - 如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化。

3. 声明数组时只能在方括号中使用**整型常量表达式**。所谓整型常量表达式，是由整型常量构成的表达式。==**`sizeof`表达式被视为整型常量**==但是（与C++不同）**==`const`值不是。==**

   ```c
       const float rain[YEARS][MONTHS] =
           {
               {4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6},
               {8.5,8.2,1.2,1.6,2.4,0.0,5.2,0.9,0.3,0.9,1.4,7.3},
               {9.1,8.5,6.7,4.3,2.1,0.8,0.2,0.2,1.1,2.3,6.1,8.4},
               {7.2,9.9,8.4,3.3,1.2,0.8,0.4,0.0,0.6,1.7,4.3,6.2},
               {7.6,5.6,3.8,2.8,3.8,0.2,0.0,0.0,0.0,1.3,2.6,5.2}
           };
   ```

   - 如果第1个列表中只有10个数，则只会初始化数组第1行的前10个元素，而最后两个元素将被默认初始化为0。

4. **在C中，指针加1指的是增加一个存储单元**。对数组而言，这意味着把加1后的地址是下一个元素的地址，而不是下一个字节的地址。

5. `int *ar`形式和`int ar[]`形式都表示ar是一个指向int的指针。但是，`int ar[]`**只能用于声明形式参数**。第2种形式（`int ar[]`）提醒读者指针`ar`指向的不仅仅一个`int`类型值，还是一个`int`类型数组的元素。
   
6. ==**C保证在给数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。**==虽然C保证了`marbles + SIZE`有效，但是对`marbles[SIZE]`（即储存在**该位置上**的值）**未作任何保证**。
   
7. 一元运算符***和++的优先级相同**，但==**结合律是从右往左**==，指针与整数相加:可以使用+运算符把指针与整数相加，或整数与指针相加。无论哪种情况，**整数都会和指针所指向类型的大小(以字节为单位)相乘,然后把结果与初始地址相加。**

8. `const`

   1. 指向` const `的指针通常用于函数形参中，表明该**函数不会使用指针改变数据**。只能把非`const`数据的地址赋给普通指针。C标准规定，使用==**非**==`const`标识符修改`const`数据导致的结果是未定义的。
   2. `const`还有其他的用法。例如，可以声明并初始化一个不能指向别处的指针。
   3. 把`const`指针赋给非`const`指针不安全，因为这样==**可以使用新的指针改变`const`指针指向的数据。**==编译器在编译代码时，可能会给出警告，执行这样的代码是未定义的。
   4. C和C++中`const`的用法很相似，但是并不完全相同。**区别之一是，C++允许在声明数组大小时使用`const`整数**，而C却不允许。区别之二是，C++的指针赋值检查更严格。**C++不允许把`const`指针赋给非`const` 指针**。而C则允许这样做，但是如果通过`pl`更改`y`，其行为是未定义的。

9. ==**指向多维数组的指针**==

   1. `int (* pz)[2];//pz指向一个内含两个int类型值的数组`。`pz`声明为**指向一个数组的指针**，该数组内含两个`int`类型值。

   2. `int * pax[2];//pax是一个内含两个指针元素的数组，每个元素都指向int的指针`

   3. 由于`[]`优先级高，先与`pax`结合，所以`pax`成为一个内含两个元素的数 组。然后*表示`pax`数组内含两个指针。最后，`int`表示`pax`数组中的指针都指向`int`类型的值。因此，这行代码声明了两个指向`int`的指针。而前面有圆括号的版本，*先与`pz`结合，因此声明的是一个指向数组（内含两个`int`类型的值）的指针。

   4. 可以用数组表示法或指针表示法来表示一个数组元素，既可以使用数组名，也可以使用指针名：

      `zippo[m][n] == *(*(zippo + m) + n)` `pz[m][n] == *(*(pz + m) + n)`

10. 函数和多维数组

   - ```c
     void sum_rows(int ar[COLS],int rows);
     void sum_cols(int [][COLS],int);
     void sum2d(int(*ar)[COLS],int rows);
     ```

   - 一般而言，声明一个指向N维数组的指针，**只能省略最左边方括号中的值**。`int sum4d(int ar[][12][20][30])`

   - 变长数组

     - ```c
       int quarters=4;
       int regions=5;
       double sales[regions][quarters]; //一个变长数组且变长数组必须是自动储存类别
       int sum2d(int rows,int cols,int ar[rows][cols]);
       //因为ar的声明要使用rows和cols，所以在形参列表中必须在声明ar之前声明这两个形参。
       int sum2d(int,int,int ar[*][*]);
       //c99和c11标准规定，可以省略原型中的形参名，但是在这种情况下，必须使用星号来代替省略的维度。
       ```

     - ==**不能在声明中初始化它们**==。最终，**C11把变长数组作为一个可选特性**，而不是必须强制实现的特性。

     - 变长数组中的变不是指可以修改已创建数组的大小。一旦创建了变长数组，他的大小则保持不变。这里的变指的是：**在创建数组时，可以使用变量指定数组的维度。**

     - 需要注意的是，在**函数定义的形参列表**中声明的**变长数组并未实际创建数组**。和传统的语法类似，变长数组名实际上是一个指针。这说明带变长数组形参的函数实际上是在原始数组中处理数组，因此可以修改传入的数组。

     - ==**C99/C11** 标准==允许在声明变长数组时使用 `const `变量。所以该数组的定义必须是声明在块中的自动存储类别数组。

11. 复合字面量

    - `(int [2]){10, 20}`复合字面量也可以省略大小。

### 字符串和字符串函数

1. 字符串

   - ```c
     const char m1 [40] = "Limit yourself to one line's worth.";
     //这种形式的初始化比标准的数组初始化形式简单得多:
     const char m1 [40] = {'L','i','m','\0'};
     //注意最后的空字符。没有这个空字符，这就不是一个字符串，而是一个字符数组。
     
     //从ANSI C标准起，如果字符串字面量之间没有间隔，或者用空白字符分隔，C会将其视为串联起来的字符串字面量。例如:
     char greeting [50]= "Hello, and"" how are" " you"
         						"today ! ";
     //与下面的代码等价：
     char greeting [50] = "Hello,and how are you today ! " ;
     ```

   - **字符串常量属于静态存储类别**(static storage class)，这说明如果在函数中使用字符串常量，该字符串**只会被储存一次**，在**整个程序的生命期内存在**，即使函数被调用多次。用==**双引号括起来的内容被视为指向该字符串储存位置的指针**==。这类似于把数组名作为指向该数组位置的指针。

   - ```c
     const char ar1[] = "Something is pointing at me.";
     const char * pt1 = "Something is pointing at me.";
     ```

   - 数组形式和指针形式有何不同？以上面的声明为例，**数组形式**（`ar1[]`）在**计算机的内存中分配为一个内含29个元素的数组**（每个元素对应一个字符，还加上一个末尾的空字符'\0'），每个元素被初始化为字符串字面量对应的字符。通常，字符串都作为可执行文件的一部分储存在数据段中。当把程序载入内存时，也载入了程序中的字符串。字符串储存在静态存储区（static memory）中。但是，**程序在开始运行时才会为该数组分配内存**。**此时，才将字符串拷贝到数组中**（第 12 章将详细讲解）。注意，**此时字符串**有两个副本**。一个是在**静态内存中的字符串字面量**，另一个是**储存在ar1数**组中的字符串。**此后，编译器便把**数组名ar1**识别为**该数组首元素地址**（`&ar1[0]`）的别名。这里关键要理解，==**在数组形式中，ar1是地址常量**==。不能更改ar1，如果改变了`ar1`，则意味着改变了数组的存储位置（即地址）。可以进行类似`ar1+1`这样的操作，标识数组的下一个元素。但是不允许进行`++ar1`这样的操作。递增运算符只能用于变量名前（或概括地说，只能用于可修改的左值），不能用于常量。**指针形式（*pt1）**也使得编译器为字符串在静态存储区预留29个元素的空间。另外，一旦开始执行程序，它会为指针变量pt1留出一个储存位置，并把字符串的地址储存在指针变量中。**该变量最初指向该字符串的首字符，但是它的值可以改变。**因此，可以使用递增运算符。例如 `++pt1`将指向第2 个字符（o）。字符串字面量被视为`const`数据。由于`pt1`指向这个`const`数据，所以应该把`pt1`声明为指向`const`数据的指针。这意味着不能用pt1改变它所指向的数据，但是仍然可以改变`pt1`的值（即，`pt1`指向的位置）。如果把一个字符串字面量拷贝给一个数组，就可以随意改变数据，除非把数组声明为`const`。==**总之，初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针。**==
   
2. 数组和指针的区别

   - ```c
     char heart[]="I love Tilllie";
     const char *head="I love Tilllie";
     ```

   - `head = heart;`不会导致`head`指向的字符串消失，这样做只是改变了储存在`head`中的地址。除非已经保存了`"I love Millie!"`的地址，否则当`head`指向别处时，就无法再访问该字符串。

   - ```c
     char * p1 = "Klingon";
     p1[0] = 'F'; // ok?
     printf("Klingon");
     printf(": Beware the %ss!\n", "Klingon");
     ```

   - 编译器可以使用**内存中的一个副本**来**表示所有完全相同的字符串字面量**。也就是说，编译器可以用相同的地址替换每个`"Klingon"`实例。如果编译器使用这种单次副本表示法，并允许`p1[0]`修改`'F'`，那将影响所有使用该字符串的代码。
     
   - 如果要用**数组表示一系列待显示的字符串**，**请使用指针数组**，因为它比二维字符数组的效率高。但是，指针数组也有**自身的缺点**：==**指针指向的字符串字面量不能更改**==。

3. 字符串输入

   - `puts()`函数只显示字符串,而且自动在显示的字符串末尾**加上换行符**。
   - `gets()`它读取整行输入，直至遇到换行符，然后**丢弃换行符**，储存其余字符，并在这些字符的末尾**添加一个空字符**使其成为一个 C 字符串。
     - **C11标准委员**会采取了更强硬的态度，直接**从标准中废除了gets()函数**。
     - 编译器为了能兼容以前的代码，大部分都继续支持gets()函数。
     - C11标准新增的`gets_s()`是`stdio.h`输入/输出函数系列中的**可选扩展**，所以支持C11的编译器也不一定支持它。
       - 如果`gets_s()`读到**最大字符数都没有读到换行符**，会执行以下几步。首先把**目标数组中的首字符设置为空字符**，**读取并丢弃随后的输入直**至读到换行符或文件结尾，然后**返回空指针**。接着，**调用依赖实现的“处理函数”**（或你选择的其他函数），可能会中止或退出程序。
   - `fgets()&fputs`
     - `fgets()`**第2个参数**指明了读入**字符的最大数量**，如果该参数的值是n，那么`fgets()`将读入n-1个，**字符最后一个字符为'\0'**，或者读到遇到的第一个换行符为止。
     - `fgets()`**读到一个换行符**，会把它**储存**在字符串中。
     - `fgets()`的**第3 个参数**指明要**读入的文件**，读入**从键盘输入**的数据，则以**stdin**（标准输入）作为参数，该标识符定义在`stdio.h`中。
     - `fgets()` 函数在成功读取时返回指向存储输入字符串的指针。如果发生错误或到达文件末尾且未读取任何字符，则返回 `NULL`
     - `fputs()`函数返回指向 char的指针。如果一切进行顺利，该**函数返回的地址与传入的第 1 个参数相同**。但是，如果**函数读到文件结尾**，它将返回一个特殊的指针：**空指针**(NULL)
     - `fputs()`**不在字符串末尾添加换行符**。
   - ==处理字符串的函数通常都不知道数组的大小，这些**函数通过查找字符串末尾的空字符**确定字符串在何处结束==
   
4. 字符串输出

   - `fputs()`函数的**第 2 个参数指明要写入数据的文件**。如果要打印在显示器上，可以用定义在`stdio.h`中的`stdout`作为该参数。`fputs()`==**不会在输出的末尾添加换行符。**==
   - `puts()`应与`gets()`配合使用，`fputs()`应与`fgets()`配合使用。
   - **`*string`当string指向空字符时，`*string`的值是0**

5. `string.h`字符串处理函数

   - `strcat()`该函数把**第2个字符串的备份附加在第1个字符串末尾**，并把拼接后形成的新字符串作为第1个字符串，`strcat()`函数**返回第1个参数**。
     - `strcat()`函数无法检查第1个数组是否能容纳第2个字符串，`strncat()`该函数的**第3 个参数指定了最大添加字符数**，**在加到第n个字符或遇到空字符时停止。**
   - `strcmp()`如果**两个字符串参数相同，该函数就返回0**，否则返回非零值。
     - `strcmp()`函数**比较的是字符串，不是整个数组**，`strcmp()`函数只会比较try中第1个空字符前面的部分。
     - 两者的ASCII码之差，`strcmp()`会依次比较每个字符。
     - `strncmp()`函数在比较两个字符串时，可以比较到字符不同的地方，**也可以只比较第3个参数指定的字符数**。
   - `strcpy()`
     - `strcpy()`的返回类型是 `char *`，该函数返回的是第 1个参数的值，即一个字符的地址。
     - 第 1 个参数不必指向数组的开始。这个属性可用于拷贝数组的一部分。
     - `strcpy()`==**把源字符串中的空字符也拷贝在内**==
     - `strncpy()`更安全，该函数的**第 3 个参数指明可拷贝的最大字符数**。
       - n个字符或空字符之前的字符（先满足哪个条件就拷贝到何处），
       - **如果目标空间装不下副本，因该把副本最后一个元素设置为空字符。**
   - 其它字符串函数
     - `char *strchr(const char * s, int c);`
       - 如果**s字符串中包含c字符**，该函数**返回指向s字符串首位置的指针**（末尾的空字符也是字符串的一部分，所以在查找范围内）；如果在字符串s中未找到c字符，该函数则返回空指针。
     - `char *strpbrk(const char * s1, const char * s2);`
       - 如果 **s1 字符中包含 s2 字符串中的任意字符**，该函数**返回指向 s1 字符串首位置的指针**；如果在s1字符串中未找到任何s2字符串中的字符，则返回空字符。
     - `char *strrchr(const char * s, int c);`
       - 该函数返回**s字符串中c字符**的**最后一次出现的位置**。
     - `char *strstr(const char * s1, const char * s2);`
       - 该函数返回指向**s1字符串中s2字符串**出现的首位置。

6. `sprintf()`

   - 把数据写入字符串，而不是打印在显示器上。
   - `sprintf()`的第1个参数是目标字符串的地

7. 命令行参数

   - `int main(int argc, char *argv [])`
   - 如果系统允许（一些操作系统不允许这样），就把**程序本身的名称赋给**
     `argv[0]`，然后把随后的第1个字符串赋给`argv[1]`，以此类推。
   - `char **argv与char *argv[]`等价
   - 许多环境（包括UNIX和DOS）都**允许用双引号把多个单词括起来形成一个参数。**

8. 把字符串转换为数字

   - `#include<stdlib.h>`
     - `atof() atol() `
     - `atof()`函数把字符串转换成 `double` 类型的值， `atol()`函数把字符串转换成`long`类型的值。
   - 如果**字符串仅以整数开头**，`atoi()`函数也能处理，它只**把开头的整数转换为字符。**
   - 在我们所用的C实现中，如果命令行参数不是数字，`atoi()`函数返回0。然而C标准规定，这种情况下的行为是未定义的。
   - ==**更智能的函数**==：`strtol()`把字符串转换成long类型的值，`strtoul()`把字符串转换成`unsigned long`类型的值，`strtod()`把字符串转换成`double`类型的值。这些函数的智能之处在于识别和报告字符串中的首字符是否是数字。而且，`strtol()`和`strtoul()`还可以**指定数字的进制**。
   - `long strtol(const char * restrict nptr, char ** restrict endptr, int base);`
     - `nptr`是指向**待转换字符串的指针**，`endptr`是**一个指针的地址**，该指针被设置为**标识输入数字结束字符的地址**，base表示以什么进制写入数字。
     - `strtol()`函数最多可以转换三十六进制，'a'~'z'字符都可用作数字。
     - `strtod()`函数只以十进制转换，因此它值需要两个参数。

### 存储类别，链接和内存管理

1. 作用域

   - 作用域描**述程序中可访问标识符的区域**。一个C变量的作用域可以是**块作用域、函数作用域、函数原型作用域或文件作用域。**
     
   - **以前**，具有**块作用域的变量都必须声明在块的开头**。**C99 标准放宽了这一限制**，允许在块中的任意位置声明变量。
     
   - **函数原型作用域**的范围是**从形参定义处到原型声明结束**。这意味着，编译器在处理函数原型中的形参时只关心它的类型，而形参名（如果有的话）通常无关紧要。而且，**即使有形参名**，**也不必与函数定义中的形参名相匹配。**
     
   - ==**变量的定义在函数的外面，具有文件作用域（file scope）。具有文件作用域的变量，从它的定义处到该定义所在文件的末尾均可见。**==
     
   - **C 变量**有 **3 种链接属性**：**外部链接**、**内部链接或无链接**。具有块**作用域**、**函数作用域**或**函数原型作用域的变量都是无链接变量**。这意味着这些变量属于定义它们的块、函数或原型私有。具有**文件作用域的变量**可以是**外部链接或内部链接**。**外部链接变量**可以在**多文件程序**中使用，==**内部链接变量**只能在**一个翻译单元**中使用。==
   
     ```c
     static int dodgers = 3;//文件作用域，内部链接
     int giants = 5;//文件作用域，外部链接
     ```
   
2. 存储期

   - 静态存储期：它在程序的执行期间一直存在。
     - **文件作用域变量**具有静态存储期
   - 线程存储期：具有线程存储期的对象，从被声明时到线程结束一直存在。
     - 以关键字_Thread_local声明一个对象时，每个线程都获得该变量的私有备份。
   - 自动存储期：块作用域的变量通常都具有自动存储期。当程序进入定义这些变量的块时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存。
     - 变长数组稍有不同，它们的存储期从声明处到块的末尾，而不是从块的
       开始处到块的末尾。
     - **块作用域变量也能具有静态存储期**。声明前面加上**关键字static**。
   - 动态分配存储期：

3. 自动变量

   - ```c
     int loop(int n)
     {
     	int m;
     	scanf("%d", &m);
     	{
     		int i;//i变量只有在使用时才占用内存
     				
     		for (i = m; i < n; ++i)
     		{
     			puts("i is local to a sub-block\n");
     		}
     	}
     	return m;
     	//变量n和 m 分别定义在函数头和外层块中，
     	//它们的作用域是整个函数，而且在调用函数到函数结束期间都一直存在。
     }
     int main()
     {
         //内层块中声明的变量与外层块中的变量同名
         //内层块会隐藏外层块的定义。但是离开内层块后，外层块变量的作用域又回到了原来的作用域。
         
         	int x = 30;//原始的x
     	printf("x in outer block:%d at %p\n", x, &x);
     	{
     		int x = 77;//新的x，隐藏了原始的x
     		printf("x in inner block:%d at %p\n", x, &x);
     	}
     	printf("x in outer block:%d at %p\n", x, &x);//原始的x
     }
     //gcc -std=c11
     ```

   - **自动变量不会初始化，除非显式初始化它。**

   - 寄存器变量

     - **寄存器变量储存在寄存器**而非内存中，所以**无法获取寄存器变量的地址**。绝大多数方面，寄存器变量和自动变量都一样。
     - 声明变量为`register`类别与直接命令相比更像**是一种请求**。编译器必须**根据寄存器或最快可用内存的数量衡量你的请求**，或者直接忽略你的请求，所以可能不会如你所愿。
     - `register int quick;`

   - 有**意覆盖一个外部变量定义**，或者**强调不要把该变量改为其他存储类别**，可以显式使用**关键字auto**。

4. 块作用域的静态变量

   - ```c
     void trystat(void)
     {
     	int fade = 1;
     	static int stay = 1;
     	printf("fade = %d and stay = %d\n", fade++, stay++);
     }
     ```

   - 第1条声明确实是`trystat()`函数的一部分，每次调用该函数时都会执行这条声明。这是运行时行为。第2条声明实际上并不是`trystat()`函数的一部分。如果逐步调试该程序会发现，程序似乎跳过了这条声明。这是因为**静态变量和外部变量在程序被载入内存时已执行完毕。**把这条声明放在`trystat()`函数中是为了告诉编译器只有`trystat()`函数才能看到该变量。这条声明并未在运行时执行。
   
5. 外部链接的静态变量

   - ```c
     int Errupt;
     double up[100];
     extern char Coal;//如果Coal被定义在另一个文件中，则必须这样声明。
     int main(void)
     {
         extern int Errupt;//为了指出该函数使用了外部变量，可以在函数中使用关键字extern再次声明。可选的声明。
         				//表明要使用外部变量Errupt
         extern double Up[];
     }
     ```

   - **在执行块中的语句时，块作用域中的变量将“隐藏”文件作用域中的同名变量。**

   - 如果**未初始化外部变量**，他们会被==**自动初始化为0**==，这一原则也同样适用于外部定义的数组元素。==**只能使用常量表达式初始化文件作用域变量**==。

6. 存储类别和函数

   - 外部函数可以被其他文件的函数访问，但是**静态函数只能用于其定义所在的文件。**

   - 用 extern 关键字**声明**定义在其他文件中的函数。这样做是为了表明当前文件中使用的函数被定义在别处。除非使用static关键字，否则一般**函数声明都默认为extern。**

     ```c
     double gamma(double);　　　/* 该函数默认为外部函数 */
     static　double　beta(int,　int);
     extern　double　delta(double,　int);
     ```

7. 随机数

   - `rand()`生成的随机数在0~RAND_MAX之间。RAND_MAX被定义在`stdlib.h`中。
   - `srand((unsigned int)time(0));`时钟种子，每次随机都随着时间变化。

8. 分配内存：malloc()和free()

   - `malloc()`

     - 该函数接收一个参数：**所需要的字节数**，返回动态分配内存块的**首字节地址**（**指向void的指针**，ANSI C标准)，分配失败返回空指针。

     - ```c
       double *ptd;
       ptd=(double*)malloc(30*sizeof(double));
       ```

     - 在c中不一定要使用强制类型转换，**但在C++中必须使用**。所以，使用强制类型抓换更容易把C程序转会为C++程序。

     - `calloc()`

       - 第一个参数所需的存储单元数量，第二个参数是存储单元的大小。`calloc()`**把块中所有的位都设置位0**。

   - `free()`

     - 函数的**参数**是之前**malloc()返回的地址**，该函数释放之前malloc()分配的内存。
     - `free()`所用的指针变量可以与`malloc()`的指针变量不同，但是**两个指针必须存储相同的地址。**

   - 原型在`stdlib.h`中。EXIT_FAILURE表示程序异常终止，EXIT_SUCCES表示普通的程序结束。

   - 静态数据（包括字符串字面量）占用一个区域，自动数据占用另一个区域，动态分配的数据占用第3个区域（通常被称为**内存堆或自由内存**）。

9. ANSI C类型限定符

   - C99 为类型限定符增加了一个新属性：它们现在是幂等的。意思是**可以在一声明中多次使用同一个限定符，多余的限定符将被忽略。**
     - `const const const int n = 6`
   - `const float *pf`，**pf指向的值不能被改变，而pt本身的值可以改变。**
   - `float* const pf，float const * pfc; /`，**pt本身的值不能更改**。pt必须指向同一个地址，但是它所指向的值可以改变。
   - `volatile`
     - 用volatile修饰的变量表示：代理（而不是变量所在的程序）可以改变该变量的值。如果声明中没有volatile关键字，编译器会假定变量的值在使用过程中不变，然后再尝试优化代码。
   - restrict
     - restrict 关键字**允许编译器优化某部分代码**以更好地支持计算。**它只能用于指针**，**表明该指针是访问数据对象的唯一且初始的方式。**
   - _Atomic类型限定符(c11)
   
10. 旧关键字的新位置

    - ```c
      void ofmouth(int *const al,int *restrict a2,int n);//以前的风格
      void ofmouth(int al[const],int a2[restrict],int n);//c99 允许
      
      double stick(double ar[static 20]);
      ```

    - static 的这种用法表明，**函数调用中的实际参数应该是一个指向数组首元素的指针，且该数组至少有20个元素。**这种用法的目的是让**编译器使用这些信息优化函数的编码。**

### 文件输入/输出

1. `fopen()`函数

   - | 模式字符串                            | 含义                                                         |
     | ------------------------------------- | ------------------------------------------------------------ |
     | "r"                                   | 以**读**模式打开文件                                         |
     | "w"                                   | 以**写**模式打开文件，把**现有文件的长度截为0**，如果**文件不存在**，则**创建**一个新文件 |
     | "a"                                   | 以**写**模式打开文件，在现有**文件末尾添加内容**，如果文件不存在，则**创建**一个新文件 |
     | "r+"                                  | 以**更新**模式打开文件（即可以读写文件）                     |
     | "w+"                                  | 以**更新**模式打开文件（即，读和写），如果文件存在，则将其长度截为0；如果文件不存在，则创建一个新文件 |
     | "a+"                                  | 以**更新**模式打开文件（即，读和写），在现有**文件的末尾添加内容**，如果文件不存在，则创建一个新文件；可以读整个文件，但是只能从末尾添加内容 |
     | "rb","wb","ab","ab+","a+b","wb+",w+b" | 与上一个模式类似，但是以二进制模式而不是文本模式打开文件     |
     | "wx","wbx","w+x","wb+x"或"w+bx"       | (c11)类似非x模式，但是如果文件已经存在或以独占模式打开文件，则打开文件失败。 |

   - 程序成功打开文件后，`fopen()`将返回文件指针，其中包含操作文件的I/O函数所用的缓冲区信息。

   - `getc()`和`putc()`

     - `getc()`和`putc()`函数与`getchar()`和`putchar()`函数类似。所不同的是，要告诉`getc()`和`putc()`函数使用哪一个文件。

     - `putc()`函数的参数列表中，**第1个参数是待写入的字符**，**第2个参数是文件指针。**
       
     - `stdout`作为==**与标准输出相关联的文件指针**==，定义在stdio.h中
     
       - | 标准文件 | 文件指针 | 通常使用的设备 |
         | -------- | -------- | -------------- |
         | 标准输入 | stdin    | 键盘           |
         | 标准输出 | stdout   | 显示器         |
         | 标准错误 | stderr   | 显示器         |
     
   - **相同的文件指针可以处理不同的文件，前提是这些文件不需要同时打开。**

2. `fclose() fclose(fp)`函数关闭`fp`指定的文件，必要时刷新缓冲区。**如果成功关闭，函数返回0，否则返回EOF**

3. `fprintf(),fscanf(),fgets(),fputs()`

   - 文件I/O函数`fprintf()`和`fscanf()`函数的工作方式与`printf()`和`scanf()`类似，区别在于前者需要用**第1个参数指定待处理的文件**。
   - `rewind()`函数让程序**回到文件开始处**。接收一个文件指针作为参数。
   - `fgets()`函数，第1个参数表示**储存输入位置的地址**，第2个参数表示**待输入字符串的大小**，**最后一个参数是文件指针**。
   - `fputs()`函数接受两个参数：**第1个是字符串的地址**；**第2个是文件指针**。`fputs()`在打印字符串时不会在其末尾添加换行符。

4. 随机访问：`fseek()`和`ftell()`

   - `fseek()`第1个参数是FILE指针，指向**带查找的文件**，==**`fopen()`因该已经打开该文件。**==第2个参数是偏移量，表示从**起点开始要移动的距离**，该参数必须是一个==**long值**==，正（前移）负（后移）0（保持不动）。**第3个参数是模式，该参数确定起点。**

   - 文件的起点模式

     - | 模式     | 偏移量的起始点 |
       | -------- | -------------- |
       | SEEK_SET | 文件开始处     |
       | SEEK_SUR | 当前位置       |
       | SEEK_END | 文件末尾       |

     - **旧的实现可能缺少这些定义**，可以使用数值0L，1L，2L分别表示这三种模式。

   - 如果一切正常`fseek()`返回0，如果出现错误返回-1。

   - `ftell()`返回的是当前的位置。

5. `fgetpos()`和`fsetpos()`

   - 第1个参数文件指针，第二个参数fpos_t类型的变量。
   - 它把`fpos_t`类型的值放在`pos`指向的位置上，该值描述了文件中的一个位置。如果**成功**，`fgetpos()`函数**返回0**；如果失败，返回非0。
   - `fpos_t`类型不是基本类型，它根据其他类型来定义。

6. 其它标准I/O函数

   - `int ungetc(int c,FILE *fp)`函数把c指定的字符放回输入流中
   - `int fflush(FILE *fp);`刷新缓冲区。如果 `fp`是空指针，所有输出缓冲区都被刷新。
   - `int setvbuf(FILE * restrict fp, char * restrict buf, int mode, size_t size);`
     - 创建了一个供标准I/O函数替换使用的缓冲区。
     - ==**在打开文件后且未对流进行其他操作之前，调用该函数。**==
     - 指针fp识别待处理的流，buf指向待使用的存储区。
     - 如果buf的值不是NULL，则必须创建一个缓冲区。例如，声明一个内含1024个字符的数组，并传递该数组的地址。然而，如果把NULL作为buf的值，该函数会为自己分配一个缓冲区。
     - mode的选择如下：`_IOFBF`**表示完全缓冲**（在缓冲区满时刷新）；`_IOLBF`**表示行缓冲**（在缓冲区满时或写入一个换行符时）；`_IONBF`**表示无缓冲**。如果操作成功，函数返回0，否则返回一个非零值。
   - `size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb,FILE * restrict fp);`
     - 指针ptr是**待写入数据块的地址**。size表示**待写入数据块的大小**（以字节为单位），nmemb表示待**写入数据块的数量**。和其他函数一样，fp指定待写入的文件。
     - `fwrite()`函数==**返回成功写入项的数量**==。正常情况下，该返回值就nmemb，但如果出现写入错误，返回值会比nmemb小。
   - `size_t fread(void * restrict ptr, size_t size, size_t nmemb,FILE * restrict fp);`
     - `fread()`函数接受的参数和`fwrite()`函数相同，该函数用于读取被`fwrite()`写入文件的数据。
     - `fwrite(),fread()`**以二进制处理文件**。
   - 如果标准输入函数返回 EOF，则通常表明函数已到达文件结尾。**然而，出现读取错误时，函数也会返回EOF**。
     - 当上一次输入调用检测到文件结尾时，`feof()`函数返回一个非零值，否则返回0。
     - 当读或写出现错误，`ferror()`函数返回一个非零值，否则返回0。

### 结构和其它数据形式

1. 如果初始化一个静态存储期的结构，**初始化列表中的值**必须是常量表达式。

2. 结构的初始化器

   - ```c
     //只初始化book结构的value成员
     struct book surprise = {.value = 10.99};
     ```

   - 现在的C允许把一个结构复制给另一个结构，**即使成员是数组，也能完成赋值**。

3. 结构中的字符数组和字符指针

   - ```c
     struct pnames
     {
         char * first;
         char * last;//指针应该只用来在程序中管理那些已分配和在别处分配的字符串。
     }
     struct pnames attorney;
     scanf("%s",attorney.last);
     //对于律师（attorney），scanf()把字符串放到attorney.last表示的地址上。由于这是未经初始化的变量，地址可以是任何值，因此程序可以把名放在任何地方。
     ```

4. 复合字面量和结构

   - ```c
     //下面是struct book类型的复合字面量
     (struct book){"The Idiot","Fyodor Dostoyevsky",6.99};
     //如果函数接受一个地址，可以传递复合字面量的地址
     &(struct book){"The Idiot","Fyodor Dostoyevsky",6.99};
     ```

5. 伸缩型数组成员

   - 规则

     - **伸缩性数组成员**必须是结构的最后一个成员

     - 结构中至少有一个成员

     - 伸缩数组的声明类似于普通数组，只是**他的方括号中是空的**

     - ```c
       struct flex
       {
       	int count;
       	double average;
       	double scores[];//伸缩型数组成员
       }
       ```

   - 声明一个struct flex类型的结构变量时，**不能用scores做任何事，因为没有给这个数组预留存储空间**。实际上，C99的意图并不是让你声明struct flex类型的变量，而是希望你声明一个指向struct flex类型的指针，然后用malloc()来分配足够的空间，以储存struct flex类型结构的常规内容和伸缩型数组成员所需的额外空间。
     
     - ```c
       struct flex * pf; // 声明一个指针
       // 请求为一个结构和一个数组分配存储空间
        pf = malloc(sizeof(struct flex) + 5 * sizeof(double));
       ```
     
   - **带伸缩型数组成员的结构有一些特俗的处理要求**
   
     - **不能用结构进行赋值或拷贝**。这样做只能拷贝除伸缩型数组成员以外的其他成员。确实要进行拷贝，应使用`memcpy()`函数
   
     - 不要以按值方式把这种结构传递给结构。
        - 不要使用**带伸缩型数组成员的结构**作为数组成员或另一个结构的成员。
   
6. 匿名结构(C11)

   - ```c
     struct names
     {
         char first[20];
         char last[20];
     };
     struct person
     {
         int id;
         struct names name;//嵌套结构成员
     };
     
     struct person
     {
         int id;
         struct {char first[20];char last[20]};//匿名结构
         //初始化和嵌套结构相同，只是在访问成员时简化了步骤，只需把first直接看作是person的成员。
     };
     ```

7. 联合简介

   - 联合是一种数据类型，他能在**同一个内存空间中储存不同的数据类型**(==不是同时储存==)。

   - ```c
     //创建联合和创建结构的方式相同，需要一个联合模板和联合变量。可以用一个步骤定义联合，也可以用联合标记分两步定义。
     union hold //带标记的联合模板
     {
         int digit;
         double bigfl;
         char letter;
     };
     ```

   - 编译器**分配足够的空间**以便它能够储存联合声明中**占用最大字节类型**。

     - 初始化联合

       - ```c
         union hold valA;
         valA.letter='R';
         union hold valB=valA;//用另一个联合来初始化
         union hold valC={88};//初始化联合的digit成员
         union hold ValD={.bigfl=118.2};//指定初始化器
         ```

     - 使用联合

       - ```c
         fit.digit = 23;//把23存储在fit，占4字节
         fit.bigfl = 2.0;//清除23，存储2.0，占8字节
         fit.letter = 'h';//清除2.0，存储h，占1字节
         ```

     - 点运算符表示正在使用哪种数据类型。在联合中，**一次只能储存一个值**。即使有足够的空间，也不能同时存储一个char类型值和一个int类型值。

     - **指针访问联合时也要使用->运算符**。

   - 匿名联合

     - 匿名联合和匿名结构的工作原理相同，即**匿名联合**是**一个结构**或**联合的**无名联合成员。

     - ```c
       struct owner
       {
           char socsecurity[12];
       };
       struct leasecompany
       {
           char name[40];
           char headquarters[40];
       };
       struct car_data
       {
           char make[15];
           int status;
           union
           {
             struct owner ownercar;
             struct leasecompany leasecar;
           };
       };
       ```

8. 枚举类型

   - 枚举类型声明符号名称来**表示整形常量**，枚举类型的目的是提高程序的可读性。

   - ```c
     enum spectrum{red,orange,yellow,green,blue,violet};
     enum spectrum color;
     //第一个声明中花括号内的标识符枚举了spectrum变量可能有的值。因此color可能的值是red，orange，yellow等
     color=bule;
     if(color==yellow)
     {
         
     }
     ```

   - 虽然**枚举符是`int`类型**，但是**枚举变量可以是任意整数类型**，前提是该整数类型可以储存枚举常量。

   - **C允许枚举变量使用++运算符，但是C++标准不允许。**

   - 默认值于赋值

     - 默认情况下，枚举列表中的常量都别赋予0，1，2等。
     - 如果**只给一个枚举常量赋值**，没有对后面的枚举常量赋值，那么**后面的常量会被赋予后续的值**。`enum feline{cat,lynx=10,puma,tiger};`

9. 共享名称空间

   - **结构标记、联合标记和枚举标记**：共享一个名称空间。
   - **普通变量和函数**：共享另一个名称空间。
   - **不同名称空间之间**：可以有相同的名称而不冲突。

10. `typedef`

       - 利用`typede`f可以为某一类型自定义名称。这方面与`#define`类似，但是两者有3处不同。

         - 与`#define`不同，`typedef`创建的符号名只**受限于类型，不能用于值**。
         
         - `typedef`由**编译器解释**，不是预处理器。
         
         - 在其受限范围内，`typedef`比`#define`更灵活。
         
         - **作用域取决于typedef定义所在的位置**。如果定义在函数中，就具有局部作用域，受限于定义所在的函数。如果定义在函数外面，就具有文件作用域。
         
         - ```c
           //typedef的一些特性与#define的功能重合。例如
                #define BYTE unsigned char
                
                //但是也有#define没有的功能
                typedef char * STRING;
                
                //但是，如果这样假设：
                #define STRING char *
                //STRING name, sign;将被翻译成：char * name, sign;
                
                //还可以把typedef用于结构：
                typedef struct complex {
                float real;
                float imag;
                } COMPLEX;
                //然后便可使用COMPLEX类型代替complex结构来表示复数。
                
                //用typedef来命名一个结构类型时，可以省略该结构的标签：
                typedef struct {double x; double y;} rect;
                //假设这样使用typedef定义的类型名：
                rect r1 = {3.0, 6.0};
                rect r2;
                //以上代码将被翻译成：
                struct {double x; double y;} r1= {3.0, 6.0};
                struct {double x; double y;} r2;
                r2 = r1;
           ```


11. 其它复杂的声明

    - | 符号 | 含义         |
      | ---- | ------------ |
      | *    | 表示一个指针 |
      | ()   | 表示一个函数 |
      | []   | 表示一个数组 |

    - ==**优先级：`()=[]>*`**==且()，[]是从左往右结合。

      - `int(*uof[3])[4];`

12. 函数和指针

    - 指向函数的指针中**储存着函数代码起始处的地址**。
    - 要声明一个**指向特定类型函数的指针**，可以**先声明一个该类型的函数**，然后**把函数名替换成(*pf)形式的表达式**。然后，pf就成为指向该类型函数的指针。
    - `pf()`和`(*pf)()` ANSI C认为这两种函数调用形式等价。
    - **`typedef void(*V_PF_CHARP)(char*)`  `V_PF_CHARP pfun;`**

### 位操作

1. 按位逻辑运算符

   - 按**位取反**`~` 把0变为1，把1变为0。
   - 按**位于**`&`二元运算符&逐位比较两个运算对象，生成一个新值。（从真/假方面看，只有**两个位都为真**时，结果才为真）。
   - 按**位或**`|`（从真/假方面看，如果两个运算对象中相应的**一个位为真或两个位为真**，那么结果为真）。
   - 按**位异或**`^`（从真/假方面看，如果两个运算对象中相应的**一个位为真且不是两个为同为1**，那么结果为真）

2. 使用方法

   1. 掩码：所谓掩码指的是一些设置为开（1）或关（0）的位组合。

      - `ch&=0xff;`这个掩码**保持`ch`中最后8位不变，其他位都设置为0。**无论`ch`原来是8位、16位或是其他更多位，最终的值都被修改为1个8位字节。**在该例中**，**掩码的宽度为8位**。

   2. 打开位

      - `flags |= MASK;`这种方法根据MASK中为1的位，把flags中对应的位设置为1，其他位不变。

   3. 关闭位

      - ```C
        //假设flags是00001111，MASK是10110110
        flags&~MASK; //(00001111)&~(10110110) 关闭MASK为1的位
        		//结果为(00001001)
        ```

   4. 切换位

      - 打开已经关闭的位，或关闭已经打开的位。（对指定的位操作）

      - ```c
        //假设flags是00001111，MASK是10110110
        flags^MASK//(00001111)^(10110110)
             //结果为(10111001) 打开MASK为是1的位
        ```

   5. 检查位的值

      - `flags`1号位是否被设置为1？我们不能直接比较flags和MASK。

      - ```c
        if((flags&MASK)==MASK)//需覆盖flags中的其它位
        {
            puts("Wow");
        }
        ```

3. 位移运算符

   - 左移`<<`将其左侧**运算对象每一位的值向左移动**其右侧运算对象指定的位数。左侧运算对象移出左末端位的值丢失，用0填充空出的位置。
   - 右移`>>`将其左侧运算对象每一位的值向右移动其右侧运算对象指定的位数。左侧运算对象移出右末端位的值丢。对于**无符号类型，用0 填充空出的位置**；对于**有符号类型，其结果取决于机器**。
   - **移位运算符针对2的幂提供快速有效的乘法和除法。**

4. 位字段

   - 位字段是一个**`signed int`或`unsigned int`类型变量**中的一组相邻的位(c99c11新增了_Bool类型的位字段)

   - ```c
     struct
     {
         unsigned int autfd :1;
         unsigned int bldfc :1;
         unsigned int undln :1;
         unsigned int itals :1;
     }prnt;
     //prnt包含4个1位的字段，由于每个字段恰好为1位，所以只能为其赋值1或0。
     //变量prnt被存储在int大小的内存单元中，只使用了其中4位。
     struct
     {
         //有些设置有多个选择，因此需要多位来表示，字段不限制1位大小。
         unsigned int code1 :2;
         unsigned int code2 :2;
         unsigned int code3 :8;
     }prcode;
     	//prcode.code2=3;
     ```

   - 如果**声明的总位数超过了一个unsigned int类型的大小**会怎样？会用到下一个unsigned int类型的存储位置。**一个字段不允许跨越两个unsigned int之间的边界。编译器会自动移动跨界的字段**，保持unsigned int的边界对齐。一旦发生这种情况，第1个unsigned int中会留下一个未命名的“洞”。
     
   - ```c
     struct
     {
         unsigned int field1 :1;
         unsigned int 		:2;//两个位的空隙。
         unsigned int field2 :1;
         unsigned int 	 	:0;//使用一个宽度为0的未命名字段迫使下一个字段与下一个整数对齐。
         unsigned int field3 :1;
     }stuff;
     ```
   
5. 对齐特性

   - `_Alignof`运算符给出一个类型的对齐要求。`size_t d_align = _Alignof(float)`
   - `_Alignas`说明符**指定一个变量或类型的对齐值**`_Alignas(double) char c1`。不因该要求该值小于基本对齐值。`_Alignas`说明符可以放在类型的前面或后面。
   - **包含`stdalign.h`**后`alignas`和`alignof`成为别名，这样可以**与C++关键字匹配。**
   - `void *aligned_alloc(size_t alignment,size_t size);`
     - 第一个参数代表**指定的对齐**，第二个参数是所需的字节数。也要用free()释放以前分配的内存。

### C预处理和C库

1. `#define`

   - **预处理指令从#开始运行，到后面的第一个换行符为止**。宏常量可以用于指定`const`变量的初始值。

   - 假设先把LIMIT定义为20，稍后在该文件中又把它定义为25。这个过程称为重定义常量。**不同的实现采用不同的重定义方案**。除非新定义与旧定义相同，否则有些实现会将其视为错误。另外一些实现允许重定义，但会给出警告。**ANSI标准采用第1种方案，只有新定义和旧定义完全相同才允许重定义。**

     - `#define SIX 2 * 3`
     - `#define SIX 2 * 3`这两条定义都有 3 个相同的记号，额外的空格不算替换体的一部分。
     - `#define SIX 2*3`这条宏定义中只有一个记号，因此与前两条定义不同。

   - 在#define中使用参数可以创建外形和作用与函数类似的**类函数宏**。

     - `#define MEAN(X,Y) ((x)+(y)/2)`。**必要时使用足够多的圆括号来确保运算和结合的正确顺序。**避免在宏中用递增或递减运算符。

   - C允许在字符串中包含宏参数。在**类函数宏**的替换体中，**#号作为一个预处理运算符，可以把记号转换成字符串**。例如，如果x是一个宏形参，那么#x就是转换为字符串"x"的形参名。这个过程称为字符串化

     - ```c
       #include<stdio.h>
       #define PSQR(x) printf("The square of" #x "is %d.\n",((x)*(x))
       int main(void)
       {
           int y = 5;
           PSQR(y);//#x 被替换为 y
           PSQR(2+4);//#x被替换为2+4
           return 0;
       }
       ```

   - 预处理器粘合剂：`##`

     - 与#运算符类似，##运算符可用于类函数宏的替换部分。而且，##还可
       用于对象宏的替换部分。**##运算符把两个记号组合成一个记号**。

       - ```c
         #include<stdio.h>
         
         #define XNAME(n) x ## n
         #define PRINT_XN(n) printf("x" #n "= %d\n",x##n)
         int main(void)
         {
             int XNAME(1) = 14; //n是1，组合成一个记号x1
             int XNAME(2) = 20;
             int x3 = 30;
             PRINT_XN(1);
             PRINT_XN(2);
             PRINT_XN(3);
             return 0;
         }
         ```

2. 变参宏`...`和`__VA_ARGS__`

   - ```c
     #define PR(...) printf(__VR_ARGS__)
     
     PR("Howdy");//_ _VA_ARGS_ _展开为1个参数："Howdy"。
     PR("weight = %d, shipping = $%.2f\n", wt, sp);
     			//，_ _VA_ARGS_ _展开为3个参数："weight = %d,shipping = $%.2f\n",wt,sp。
     ```

   - **宏生成内联代码**，即在程序中生成语句。如果调用20次宏，即在程序中插入20行代码。

3. `#include`

   - 头文件中最常用的形式
     - 明示常量，宏函数，函数声明，结构模板定义，类型定义

4. 其它指令

   - `#if,#ifdef,#ifndef,#else,#elif,#endif`用于指定什么情况下编写哪些代码。

   - `#line`用于重置行和文件信息

   - `#error`用于给出错误消息

   - `#pragma`用于向编译器发出指令

   - `#undef`用于取消已经定义的`#define`指令

   - 条件编译

     - ```c
       #ifdef MAVIS
       	#include"horse.h" //如果已经用#define定义了MAVIS，则执行下面的指令
       	#define STABLES 5
       #else //没有用#define定义MAVIS
       	#include"cow.h"
       	#define STABLES 15
       #endif
       //较新的编译器和ANSI标准支持的缩进格式
       ```

     - `#ifndef`指令与`#ifdef`指令的用法类似，也可以和`#else`、`#endif`一起使用，**但是它们的逻辑相反**。

       - 包含多个头文件时，其中的文件可能包含了相同宏定义。`#ifndef`指令可以防止相同的宏被重复定义。

         - ```c
           #ifndef SIZE
           	#define SIZE 100
           #endif
           ```

       - `ifndef`指令通常用于防止多次包含一个文件。

         - ```c
           #ifndef THINGS_H_
           #define THINGS_H_
           	/*
           	一些声明
           	
           	*/
           #endif
           ```

     - `#if`和`#elif`

       - `#if`指令很像C语言中的`if`。`#if`后面跟整型常量表达式

         - ```c
           #if SYS == 1
           	#include "ibmpc.h"
           #elif SYS == 2
           	#include "vax.h"
           #elif SYS == 3
           	#include "mac.h"
           #else
           	#include "general.h"
           #endif
           ```

       - **较新的编译器提供另一种方法测试名称是否已定义**，即用`#if defined(VAX)`代替`#ifdef VAX`

         - ```c
           
           //defined是一个预处理运算符，如果它的参数是用#defined定义过，则返回1，否则返回0
           #if defined (IBMPC)
           	#include "ibmpc.h"
           #elif defined (VAX)
           	#include "vax.h"
           #elif defined (MAC)
           	#include "mac.h"
           #else
           	#include "general.h"
           #endif
           ```

5. 预定义宏

   - | 宏                 | 含义                                                  |
     | ------------------ | ----------------------------------------------------- |
     | `__DATE__`         | 预处理的日期"mm dd yy"                                |
     | `__FILE__`         | 表示当前源代码文件名的字符串字面量                    |
     | `__LINE__`         | 表示当前源代码文件中行号的整形常量                    |
     | `__STDC__`         | 设置为1时，表示实现遵循C标准                          |
     | `__STDC_HOSTED__`  | 本机环境设置为1，否则设置为0                          |
     | `__STDC_VERSION__` | 支持C99标准，设置为19901L；支持C11标准，设置为201112L |
     | `__TIME__`         | 翻译代码的时间"hh:mm:ss"                              |

   - `__func__`函数名

6. `#line`和`#error`

   - `#line`指令重置`__LINE__`和`__FILE__`宏报告的行号和文件名。

     - `#line 10 "cool.c"`行号重置为10，把文件名重置为cool.c

   - `#error`指令**让预处理器发出一条错信息**，该消息包含指令中的文本。**如果可能的话，编译过程因该中断**。

     - ```c
       #if __STDC_VERSOPM__ != 201112L
       #error Not C11
       #endif
       ```

7. 内敛函数

   - C99和C11标准中叙述的是：“把函数变成内联函数**建议尽可能快地调用该函数，其具体效果由实现定义**”。因此，把函数变成内联函数，**编译器可能会用内联代码替换函数调用，并（或）执行一些其他的优化，但是也可能不起作用**。

   - 标准规定具有**内部链接的函数可以成为内联函数**，还规定了==**内联函数的定义与调用该函数的代码必须在同一个文件中**。==

     - ```c
       inline static void eatline()
       {
           while(getcher()!='\n')
           {
               continue;
           }
       }
       ```

     - 由于并**未给内联函数预留单独的代码块，所以无法获得内联函数的地**（实际上可以获得地址，不过这样做之后，编译器会生成一个非内联函数）。另外，内联函数无法在调试器中显示。

     - **内联函数应该比较短小**。把较长的函数变成内联并未节约多少时间，因为执行函数体的时间比调用函数的时间长得多。
   
8. `_Noreturn`函数

   - C11新增了第2个函数说明符`_Noreturn`，表**明调用完成后函数不返回主调函数。**

9. C库

   - | 原型                                | 描述                               |
     | ----------------------------------- | ---------------------------------- |
     | `double acos (double x)`            | 返回余弦值为x的角度(0~π弧度)       |
     | `double asin (double x)`            | 返回正弦值为x的角度(- π/2~π/2弧度) |
     | `double atan (double x)`            | 返回正切值为x的角度(-π/2~π/2弧度)  |
     | `double atan2 (double y, double X)` | 返回正弦值为y/x的角度(-π~π弧度)    |
     | `double cos (double x`              | 返回x的余弦值，x的单位为弧度       |
     | `double sin (double x)`             | 返回x的正弦值，x的单位为弧度       |
     | `double tan (double x)`             | 返回x的正切值，x的单位为弧度       |
     | `double exp (double x)`             | 返回x的指数函数的值(e*)            |
     | `double log (double x)`             | 返回x的自然对数值                  |
     | `double log10 (double x)`           | 返回x的以10为底的对数值            |
     | `double pow (double X，double y)`   | 返回**x的y次幂**                   |
     | `double sqrt (double x)`            | 返回x的**平方值**                  |
     | `double cbrt (double x)`            | 返回x的**立方值**                  |
     | `double ceil (double x)`            | 返回不小于x的最小整数值            |
     | `double fabs (double x)`            | 返回x的绝对值                      |
     | `double floor (double x)`           | 返回不大于x的最大整数值            |

     - C标准专门为float类型和long double类型提供了标准函数，即在**原函数名前**
       **加上f或l后缀**。因此，sqrtf()是sqrt()的float版本，sqrtl()是sqrt()的long double版本。

     - ```c
       // 泛型平方根函数
       #define SQRT(X) _Generic((X),\
           long double: sqrtl, \
           default: sqrt, \
           float: sqrtf)(X)
       
       // 泛型正弦函数，角度的单位为度
       #define SIN(X) _Generic((X),\
       long double: sinl((X)/RAD_TO_DEG),\
       default:     sin((X)/RAD_TO_DEG),\
       float:       sinf((X)/RAD_TO_DEG)\
       )
       
       ```

   - `tgmath.h`

     - C99标准提供的`tgmath.h`头文件中定义了**泛型类型宏**。根据提供的参数类型，定义 sqrt()宏展开为sqrtf()、sqrt()或 sqrtl()函数。

       - 如果包含了tgmath.h，**要调用sqrt函数**而不是sqrt()宏，可以**用圆括号把被调用的函数名括起来。**

       - ```c
         #include<tgmath.h>
         float x = 44.0;
         double y;
         y = sqrt(x);//调用宏
         y = (sqrt)(x);//调用函数
         ```

10. 通用工具库

    - `atexit()`
      - 把**退出时要调用的函数**地址传递给 `atexit()`即可，当调用`exit()`时就会执行这些函数。ANSI保证，在这个列表中至少可以放 32 个函数。最后调用 `exit()`函数时，`exit()`**会执行这些函数**，执行顺序与列表中的函数**顺序相反**
      - `atexit()`**注册的函应该不带任何参数且返回类型为void**。通常，这些函数会执行一些清理任务
      - `main()`结束时会隐式调用exit()。
      - exit()执行完atexit()指定的函数后，会完成一些清理工作：刷新所有输出
        流、关闭所有打开的流和关闭由标准I/O函数tmpfile()创建的临时文件。然后exit()把控制权返回主机环境，如果可能的话，向主机环境报告终止状态。通常，UNIX程序使用0表示成功终止，用非零值表示终止失败。UNIX返回的代码并不适用于所有的系统，所以ANSI C为了**可移植性的要求**，定义了一个名为**EXIT_FAILURE**的宏表示终止失败。类似地，ANSI C还定义了**EXIT_SUCCESS**表示成功终止。
    - `qsort()`
      - `void qsort(void *base, size_t nmemb, size_t size,int (*compar)(const void *, const void *));`
        - 第1个参数是指针，指向待**排序数组的首元素**。
        - 第2个参数是**待排序项的数量**
        - 第 3 个参数显式指明待排序数组中**每个元素的大小**
        - 比较函数用于确定**排序的顺序**。
          - 如果第1项的值大于第2项，比较函数则返回正数；如果两项相同，则返回0；如果第1项的值小于第2项，则返回负数。
      - ANSI C允许把==**指向任何数据类型的指针强制转换层指向void的指针**。==
      - **C++要求把`void*`指针赋给任何类型的指针时都进行强制类型钻换。**
    - 短语库
      - `assert.h`
        - 由assert()宏组成，**接收一个整形表达式作为参数。如果表达式为假，**`assert()`宏就在标准错误流(stderr)中**写入一条信息，并调用abort()函数终止函数。**(`abort()`函数原型在`stdlib.h`头文件中
        - assert()有几个好处：它不仅能自动标识文件和出问题的行号，还有一种无需更改代码就能开启或关闭 assert()的机制。==**如果认为已经排除了程序的 bug，就可以把下面的宏定义写在包含assert.h的位置前面**==：`#define NDEBUG`
        - `_Static_assert()`C11
          - `_Static_assert`声明，可以在**编译时检查assert()表达式**。因此，assert()可以导致正在运行的程序中止，**而_Static_assert()可以导致程序无法通过编译。**
          - 第1个参数**整形常量表达式**，第2个参数是一个字符串，表达式为0，编译器为打印字符串
    - `string.h`库中的`memcpy()`和`memmove()`
      - `void *memcpy(void * restrict s1, const void * restrict s2, size_t n);`
        - 假设**两个内存区域之间没有重叠**
        - 所以拷贝过程**类似于先把所有字节拷贝到一个临时缓冲区，然后再拷贝到最终目的地**。
      - `void *memmove(void *s1, const void *s2, size_t n);`
      - 两个函数都从 s2 指向的位置**拷贝 n 字节**到 s1 指向的位置，而且都返
        回 s1 的值。

11. 可变参数：`stdarg.h`

    - 提供一个使用省略号的函数原型；
      在函数定义中创建一个`va_list`类型的变量；
      用宏把**该变量初始化为一个参数列表**；
      用宏**访问参数列表**；
      用宏**完成清理工作**。

    - ```c
      #include<stdio.h>
      #include<stdarg.h>
      //即省略号的前一个形参起着特殊的作用，标准中用parmN这个术语来描述该形参。传递给该形参的实际参数是省略号部分代表的参数数量。
      double sum(int, ...);
      int main(void)
      {
      	double s, t;
      	s = sum(3, 1.1, 2.5, 13.3);
      	t = sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6, 1);
      	
      	printf("return value for s %g\n", s);
      	printf("return value for t %g\n", t);
      	
      	return 0;
      }
      double sum(int lim, ...)
      {
      	va_list ap; //类型代表一种用于储存形参对应的形参列表中省略号部分的数据对象。
      	double tot = 0;
      	int i;
          
          va_list apcopy;
          va_copy(ap,apcopy);
          
      //使用定义在stdarg.h中的va_start()宏，把参数列表拷贝到va_list类型的变量中。该宏有两个参数：va_list类型的变量和parmN形参。
          
      	va_start(ap, lim);// 把ap初始化为参数列表
      	for (i = 0; i < lim; ++i)
      	{
              
      //访问参数列表的内容，这涉及使用另一个宏va_arg()。该宏接受两个参数：一个va_list类型的变量和一个类型名。第1次调用va_arg()时，它返回参数列表的第1项；第2次调用时返回第2项，以此类推。
      		tot += va_arg(ap, double);
      	}
      	va_end(ap);
      //最后，要使用va_end()宏完成清理工作。例如，释放动态分配用于储存参数的内存。
          
      	return tot;
      }
      ```

    - 因为`va_arg()`**不提供退回之前参数的方法**，所以有必要保存`va_list`类型变量的副本。C99新增了一个宏用于处理这种情况：`va_copy()`。**该宏接受两个`va_list`类型的变量作为参数，它把第2个参数拷贝给第1个参数**

