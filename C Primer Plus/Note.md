### C语言的概述

语言与命名规则

以前的C语言，还要求把变量声明在块的顶部，其它语句不能放在任何声明的前面。

```c
  int main()
    {
        int doors;//旧规则
        int dogs;
        doors=5
        dogs=3;
      	//其它语句
      
      	//c99和c11遵循c++的惯例，可以把声明放在块中的任何位置。
    }
```

C99和C11允许使用更长的**标识符名**， 但是**编译器只识别前63个字符**。对于**外部标识符**（参阅第12章）， 只允许使用**31个字符**。实际上， 你可以使用更长的字符， 但是编译器会忽略超出的字符。**小写字母、 大写字母、 数字和下划线（＿）来==命名==**。 而且， 名称的**第1个字符必须是字符或下划线**， ==不能是数字== 。操作系统和C库经常使用以一个或两个下划线字符开始的标识符（如， `＿kcab`)，因此最好避免在自己 的程序中使用这种名称。C语言的名称区分大小写。

C语言关键字中，**粗体表示的是C90标准新增的关键字**，**斜体**表示的C99标准新增的关键字，**粗斜体**表示的是C11标准新增的关键字

|    auto     |   extern   |     short      |         while          |
| :---------: | :--------: | :------------: | :--------------------: |
|   `break`   |  `floa`t   |  **`signed`**  |    ***`_Alignas`***    |
|   `case`    |   `for`    |    `sizeof`    |    ***`_Alignof`***    |
|   `char`    |   `goto`   |    `static`    |    ***`_Atomic`***     |
| **`const`** |    `if`    |    `struct`    |     ***`_Bool`***      |
| `continue`  |  `inline`  |    `switch`    |    ***`_Complex`***    |
|  `default`  |   `int`    |   `typedef`    |    ***`_Generic`***    |
|    `do`     |   `long`   |    `union`     |   ***`_Imaginary`***   |
|  `double`   | `register` |   `unsigned`   |   ***`_Noreturn`***    |
|   `else`    | `restrict` |     `void`     | ***`_static_assert`*** |
| **`enum`**  |  `return`  | **`volatile`** | ***`_Thread_local`***  |

----

### 数据和C



1. 数据类型和关键字

   - 在`printf()`中使用**`%f`**来**处理浮点值**。%.2f中的**.2 用于精确控制输出**，指定输出的浮点数只显示小数点后面两位。
   - `char`类型也可以表示较小的整数。
   - `_Bool`类型表示布尔值（`true`或`false`），`_complex`和`_Imaginary`分别表示复数和虚数。

2. 整数和浮点数

   - ==注意==，在一个值后面加上一个小数点，该值就成为一个浮点值。

   - 对于一些算术运算（如，两个很大的数相减），**浮点数损失的精度更多** 因为在**任何区间内**（如，1.0 到 2.0 之间）**都存在无穷多个实数**，所以计算机的**浮点数不能表示区间内所有的值**。浮点数通常只是实际值的近似值。例如，7.0可能被储存为浮点值6.99999。
     
   - C 初始化变量的三种方式

     ```c
    int erns;
     int hogs, cows, goats;
     cows = 112;
     
     //通过函数（如，scanf()）获得值。
     
     int hogs = 21;
     int cows = 32, goats = 14;
     int dogs, cats = 94; /* 有效，但是这种格式很糟糕 */
     ```
   
   - 声明为变量创建和标记存储空间，初始化则是为变量赋值，没有初始化的变量的值将会是未定义的垃圾值。

   - 0x或0X前缀表示十六进制值，0前缀表示八进制，**十进制**显示数字，使用`%d`，**八进制**显示数字，使用`%o`，以**十六进制**显示数字，使用`%x`。**显示**各进制数的**前缀**0、0x和0X，必须分别使用`%#o、%#x、%#X`

3. 其它整数类型

   - `short int`类型（或者简写为`short`）的存储空间可能比`int`类型少
   - `long int`或`long`占用的存储空间可能比`int`多
   - `long long int`或`long long`占用的储存空间可能比`long`多，该类型至少占64位。
   - `unsigned int`或`unsigned`只用于非负值的场合
   - 在**C90标准**中，添加了`unsigned long int`或`unsigned long`和`unsigned in`t或`unsigned short`类型。C99标准又添加了`unsigned long long int`或`unsigned long long`。
   - 在任何**有符号类型前**面添加关键字**`signed`**，可**强调使用有符号类型**的意
     图
   - C语言只规定了`short`占用的**存储空间不能多**于`int`，`long`占用的**存储空间不能少于**`int`。
   - **对于那些`long`占用的空间比`int`大的系统，使用`long`类型会减慢运算速度。**如果在**`long`类型和`int`类型占用空间相同的机器上编写代码**，当确实需要32位的整数时，**应使用`long`类型而不是`int`类型**，以便把程序移植到16位机后仍然可以正常工作。
   - 如果在`int`设置为32位的系统中要使用16位的值，应使用short类型以节省存储空间。通常，只有当程序使用相对于系统可用内存较大的整型数组时，才需要重点考虑节省空间的问题。使用short类型的另一个原因是，计算机中某些组件使用的硬件寄存器是16位。
   - 要把一个较小的**常量作为long类型**对待，值的**末尾加上l（小写的L）或L后缀**。也可用于**八进制和十六进制**整数，如*020L和0x10L*。支持`long long`类型的系统中，也可以使用**ll或LL**后缀来表示long long类型的值，如3LL。另外，**u或U后缀**表示`unsigned long long`，如5llu、10LLU、6LLU或9Ull。

4. 打印`short`、`long`.`long long`和`unsigned`类型

   - 打印`unsigned int %u`
   - 打印`long %ld `
   - 在`x`和`o`前面可以使用`l`前缀，`%lx`表示以十六进制格式打印`long`类型整数，`%lo`表示以八进制格式打印`long`类型整数。**转换说明中只能用小写**。
   - 打印`short %hd`表示以**十进制**显示`short`类型，`%ho`表示以**八进制**显示short类型。`h`和`l`前缀都可以和`u`一起使用，用于表示无符号类型。例如，`%lu`表示打印`unsigned long`。对于支持`long long`类型的系统，`%lld`和`%llu`分别表示有符号和无符号类型
   - 必须**确保转换说明**的==数量==和**待打印值的数量相同**，**须根据待打印值的类型使用正确的转换说明**。

5. `char`类型

   - 字符常量初始化`char grade = 'A'`;C语言中，用**单引号**括起来的**单个字符**被称为**字符常量**。**字符是以数值形式储存的**，所以也可使用数字代码值来赋值`char grade = 65`;
   - C语言将**字符常量视为int类型而非char类型**字符常量的这种特性，可以定义一个字符常量'FATE'，即把4个独立的8位ASCII码储存在一个32位存储单元中如果把这样的字符常量赋给char类型变量grade，只有最后8位有效。
   - 把**转义序列赋给字符变量**时，必须用**单引号把转义序列括起来**`char nerf = '\n';`

   | 转义序列 | 含义                                                    |
   | -------- | ------------------------------------------------------- |
   | `\a`     | 警报                                                    |
   | `\b`     | 退格                                                    |
   | `\f`     | 换页                                                    |
   | `\n`     | 换行                                                    |
   | `\r`     | 回车                                                    |
   | `\t`     | 水平制表符                                              |
   | `\v`     | 垂直制表符                                              |
   | `\\`     | 反斜杠(\)                                               |
   | `\'`     | 单引号                                                  |
   | `\"`     | 双引号                                                  |
   | `\?`     | 问号                                                    |
   | `\0oo`   | 八进制值(`oo`为有效的八进制值，每个o表示一个数值) `007` |
   | `\xhh`   | 十六进制(`hh`为有效的十六进制值，每个o表示一个数值)     |

   - `printf()`函数用==`%c`指明待打印的字符==。
   - `_Bool` 布尔值，即逻辑值`true`和`false`

6. 可移植类型 `stdint.h inttypes.h`

   - C99 新增了两个头文件`stdint.h`和`inttypes.h`，以确保C语言的类型在各系统中的功能相同。
   - C语言为现有类型创建了更多类型名。类型名定义在`stdint.h`,`int32_t`表示32位的有符号整数类型。***int32_t表示整数类型的宽度正好是32位。但是，计算机的底层系统可能不支持***
   - **最小宽度类型**。`int_least8_t`是**可容纳8位有符号整数值的类型中宽度最小的类型的一个别名**
   - 最快最小宽度类型`int_fast8_t`被定义为系统中对8位有符号值而言运算最快的整数类型的别名。
   - 最大的有符号整数类型`intmax_t`，`unitmax_t`表示最大的无符号整数类型
   - 打印`int32_t`类型的值，`inttypes.h`头文件中定义了`PRId32`字符串宏，代表打印32位有符号值的合适转换说明

7. `float double long double`

   - 1.0e9表示1.0x10^9^
   - C只保证long double类型至少与double类型的精度相同。
   - **浮点数的声明**：`2.87e-3`。==可以没有小数点==（如，2E5）==或指数部分==（如，19.28），但是**不能同时省略两者**。**不要在浮点型常量中间加空格**。
   - **编译器**假定**浮点型常量**是**double**类型的精度。加上**f或F后缀可覆盖默认设置**。使用l或L后缀使得数字成为long double类型
   - C99 标准添加十六进制表示浮点型常量 `0xa.1fp10`  **用p和P分别代替e和E**

8. `long` 打印浮点值

   - `printf()`函数使用`%f `打印十进制记数法的`float`和`double`，`%e`打印指数记数法的浮点数，如果系统支持十六进制格式的浮点数，可用`a`和`A`分别代替`e`和`E`，打印`long double`类型要使用`%Lf`、`%Le`或`%La`。
   - **未在函数原型中**显式**说明参数类型**的函数**传递参**数时，**C编译器**会把**float**类型的值**自动转换成double**类型
   - 特殊的浮点值`NaN`（not a number的缩写）

9. 复数和虚数

   - 3种复数类型：`float_Complex`、`double_Complex`和`long double _Complex`。
   - 3种虚数类型：`float_Imaginary`、`double _Imaginary`和`long double _Imaginary`
   - 包含`complex.h`头文件，便可用`complex`代替`_Complex`，用`imaginary`代替`_Imaginary`，还可以用`I`代替`-1`的平方根

10. 缓冲区刷新

    - 标准明确规定了**何时把缓冲区**中的内容**发送到屏幕**：**当缓冲区
      满**、遇到**换行字符**或需要**输入**，`fflush()`主动刷新缓冲区

### 格式化输入输出

1. `string.h` 提供`strlen()`函数的原型，==**使用%s转换说明来处理字符串的输入和输出**==。*双引号*仅告知编译器它括起来的是*字符串*，正如*单引号*用于标识*单个字符*一样。**根据`%s`转换说明，`scanf()`只会读取字符串中的一个单词**，而不是一整句。

2. C中的**字符串**一定以**空字符结束**，其ASCII码值是（或等价于）0，**数组的容量必须至少比待存储字符串中的字符数多1**。

3. `strlen()`得出字符串中的字符数==**(不包括空字符)**==

4. `sizeof `使用圆括号，圆括号的使用时机否取决于运算对象是**类型**(`sizeof(char)`)还是**特定量**(`sizeof name`)

5. 常量和C预处理器

   - `#define TAXRATE 0.015` 编译程序时，程序中所有的TAXRATE都会被替换成0.015。这一过程被称为编译时替换。这样定义的常量也称为**明示常量**。

6. ==%1.2f表明，结果被四舍五入为两位小数输出==

7. C头文件`limits.h`和`float.h`分别提供了与**整数类型**和**浮点类型大小限制相**
   **关的详细信息。**

   | 明示常量       | 含义                                            |
   | -------------- | ----------------------------------------------- |
   | CHAR_BIT       | char类型的位数                                  |
   | SCHAR_MAX      | signed char类型的最大值                         |
   | UCHAR_MIN      | unsigned char类型的最小值                       |
   | USHRT_MAX      | unsigned short类型的最大值                      |
   | FLT_MANT_DIG   | float类型的尾数位数                             |
   | FLT_DIG        | float类型的最少有效数字位数                     |
   | FLT_MIN_10_EXP | 带全部有效数字的float类型的最小负指数(以10为底) |
   | FLT_MAX_10_EXP | float类型的最大正指数(以10为底)                 |
   | FLT_MIN        | 保留全部精度的float类型最小正数                 |
   | FLT_MAX        | float类型的最大正数                             |
   | FLT_EPSILON    | 1.00和比1.00大的最小float类型值之间的差距       |

   明示常量名中的**FLT**分别替**换成DBL和LDBL**，即可分别表示**double和long double类型对应的明示常量**。

8. 转换说明及其打印的输出结果

   | 转换说明      | 输出                                                         |
   | ------------- | ------------------------------------------------------------ |
   | `%a/%A`       | 浮点数，十六进制数和p记数法（c99/c11）                       |
   | `%c`          | 单个字符                                                     |
   | `%d`          | 有符号十进制数                                               |
   | `%e/%E`       | 浮点数E计数法                                                |
   | `%g/%G`       | 根据值的不同，自动选着`%`f或`%e/%E`,`%e/%E`格式用于指数小于-4或者大于或等于精度时 |
   | `%i`          | 有符号的十进制数                                             |
   | `%p`          | 指针                                                         |
   | `%s`          | 字符串                                                       |
   | `%u`          | 无符号十进制数                                               |
   | `%x/%X`       | 无符号十六进制数，使用十六进制数0f/0F                        |
   | `%%`          | 打印一个百分号                                               |
   | 标记          | + - 空格 #和0 可以不适应标记或使用多个标记 `%-10d`           |
   | ==**数字**==  | ==最小字段宽度==，如果改字不能容纳待打印的数字或字符串，系统会使用更宽的字段`%4d` |
   | ==**.数字**== | ==精度== 。对于**`%e`，`%E`和`%`f**转换，表示**小数点右边数字的位数**。对于**`%g`和`%G`**转换，表示**有效数字最大位数**。==对于**`%s`**转换==，表示代**打印字符的最大数量**，对于**整型转换**，表示代**打印数字的最小位数**，==如有必要，使用前导0来到达这个位数==。**只使用.表示其后跟随一个0**，所以`$.f`和`%。0f`相同。`%5.2f`打印一个浮点数，字段宽度为5字符，其中小数点后有两位数字。 |
   | `h`           | 表示`short int`或`unsigned short`类型的值                    |
   | `hh`          | `signed char`或`unsigned char `类型的值 `%hhu`               |
   | `j`           | 表示`intmax_t`或`uintmax_t`类型的值                          |
   | `l`           | 表示`long int`或`unsigned int` 类型的值 `%8lu`               |
   | `ll`          | 表示` long long int` 或`unsigned long long int`的值          |
   | `L`           | 表示long double类型的值                                      |
   | `t`           | 表示`ptrdiff_t`类型的值。`ptrdiff_t`是两个指针插值的类型     |
   | z             | 表示`size_t`类型的值。`size_t`是`sizeof`返回的类型           |
   | `-`           | 待打印项左对齐                                               |
   | `+`           | 有符号值若为正，则在值前面显示加号；若为负，则在值前面显示减号 |
   | 空格          | 有符号值若为正，则在值的前面显示前导空格（不显示任何字符）；若为负，则在值前面显示减号。+覆盖一个空格 |
   | `#`           | 把结果转换为另一个形式。如果是`%o`格式，则以`0`开始；如果是`%x`或`%X`格式，则以`0`x或`0X`开始；对于所有的浮点格式，`#`保证了即使后面没有任何数字，也打印一个小数点字符。对于`%`g和`%G`格式，#防止结果后面的`0`被删除 |
   | `0`           | 对于数字格式，用前导0代替空格填充字段宽度。对于**整数格式**，如果**出现-标记**或**指定精度**，**==则忽略该标记==** |

9. **`size_t`**定义成系统使用`sizeof`返回的类型这被称为底层类型

10. 转换说明的含义

    - 转换说明把**以二进制格式储存在计算机中的值转换成一系列字符**（字符串）以便于显示。例如，数字76在计算机内部的存储格式是二进制数01001100。`%d`转换说明将其转换成字符7和6，并显示为76；`%d`的意思是“把给定的值翻译成十进制整数文本并打印出来”。

11. `printf()`函数也有一个返回值，它**返回打印字符的个数**。如果有输出错误，
    `printf()`则返回一个负值（`printf()`的旧版本会返回不同的值）。==**计算针对所有字符数，包括空格和不可见的换行符（\n）。**==

    - ```c
      //不能在双引号括起来的字符串中间断行
      	printf("The printf() function printed %d
      			characters.\n", rv);
      /*C编译器会报错：字符串常量中有非法字符。在字符串中，可以使用\n
      来表示换行字符，但是不能通过按下Enter（或Return）键产生实际的换行
      符。*/
          printf("Here's another way to print a \
      long string.\n");
                 /*用反斜杠（\）和Enter（或Return）键组合来断行。这使得光标移至下一行，而且字符串中不会包含换行符。其效果是在下一行继续输出。但是，下一行代码必须和程序清单中的代码一样从最左边开始。如果缩进该行，比如缩进5个空格，那么这5个空格就会成为字符串的一部分。*/
          printf("Hello, young "　　 "lovers" ", wherever you are.");//：ANSI C引入的字符串连接。在两个用双引号括起来的字符串之
      //间用空白隔开，C编译器会把多个字符串看作是一个字符串
                
      ```

12. `scanf()`

    - ![image-20240908233305446](C:\Users\fate_\AppData\Roaming\Typora\typora-user-images\image-20240908233305446.png)

    - ![image-20240908233331850](C:\Users\fate_\AppData\Roaming\Typora\typora-user-images\image-20240908233331850.png)

    - ![image-20240908233354970](C:\Users\fate_\AppData\Roaming\Typora\typora-user-images\image-20240908233354970.png)

    - 假设`scanf()`根据一个`%d`转换说明读取一个整数。**`scanf()`函数每次读取一个字符**，**跳过所有的空白字符**，直至遇到第1个非空白字符才开始读取。如果下一个**字符是数字**，它便**保存**该数字并读取下一个字符如果遇到一个**非数字字符**，它便**认为读到了整数的末尾**。==然后，`scanf()`把非数字字符放回输入。==

    - 如果使用**字段宽度**，`scanf()`会在**字段结尾或第1个空白字符处停止读取**。如果第1个非空白字符是A而不是数字，会发生什么情况？`scanf()`将停在那里，并把A放回输入中，不会把值赋给指定变量。程序在下一次读取输入时，首先读到的字符是A。如果程序只使用%d转换说明，` scanf()`就一直无法越过A读下一个字符。如果使用带多个转换说明的`scanf()`，**C规定在第1个出错处停止读取输入**。

    - **使用%s 转换说明**，`scanf()`会读取除空白以外的所有字符。`scanf()`跳
      过空白开始读取第 1 个非空白字符，**并保存非空白字符直到再次遇到空白。**
      
    - `scanf()`函数允许把普通字符放在格式字符串中。除空格字符外的普通字符必须与输入字符串严格匹配。`scanf("%d,%d", &n, &m);` 用户必须输入 88,121

    - 格式字符串中的空白意味着跳过下一个输入项前面的所有空白

    - **对于%c，在格式字符串中添加一个空格字符会有所不同**。例如，如果把%c放在格式字符串中的空格后面，`scanf()`便会跳过空格，从第1个非空白字符开始读取。也就是说，`scanf("%c", &ch)`从输入中的第1个字符开始读取，`scanf(" %c", &ch)`则从第1个非空白字符开始读取。

    - `scanf()`函数返回**成功读取的项数**。没有读取任何项且需要读取一
      个数字而用户却输入一个非数值字符串，`scanf()`便返回0。当`scanf()`检测到“文件结尾”时，会返回EOF（`EOF`是`stdio.h`中定义的特殊值，通常用`#define`指令把`EOF`定义为`-1`）

      - ```c
        	int n;
        	printf("Please enter three integers:\n");
        	scanf("%*d %*d %d", &n);//把*放在%和转换字符之间时，会使得scanf()跳过相应的输出项
        	printf("The last integer was %d\n", n);
        ```

13. **字符串**，无论是表示成字符常量还是储存在字符数组中，==**都以一个叫做空字符的隐藏字符结尾。**==

### 运算符，表达式和语句

1. C 的标准**数学库**提供了一个`pow()`函数用于指数运算。例如，`pow(3.5,
   2.2)`返回3.5的2.2次幂）。==**混合整数和浮点数计算的结果是浮点数**==。
2. **求模运算符只能用于整数，不能用于浮点数**。**如果第1个运算对象是负数，那么求模的结果为负数；如果第1个运算对象是正数，那么求模的结果也是正数**。无论何种情况，只要`a`和`b`都是整数值，便可通过**a - (a/b)*b**来计算`a%b`。
3. **递增运算符**和**递减运算符**都有**很高的结合优先级**，只有圆括号的优先级
   比它们高。
4. 在C语言中，**编译器可以自行选择先对函数中的哪个参数求值**。这样做
   提高了编译器的效率，但是如果在函数的参数中使用了递增运算符，就会有
   一些问题。
5. 类型转换
   - 当类型转换出现在表达式时，都是从较小类型转换为较大类型。
   - 在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。
   - 当浮点类型被降级为整数类型时，原来的浮点值会被截断。
   - 强制类型转换运算符`(type)`，例如`(int)1.6`。

### 控制语句：循环

1. 关系运算符也可用来比较浮点数，但是要注意：**比较浮点数时，尽**
   **量只使用<和>**。因为浮点数的舍入误差会导致在逻辑上应该相等的两数却
   不相等。**使用**`fabs()`**函数**（声明在`math.h`头文件中）**可以方便地比较浮点数，**该函数返回一个浮点值的绝对值（即，没有代数符号的值）。

2. 在构建比较是否相等的表达式时，都习惯把常量放在左侧。

3. **关系运算符的优先级比算术运算符（包括+和-）低，比赋值运算符高。**

   - 高优先级组： < <= > >=
   - 低优先级组： == !=
   - 关系运算符的结合律也是从左往右。例，`ex != wye == zee与(ex != wye) == zee`

4. **C99**提供了`stdbool.h`头文件，**该头文件让bool成为_Bool的别名**，而且还
   **把true和false分别定义为1和0的符号常量**。包含该头文件后，写出的代码可
   以与C++兼容，因为C++把bool、true和false定义为关键字。

5. `for`

   ```c
   for (1;2;4)
   {
       3//1仅执行一次 之后的循环为2，3，4
        //可以省略一个或多个表达式（但是不能省略分号），只要在循环中包含能结束循环的语句即可。
        //省略第2个表达式被视为真
        //第1个表达式不一定是给变量赋初值，也可以使用printf()。
   }
   ```

   - **逗号运算符扩展了for循环的灵活性，以便在循环头中包含更多的表达**
   - `for　(ounces　=　1,　cost　=　FIRST_OZ;　ounces　<=　16;　
     ounces++,cost　+=　NEXT_OZ);`

6. `x *= 3 * y + 12 与 x = x * (3 * y + 12) `相同。以上提到的赋值运算符与=的优先级相同，即比+或*优先级低。

7. **逗号运算符**

   - 首先，==它保证了被它分隔的表达式从左往右求值。==（换言之，逗号是一个序列点，所以**逗号左侧项的所有副作用都在程序执行逗号右侧项之前发生**）

8. 可以把字符串储存在char类型的数组中。**如果**`char`**类型的数组末尾包含一个表示字符串末尾的空字符**`\0`，**则该数组中的内容就构成了一个字符串**。

9. 如果把`power()`函数的定义置于`main()`的文件顶部，**就可以省略前置声明**，因为编译器在执行到`main()`之前已经知道power()的所有信息。**但是，这不是C的标准风格。**

### 分支和跳转

1. `getchar()`函数不带任何参数，它从输入队列中返回下一个字符。`putchar()`函数打印它的参数。**只处理字符**。这两个函数通常定义在 `stdio.h`头文件中

2. if else：对于编译器的限制范围，**C99标准要求编译器**最少==**支持127层嵌套**==

3. `ctype.h`头文件中的**字符测试函数**

   | 函数名         | 如果是下列参数时，返回值为真                                 |
   | -------------- | ------------------------------------------------------------ |
   | `isalnum()`    | 字母数字（字母或数字)                                        |
   | `isalpha ( )`  | 字母                                                         |
   | `isblank ()`   | 标准的空白字符（空格、水平制表符或换行符）或任何其他本地化指定为空白的字符 |
   | `iscntrl ()`   | 控制字符，如Ctrl+B                                           |
   | `isdigit ()`   | 数字                                                         |
   | `isgraph ( )`  | 除空格之外的任意可打印字符                                   |
   | `islower ()`   | 小写字母                                                     |
   | `isprint ()`   | 可打印字符                                                   |
   | `ispunct ()`   | 标点符号（除空格或字母数字字符以外的任何可打印字符)          |
   | `isspace()`    | 空白字符（空格、换行符、换页符、回车符、垂直制表符、水平制表符或其他本地化定义的字符） |
   | `isupper()`    | 大写字母                                                     |
   | `isxdigit ( )` | 十六进制数字符                                               |

   | 函数名       | 行为                                                      |
   | ------------ | --------------------------------------------------------- |
   | `tolower ()` | 如果参数是大写字符，该函数返回小写字符;否则，返回原始参数 |
   | `toupper ()` | 如果参数是小写字符，该函数返回大写字符;否则，返回原始参数 |

4. **逻辑运算符的备选拼写**

   | 传统写法 | iso646.h |
   | -------- | -------- |
   | &&       | and      |
   | \|\|     | or       |
   | !        | not      |

   - `!`**运算符的优先级很高**，**比乘法运算符还高**，**与递增运算符的优先级相**
     **同**，**只比圆括号的优先级低**。`&&`**运算符的优先级比**`||`**运算符高**，**但是两者的优先级都比关系运算符低，比赋值运算符高**。
   - ==**`C`保证逻辑表达式的求值顺序是从左往右**==。&&和||运算符都是序列点，所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效。而且，C 保证一旦发现某个元素让整个表达式无效，便立即停止求值。

5. 条件表达式

   - `expression1 ? expression2 : expression3`
   - 如果 expression1 为真，那么整个条件表达式的值与 expression2的值相同；如果expression1为假，那么整个条件表达式的值与expression3的值相同。

6.  `continue`

   - 执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代。如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环。

     ```c
     for (count = 0; count < 10; count++)
     {
     	ch = getchar();
     	if (ch == '\n')
     		continue;
     	putchar(ch);
         //对于for循环，执行continue后的下一个行为是对更新表达式求值，然后是对循环测试表达式求值。
         //执行完continue后，首先递增count，然后将递增后的值和10作比较。
     }
     ```

   - 如果`switch`**语句在一个循环中**，**`continue`便可作为`switch`语句的一部分。**这种情况下，就像在其他循环中一样，continue让程序跳出循环的剩余部分，包括switch语句的其他部分。

   - `expression`和`case`标签都必须是整数值（包括char类型），标签必须是常量或完全由常量组成的表达式。

7. `go to` 

   ```c
   part: a = 10;
   goto part;
   //C程序员可以接受一种goto的用法——出现问题时从一组嵌套循环中跳出（一条break语句只能跳出当前循环）
   
   ```
   



### 字符输入/输出和输入验证

1. 缓冲区
   - 缓冲分为两类：**完全缓冲I/O**和**行缓冲I/O**。完全缓冲输入指的是当缓冲
     区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入
     中。缓冲区的大小取决于系统，常见的大小是 512 字节和 4096字节。行缓冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区。
   - 为支持==**无缓冲输入**==提供一系列特殊的函数，其原型都在**`conio.h`**头文件中。
     - ANSI C和后续的C标准都规定==**输入是缓冲的**==。
     - **回显无缓冲输入**的`getche()`函数和用于**无回显无缓冲输入**的`getch()`函数（回显输入意味着用户输入的字符直接显示在屏幕上，**无回显输入意味着击键后对应的字符不显示**）
     - **UNIX系统使用另一种不同的方式控制缓冲**。在UNIX系统中，可以使用`ioctl`()函数（该函数属于UNIX库，但是不属于C标准）指定待输入的类型，然后用`getchar()`执行相应的操作。
     - **ANSI没有提供调用无缓冲输入的标准方式**
   - 无论操作系统实际使用何种方法**检测文件结尾**，在C语言中，用`getchar()`读取文件检测到文件结尾时将返回**一个特殊的值**，即==**EOF**==（end of file的缩写）。`scanf()`函数检测到文件结尾时也返回EOF。`#define EOF (-1)`
     - 为什么是-1？因为`getchar()`函数的返回值通常都介于0～127，这些值对**应标准字符集**。但是，如果系统能识别扩展字符集，该函数的返回值可能在0～255之间。无论哪种情况，**-1都不对应任何字符，所以，该值可用于标记文件结尾。**
   - `echo_eof < words  <`符号是UNIX和DOS/Windows的重定向运算符。该运算符使words文件与stdin流相关联，把文件中的内容导入`echo_eof`程序。
   - 通常，==**系统使用行缓冲输入**==，即**当用户按下 Enter 键后输入才被传送给程序**。==**按下Enter键也传送了一个换行符**==，编程时要注意处理这个换行符。
   - 通过标准I/O包中的一系列函数，`getchar()`和` scanf()`函数也属于这一系列。当检测到文件结尾时，这两个函数都返回 EOF

### 函数

1. ANSI C**要求在每个变量前都声明其类型**。也就是说，不能像普通变量声明那样使用同一类型的变量列表。`void dubs(int x, int y, int z)`

   - 接受ANSI C之前的形式，但是将其视为废弃不用的形式：

     ```c
     void dibs(x,y,z)
     int x,y,z;
     {
         //当前的标准正逐渐淘汰 ANSI 之前的形式。读者应对此有所了解，以便能看懂以前编写的程序。
         //ANSI C也接受过去的声明函数形式，即圆括号内没有参数列表：void show_n_char();这种形式最终会从标准中剔除。
     }
     ```

   - 当函数接受参数时，函数原型用逗号分隔的列表指明参数的数量和类型。==**根据个人喜好，你也可以省略变量名**==。

   - `return;`**这条语句会导致终止函数，并把控制返回给主调函数。**因为 return 后面没有任何表达式，所以没有返回值，**只有在void函数中才会用到这种形式。**

   - 我们把函数的前置声明放在主调函数外面。当然，也可以放在主调函数里面。

   - `#include "hotels.h"`指令中的双引号表明被包含的文件位于当前目录中（通常是包含源代码的目录）

2. 声明指针

   ```c
   int *pi; // pi是指向int类型变量的指针
   		 //星号（*）表明声明的变量是一个指针。int * pi;声明的意思是pi是一个指针，*pi是int类型
   ```


### 数组和指针

1. 数组的初始化
   - `int powers[8] = {1,2,4,6,8,16,32,64};`**不支持ANSI的编译器**会
     把这种形式的初始化识别为**语法错误**，在数组声明前加上关键字static可解
     决此问题。
   - 当初始化列表中的**值少于数组**元素个数时，==编译器会把剩余的元素都初始化为0==。
   - 可以**省略方括号中数字**，让**编译器自动匹配数组大小和初始化列表中的项数**。

2. 指定初始化器
   - `int arr[6] = {0,0,0,0,0,212}; // 传统的语法`
   - 而==**C99规定**==，可以在初始化列表中使用带方括号的下标指明待初始化的元素：`int arr[6] = {[5] = 212}; // 把arr[5]初始化为212`
   - 指定初始化器的**两个重要特性**：
     - 如果指定初始化器后面有更多的值，[4] = 31,30,31，那么后面这些值将被用于初始化指定元素后面的元素。
     - 如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化。

3. 声明数组时只能在方括号中使用**整型常量表达式**。所谓整型常量表达式，是由整型常量构成的表达式。==**`sizeof`表达式被视为整型常量**==但是（与C++不同）**==`const`值不是。==**

   ```c
       const float rain[YEARS][MONTHS] =
           {
               {4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6},
               {8.5,8.2,1.2,1.6,2.4,0.0,5.2,0.9,0.3,0.9,1.4,7.3},
               {9.1,8.5,6.7,4.3,2.1,0.8,0.2,0.2,1.1,2.3,6.1,8.4},
               {7.2,9.9,8.4,3.3,1.2,0.8,0.4,0.0,0.6,1.7,4.3,6.2},
               {7.6,5.6,3.8,2.8,3.8,0.2,0.0,0.0,0.0,1.3,2.6,5.2}
           };
   ```

   - 如果第1个列表中只有10个数，则只会初始化数组第1行的前10个元素，而最后两个元素将被默认初始化为0。

4. **在C中，指针加1指的是增加一个存储单元**。对数组而言，这意味着把加1后的地址是下一个元素的地址，而不是下一个字节的地址。

5. `int *ar`形式和`int ar[]`形式都表示ar是一个指向int的指针。但是，`int ar[]`只能用于声明形式参数。第2种形式（`int ar[]`）提醒读者指针`ar`指向的不仅仅
   一个`int`类型值，还是一个`int`类型数组的元素。

6. ==**C保证在给数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。**==虽然C保证了`marbles + SIZE`有效，但是对`marbles[SIZE]`（即储存在**该位置上**的
   值）**未作任何保证**。

7. 一元运算符***和++的优先级相同**，但==**结合律是从右往左**==，指针与整数相加:可以使用+运算符把指针与整数相加，或整数与指针相加。无论哪种情况，**整数都会和指针所指向类型的大小(以字节为单位)相乘,然后把结果与初始地址相加。**

8. `const`

   1. 指向` const `的指针通常用于函数形参中，表明该**函数不会使用指针改变数据**。只能把非`const`数据的地址赋给普通指针。C标准规定，使用==**非**==`const`标识符修改`const`数据导致的结果是未定义的。
   2. `const`还有其他的用法。例如，可以声明并初始化一个不能指向别处的指针。
   3. 把`const`指针赋给非`const`指针不安全，因为这样==**可以使用新的指针改变`const`指针指向的数据。**==编译器在编译代码时，可能会给出警告，执行这样的代码是未定义的。
   4. C和C++中`const`的用法很相似，但是并不完全相同。**区别之一是，C++允许在声明数组大小时使用`const`整数**，而C却不允许。区别之二是，C++的指针赋值检查更严格。**C++不允许把`const`指针赋给非`const` 指针**。而C则允许这样做，但是如果通过`pl`更改`y`，其行为是未定义的。

9. ==**指向多维数组的指针**==

   1. `int (* pz)[2];//pz指向一个内含两个int类型值的数组`。`pz`声明为**指向一个数组的指针**，该数组内含两个`int`类型值。

   2. `int * pax[2];//pax是一个内含两个指针元素的数组，每个元素都指 向int的指针`

   3. 由于`[]`优先级高，先与`pax`结合，所以`pax`成为一个内含两个元素的数 组。然后*表示`pax`数组内含两个指针。最后，`int`表示`pax`数组中的指针都指向`int`类型的值。因此，这行代码声明了两个指向`int`的指针。而前面有圆括号的版本，*先与`pz`结合，因此声明的是一个指向数组（内含两个`int`类型的值）的指针。

   4. 可以用数组表示法或指针表示法来表示一个数组元素，既可以使用数组 名，也可以使用指针名：

      `zippo[m][n] == *(*(zippo + m) + n)` `pz[m][n] == *(*(pz + m) + n)`

10. 函数和多维数组

   - ```c
     void sum_rows(int ar[][COLS],int rows);
     void sum_cols(int [][COLS],int);
     void sum2d(int(*ar)[COLS],int rows);
     ```

   - 一般而言，声明一个指向N维数组的指针，**只能省略最左边方括号中的值**。`int sum4d(int ar[][12][20][30])`

   - 变长数组

     - ```c
       int quarters=4;
       int regions=5;
       double sales[regions][quarters]; //一个变长数组且变长数组必须是自动储存类别
       int sum2d(int rows,int cols,int ar[rows][cols]);
       //因为ar的声明要使用rows和cols，所以在形参列表中必须在声明ar之前声明这两个形参。
       int sum2d(int,int,int ar[*][*]);
       //c99和c11标准规定，可以省略原型中的形参名，但是在这种情况下，必须使用星号来代替省略的维度。
       ```

     - ==**不能在声明中初始化它们**==。最终，**C11把变长数组作为一个可选特性**，而不是必须强制实现的特性。

     - 变长数组中的变不是指可以修改已创建数组的大小。一旦创建了变长数组，他的大小则保持不变。这里的变指的是：**在创建数组时，可以使用变量指定数组的维度。**

     - 需要注意的是，在**函数定义的形参列表**中声明的**变长数组并未实际创建数组**。和传统的语法类似，变长数组名实际上是一个指针。这说明带变长数组形参的函数实际上是在原始数组中处理数组，因此可以修改传入的数组。

     - ==**C99/C11** 标准==允许在声明变长数组时使用 `const `变量。所以该数组的定
       义必须是声明在块中的自动存储类别数组。

11. 复合字面量

    - `(int [2]){10, 20}`复合字面量也可以省略大小。

### 字符串和字符串函数

1. 字符串

   - ```c
     const char m1 [40] = "Limit yourself to one line's worth. ";
     //这种形式的初始化比标准的数组初始化形式简单得多:
     const char m1 [40] = {'L','i','m','\0'};
     //注意最后的空字符。没有这个空字符，这就不是一个字符串，而是一个字符数组。
     
     //从ANSI C标准起，如果字符串字面量之间没有间隔，或者用空白字符分隔，C会将其视为串联起来的字符串字面量。例如:
     char greeting [50]= "Hello, and"" how are" " you"
         						"today ! ";
     //与下面的代码等价：
     char greeting [50] = "Hello,and how are you today ! " ;
     ```

   - **字符串常量属于静态存储类别**(static storage class)，这说明如果在函数中使用字符串常量，该字符串**只会被储存一次**，在**整个程序的生命期内存在**，即使函数被调用多次。用==**双引号括起来的内容被视为指向该字符串储存位置的指针**==。这类似于把数组名作为指向该数组位置的指针。

   - ```c
     const char ar1[] = "Something is pointing at me.";
     const char * pt1 = "Something is pointing at me.";
     ```

   - 数组形式和指针形式有何不同？以上面的声明为例，**数组形式**（`ar1[]`）
     在**计算机的内存中分配为一个内含29个元素的数组**（每个元素对应一个字
     符，还加上一个末尾的空字符'\0'），每个元素被初始化为字符串字面量对
     应的字符。通常，字符串都作为可执行文件的一部分储存在数据段中。当把
     程序载入内存时，也载入了程序中的字符串。字符串储存在静态存储区
     （static memory）中。但是，**程序在开始运行时才会为该数组分配内存**。**此时，才将字符串拷贝到数组中**（第 12 章将详细讲解）。注意，**此时字符串**
     **有两个副本**。一个是在**静态内存中的字符串字面量**，另一个是**储存在ar1数**
     **组中的字符串。**此后，编译器便把**数组名ar1**识别为**该数组首元素地址**（`&ar1[0]`）的别名。这里关键要理解，==**在数组形式中，ar1是地址常量**==。不能更改ar1，如果改变了`ar1`，则意味着改变了数组的存储位置（即地址）。可以进行类似`ar1+1`这样的操作，标识数组的下一个元素。但是不允许进行`++ar1`这样的操作。递增运算符只能用于变量名前（或概括地说，只能用于可修改的左值），不能用于常量。**指针形式（*pt1）**也使得编译器为字符串在静态存储区预留29个元素的空间。另外，一旦开始执行程序，它会为指针变量pt1留出一个储存位置，并把字符串的地址储存在指针变量中。**该变量最初指向该字符串的首字符，但是它的值可以改变。**因此，可以使用递增运算符。例如 `++pt1`将指向第2 个字符（o）。字符串字面量被视为`const`数据。由于`pt1`指向这个`const`数据，所以应该把`pt1`声明为指向`const`数据的指针。这意味着不能用pt1改变它所指向的数据，但是仍然可以改变`pt1`的值（即，`pt1`指向的位置）。如果把一个字符串字面量拷贝给一个数组，就可以随意改变数据，除非把数组声明为`const`。==**总之，初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针。**==

2. 数组和指针的区别

   - ```c
     char heart[]="I love Tilllie";
     const char *head="I love Tilllie";
     ```

   - `head = heart;`不会导致`head`指向的字符串消失，这样做只是改变了储存在`head`中的地址。除非已经保存了`"I love Millie!"`的地址，否则当`head`指向别处时，就无法再访问该字符串。

   - ```c
     char * p1 = "Klingon";
     p1[0] = 'F'; // ok?
     printf("Klingon");
     printf(": Beware the %ss!\n", "Klingon");
     ```

   - 编译器可以使用**内存中的一个副本**来**表示所有完全相同的字符串字面量**。也就是说，编译器可以用相同的地址替换每个`"Klingon"`实例。如果编译
     器使用这种单次副本表示法，并允许`p1[0]`修改`'F'`，那将影响所有使用该字
     符串的代码。

   - 如果要用**数组表示一系列待显示的字符串**，**请使用指针数组**，因为它比二维字符数组的效率高。但是，指针数组也有**自身的缺点**：==**指针指向的字符串字面量不能更改**==。

3. 字符串输入

   - `puts()`函数只显示字符串,而且自动在显示的字符串末尾**加上换行符**。
   - `gets()`它读取整行输入，直至遇到换行符，然后**丢弃换行符**，储存其余字符，并在这些字符的末尾**添加一个空字符**使其成为一个 C 字符串。
     - **C11标准委员**会采取了更强硬的态度，直接**从标准中废除了gets()函数**。
     - 编译器为了能兼容以前的代码，大部分都继续支持gets()函数。
     - C11标准新增的`gets_s()`是`stdio.h`输入/输出函数系列中的**可选扩展**，所以支持C11的编译器也不一定支持它。
       - 如果`gets_s()`读到**最大字符数都没有读到换行符**，会执行以下几步。首先把**目标数组中的首字符设置为空字符**，**读取并丢弃随后的输入直**至读到换行符或文件结尾，然后**返回空指针**。接着，**调用依赖实现的“处理函数”**（或你选择的其他函数），可能会中止或退出程序。
   - `fgets()&fputs`
     - `fgets()`**第2个参数**指明了读入**字符的最大数量**，如果该参数的值
       是n，那么`fgets()`将读入n-1个，**字符最后一个字符为'\0'**，或者读到遇到的第一个换行符为止。
     - `fgets()`**读到一个换行符**，会把它**储存**在字符串中。
     - `fgets()`的**第3 个参数**指明要**读入的文件**，读入**从键盘输入**的数
       据，则以**stdin**（标准输入）作为参数，该标识符定义在`stdio.h`中。
     - `fgets()` 函数在成功读取时返回指向存储输入字符串的指针。如果发生错误或到达文件末尾且未读取任何字符，则返回 `NULL`
     - `fputs()`函数返回指向 char的指针。如果一切进行顺利，该**函数返回的地址与传入的第 1 个参数相同**。但是，如果**函数读到文件结尾**，它将返回一个特殊的指针：**空指针**(NULL)
     - `fputs()`**不在字符串末尾添加换行符**。
   - ==处理字符串的函数通常都不知道数组的大小，这些**函数通过查找字符串末尾的空字符**确定字符串在何处结束==

4. 字符串输出

   - `fputs()`函数的**第 2 个参数指明要写入数据的文件**。如果要打印在显示器上，可以用定义在`stdio.h`中的`stdout`作为该参数。`fputs()`==**不会在输出的末尾添加换行符。**==
   - `puts()`应与`gets()`配合使用，`fputs()`应与`fgets()`配合使用。
   - **`*string`当string指向空字符时，`*string`的值是0**

5. `string.h`字符串处理函数

   - `strcat()`该函数把**第2个字符串的备份附加在第1个字符串末尾**，并把拼接后形成的新字符串作为第1个字符串，`strcat()`函数**返回第1个参数**。
     - `strcat()`函数无法检查第1个数组是否能容纳第2个字符串，`strncat()`该函数的**第3 个参数指定了最大添加字符数**，**在加到第n个字符或遇到空字符时停止。**
   - `strcmp()`如果**两个字符串参数相同，该函数就返回0**，否则返回非零值。
     - `strcmp()`函数**比较的是字符串，不是整个数组**，`strcmp()`函数只会比较try中第1个空字符前面的部分。
     - 两者的ASCII码之差，`strcmp()`会依次比较每个字符。
     - `strncmp()`函数在比较两个字符串时，可以比较到字符不同的地方，**也可以只比较第3个参数指定的字符数**。
   - `strcpy()`
     - `strcpy()`的返回类型是 `char *`，该函数返回的是第 1个参数的值，即一个字符的地址。
     - 第 1 个参数不必指向数组的开始。这个属性可用于拷贝数组的一部分。
     - `strcpy()`==**把源字符串中的空字符也拷贝在内**==
     - `strncpy()`更安全，该函数的**第 3 个参数指明可拷贝的最大字符数**。
       - n个字符或空字符之前的字符（先满足哪个条件就拷贝到何处），
       - **如果目标空间装不下副本，因该把副本最后一个元素设置为空字符。**
   - 其它字符串函数
     - `char *strchr(const char * s, int c);`
       - 如果**s字符串中包含c字符**，该函数**返回指向s字符串首位置的指针**（末尾的空字符也是字符串的一部分，所以在查找范围内）；如果在字符串s中未找到c字符，该函数则返回空指针。
     - `char *strpbrk(const char * s1, const char * s2);`
       - 如果 **s1 字符中包含 s2 字符串中的任意字符**，该函数**返回指向 s1 字符串首位置的指针**；如果在s1字符串中未找到任何s2字符串中的字符，则返回空字符。
     - `char *strrchr(const char * s, int c);`
       - 该函数返回**s字符串中c字符**的**最后一次出现的位置**。
     - `char *strstr(const char * s1, const char * s2);`
       - 该函数返回指向**s1字符串中s2字符串**出现的首位置。

6. `sprintf()`

   - 把数据写入字符串，而不是打印在显示器上。
   - `sprintf()`的第1个参数是目标字符串的地

7. 命令行参数

   - `int main(int argc, char *argv [])`
   - 如果系统允许（一些操作系统不允许这样），就把**程序本身的名称赋给**
     `argv[0]`，然后把随后的第1个字符串赋给`argv[1]`，以此类推。
   - `char **argv与char *argv[]`等价
   - 许多环境（包括UNIX和DOS）都**允许用双引号把多个单词括起来形成一个参数。**

8. 把字符串转换为数字

   - `#include<stdlib.h>`
     - `atof() atol() atof()`
     - `atof()`函数把字符串转换成 `double` 类型的值， `atol()`函数把字符串转换成`long`类型的值。
   - 如果**字符串仅以整数开头**，`atoi()`函数也能处理，它只**把开头的整数转**
     **换为字符。**
   - 在我们所用的C实现中，如果命令行参数不是数字，`atoi()`函数返回0。然而C标准规定，这种情况下的行为是未定义的。
   - 更智能的函数：`strtol()`把字符串转换成long类型的值，`strtoul()`把字符串转换成`unsigned long`类型的值，`strtod()`把字符串转换成`double`类型的值。这些函数的智能之处在于识别和报告字符串中的首字符是否是数字。而且，`strtol()`和`strtoul()`还可以**指定数字的进制**。
   - `long strtol(const char * restrict nptr, char ** restrict endptr, int base);`
     - `nptr`是指向**待转换字符串的指针**，`endptr`是**一个指针的地址**，该
       指针被设置为**标识输入数字结束字符的地址**，base表示以什么进制写入数
       字。
     - `strtol()`函数最多可以转换三十六进制，'a'~'z'字符都可用作数字。
     - `strtod()`函数只以十进制转换，因此它值需要两个参数。

### 存储类别，链接和内存管理

1. 作用域

   - 作用域描**述程序中可访问标识符的区域**。一个C变量的作用域可以是**块**
     **作用域、函数作用域、函数原型作用域或文件作用域。**

   - **以前**，具有**块作用域的变量都必须声明在块的开头**。**C99 标准放宽了这**
     **一限制**，允许在块中的任意位置声明变量。

   - **函数原型作用域**的范围是**从形参定义处到原型声明结束**。这意味着，编
     译器在处理函数原型中的形参时只关心它的类型，而形参名（如果有的话）
     通常无关紧要。而且，**即使有形参名**，**也不必与函数定义中的形参名相匹**
     **配。**

   - ==**变量的定义在函数的外面，具有文件作用域（file scope）。具有文件作**
     **用域的变量，从它的定义处到该定义所在文件的末尾均可见。**==

   - **C 变量**有 **3 种链接属性**：**外部链接**、**内部链接或无链接**。具有块**作用域**、**函数作用域**或**函数原型作用域的变量都是无链接变量**。这意味着这些变量属于定义它们的块、函数或原型私有。具有**文件作用域的变量**可以是**外部链接或内部链接**。**外部链接变量**可以在**多文件程序**中使用，==**内部链接变量**只能在**一个翻译单元**中使用。==

     ```c
     static int dodgers = 3;//文件作用域，内部链接
     int giants = 5;//文件作用域，外部链接
     ```

2. 存储期

   - 静态存储期：它在程序的执行期间一直存在。
     - **文件作用域变量**具有静态存储期
   - 线程存储期：具有线程存储期的对象，从被声明时到线程结束一直存在。
     - 以关键字_Thread_local声明一个对象时，每个线程都获得该变量的私有备份。
   - 自动存储期：块作用域的变量通常都具有自动存储期。当程序进入定义这些变量的块时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存。
     - 变长数组稍有不同，它们的存储期从声明处到块的末尾，而不是从块的
       开始处到块的末尾。
     - **块作用域变量也能具有静态存储期**。声明前面加上**关键字static**。
   - 动态分配存储期：

3. 自动变量

   - ```c
     int loop(int n)
     {
     	int m;
     	scanf("%d", &m);
     	{
     		int i;//i变量只有在使用时才占用内存
     				
     		for (i = m; i < n; ++i)
     		{
     			puts("i is local to a sub-block\n");
     		}
     	}
     	return m;
     	//变量n和 m 分别定义在函数头和外层块中，
     	//它们的作用域是整个函数，而且在调用函数到函数结束期间都一直存在。
     }
     int main()
     {
         //内层块中声明的变量与外层块中的变量同名
         //内层块会隐藏外层块的定义。但是离开内层块后，外层块变量的作用域又回到了原来的作用域。
         
         	int x = 30;//原始的x
     	printf("x in outer block:%d at %p\n", x, &x);
     	{
     		int x = 77;//新的x，隐藏了原始的x
     		printf("x in inner block:%d at %p\n", x, &x);
     	}
     	printf("x in outer block:%d at %p\n", x, &x);//原始的x
     }
     //gcc -std=c11
     ```

   - **自动变量不会初始化，除非显式初始化它。**

   - 寄存器变量

     - **寄存器变量储存在寄存器**而非内存中，所以**无法获取寄存器变量的地址**。绝大多数方面，寄存器变量和自动变量都一样。
     - 声明变量为`register`类别与直接命令相比更像**是一种请求**。编译器必须**根据寄存器或最快可用内存的数量衡量你的请求**，或者直接忽略你的请求，所以可能不会如你所愿。
     - `register int quick;`

   - 有**意覆盖一个外部变量定义**，或者**强调不要把该变量改为其他存储类别**），可以显式使用**关键字auto**。

4. 块作用域的静态变量

   - ```c
     void trystat(void)
     {
     	int fade = 1;
     	static int stay = 1;
     	printf("fade = %d and stay = %d\n", fade++, stay++);
     }
     ```

   - 第1条声明确实是`trystat()`函数的一部分，每次调用该函数时都会执行这
     条声明。这是运行时行为。第2条声明实际上并不是`trystat()`函数的一部分。如果逐步调试该程序会发现，程序似乎跳过了这条声明。这是因为**静态变量和外部变量在程序被载入内存时已执行完毕。**把这条声明放在`trystat()`函数中是为了告诉编译器只有`trystat()`函数才能看到该变量。这条声明并未在运行时执行。

5. 外部链接的静态变量

   - ```c
     int Errupt;
     double up[100];
     extern char Coal;//如果Coal被定义在另一个文件中，则必须这样声明。
     int main(void)
     {
         extern int Errupt;//为了指出该函数使用了外部变量，可以在函数中使用关键字extern再次声明。可选的声明。
         				//表明要使用外部变量Errupt
         extern double Up[];
     }
     ```

   - **在执行块中的语句时，块作用域中的变量将“隐藏”文件作用域中的同名变量。**

   - 如果**未初始化外部变量**，他们会被==**自动初始化为0**==，这一原则也同样适用于外部定义的数组元素。==**只能使用常量表达式初始化文件作用域变量**==。

6. 存储类别和函数

   - 外部函数可以被其他文件的函数访问，但是**静态函数只能用于其定义所在的文件。**

   - 用 extern 关键字**声明**定义在其他文件中的函数。这样做是为了表明当前文件中使用的函数被定义在别处。除非使用static关键字，否则一般**函数声明都默认为extern。**

     ```c
     double gamma(double);　　　/* 该函数默认为外部函数 */
     static　double　beta(int,　int);
     extern　double　delta(double,　int);
     ```

7. 





















