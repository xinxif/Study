### 第一部分

#### 程序结构和执行

##### 信息存储

- 大多数计算机使用8位的块，或者字节(byte)，作为最小的可寻址的内存单位，而不是访问内存中单独的位，机器级程序将内存视为一个非常大的字节数组，称为虚拟内存(virtual memory)。内存的每个字节都由一个唯一的数字来标识，称为它的地址(ad-dress)，所有可能地址的集合就称为虚拟地址空间( virtual address space)。这个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现是将动态随机访问存储器(DRAM)、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。

1. 十六进制表示法

   <img style="width: 1300px;height:200px" src="Image\十六进制表示法.png ">

   - 给定一个二进制数字，把它分为每4位一组来转换为16进制，如果**位数不是4的倍数**，最左边一组前面用0补足。

   - 当$X$是2的非负整数$n$次幂时，$X=2^n$，我们可以很容易地将$x$写成16进制形式。

     - $n$标识成$i+4j$形式，其中$0 \leq i \leq 3$，我们可以把$x$写成**开头**的**十六进制数**为$1(i=0),2(i=1),4(i=2),8(i=3)$，后面跟随着$j$个十六进制的0
     - $x=2048=2^{11}$，我们有$n=11=3+4*2$，$i=3,j=2$
     - 结果为$0X800$

   - 十进制和十六进制表示之间的转换

     - 将一个**十进制数**字$x$转**换为十六进制**，可以反复地用16除以$x$得到一个商$q$和一个余数$r$也就是$x=q\times16+ r$。然后，我们用十六进制数字表示的$r$作为最低位数字，并且通过对$q$反复进行这个过程得到剩下的数字。例如，考虑十进制314 156的转换。

     $$
     \begin{align*}
     314,156 & = 19,634 \times 16 + 12 \;\;\; (C) \\
     19,634 & = 1,227 \times 16 + 2 \;\;\;\;\;\;\; (2) \\
     1,227 & = 76 \times 16 + 11 \;\;\;\;\;\;\;\;\;\; (B) \\
     76 & = 4 \times 16 + 12 \;\;\;\;\;\;\;\;\;\;\;\; (C) \\
     4 & = 0 \times 16 \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; (4)
     \end{align*}
     $$

     - 反过来，将**一个十六进制**数字**转**换为**十进制**数字，我们可以使用相应的16的幂乘以每个十六进制数字
       - 例如给定数字$0X7AF =7\times16^2+10\times16^1+15\times16^0$

2. 字数据大小

   - **字**：字中的字节数(即字长)。现在大多数机器**字长**要么是4字节，要么是8字节。
   - **每台计算机都有一个字长**( word size)，**指明指针数据的标称大小**( nominal size)。因为**虚拟地址是以这样的一个字来编码的**，所以**字长决定的最重要的系统参数就是虚拟地址空间的最大大小**。也就是说，对于一个字长为w位的机器而言，虚拟地址的范围为0~2^w^-1，程序最多访问2^w^个字节。
     - `gcc -m32 prog.c`编译32位程序。

3. ==**寻址和字节顺序**==

   - 对于**跨越多字节的程序对象**，我们**必须建立两个规则**：**这个对象的地址是什么**，以及**在内存中如何排列这些字节**。在几乎所有的机器上，**多字节对象都被存储为==连续的字节序列==**，**对象的地址**为所使用字节中最小的地址。例如，假设一个类型为`int` 的变量`x`的地址为`0x100`，也就是说，地址表达式`&x`的值为`0x100`。那么，假设数据类型`int`为`32`位表示`x`的4个字节将被存储在内存的0x100、0x101、0x102和0x103位置。

   - **排列表示一个==对象的字节==有两个通用的规则**。考虑一个`w`位的整数，其位表示为[X~w-1~,X~w-2~，…，X~1~，X~0~]，其中X~w-1~是最高有效位，而x~0~是最低有效位。假设w是8的倍数，这些位就能被分组成为字节，其中最高有效字节包含位[X~w-1~，X~w-2~，…，X~1~，X~0~]，而最低有效字节包含位[X~7~ ，X~6~，…，X~0~]，其他字节包含中间的位。**某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象**，**而另一些机器则按照从最高有效字节到最低有效字节的顺序存储**。前一种规则——**最低有效字节在最前面的方式**，称为**小端法**(little endian)。后一种规则—最高有效字节在最前面的方式，称为**大端法**(big endian)。

     - 假设变量`x`的类型为`int`，位于地址`0x100`处，它的十六进制值为`0x01234567`。地址范围`0x100～0x103`的字节顺序依赖于机器的类型。

       <img style="width: 1300px;height:200px" src="Image\大小端法.png ">

     - 许多比较新的微处理器是双端法(big-endian)，也就是说可以把它们配置成作为大端或者小端的机器运行。然而，实际情况是：一旦选择了特定操作系统，那么字节顺序也就固定下来。比如，用于许多移动电话的ARM微处理器，其硬件可以按小端或大端两种模式操作，但是这些芯片上最常见的两种操作系统——Android(来自Google)和IOS(来自Apple)——却只能运行于小端模式。

   - 字节顺序导致的问题

     - 在**不同类型的机器之间通过网络传送二进制数据时**，一个常见的问题是当**小端法机器产生的数据被发送到大端法机器或者反过来时**，接收程序会发现，字里的字节成了反序的。

     ```c++
     #include<iostream>
     #include<cstdio>
     using byte_pointer = unsigned char *;
     void show_bytes(byte_pointer start,std::size_t len)
     {
         std::size_t i;
     	for(i=0;i<len;++i)
     	{
     		std::printf(" %.2x",start[i]);
     	}
         putchar('\n');
     }
     void show_int(int x){show_bytes(reinterpret_cast<byte_pointer>(&x),sizeof(int));}
     void show_float(float x){show_bytes(reinterpret_cast<byte_pointer>(&x),sizeof(float));}
     void show_pointer(void *x){show_bytes(reinterpret_cast<byte_pointer>(&x),sizeof(void*));}
     void test_show_bytes(int val)
     {
     	int ival = val;
     	float fval = static_cast<float>(ival);
     	int*pval = &ival;
     	show_int(ival);
     	show_float(fval);
     	show_pointer(pval);
     }//测试机器是大端法还是小端法
     ```

   - 基本编码，称为Unicode 的“统一字符集”，**使用32位来表示字符**。这好像要求文本串中每个字符要占用4个字节。不过，可以**有一些替代编码,常见的字符只需要1个或2个字节,而不太常用的字符需要多一些的字节数**。特别地，UTF-8表示将每个字符编码为一个字节序列，这样标准ASCII字符还是使用和它们在ASCII中一样的单字节编码，这也就意味着所有的ASCII字节序列用ASCII码表示和用UTF-8表示是一样的。

4. 布尔代数

   - 布尔运算`~`对应于逻辑运算NOT，在命题逻辑中用符号$\neg$表示
   - &对应于逻辑运算AND，$\land$
   - |对应于逻辑运算OR，$\lor$
   - ^对应于逻辑运算异或，$\oplus$
   - **布尔运算&对|的分配律**，写为` a&(b|c) = (a&b)|(a&c)`
   - **布尔运算|对&的分配律**，写为`a|(b&c)=(a|b)&(a|c)`
   - 长度为$w$的位向量上的`^`，`&`和`~`运算，会得到一种不同形式的数学形式，我们称为**布尔环**。布尔换和整数运算有很多相似之处。
     - `a^a=0`，从新排列组合顺序，这个属性也仍然成立，因此有`(a^b)a=b`
   - 位向量一个很有用的应用就是表示有限集合。我们可以用位向量[a~w-1~，…，a~1~，a~0~]编码任何子集 A$\subsetneq${0，1，…，w-1}，其中a~i~=1当且仅当i∈A。例如(记住我们是把a~w-1~写在左边，而将a~0~写在右边)，位向量a$ \doteq$[01101001]表示集合A={0，3，5，6}，而b$ \doteq$[01010101]表示集合B={0，2，4，6}。使**用这种编码集合的方法，布尔运算`|`和`&`分别对应于集合的并和交，**而`~`**对应于于集合的补**。还是用前面那个例子，运算`a&b`得到位向量[01000001]，而A∩B={0，6}。

5. C语言的移位运算

   - `x`向左移动`k`位，丢弃最高的`k`位，并在右端补`k`个`0`，(**移位量应该是一个`0~w—1`之间的值**。移位运算是**从左至右可结合**的，所以`x<<j<<k`等价于`(x<<j)<<k`。
   
   - **右移运算**
     
     - 逻辑右移：逻辑右移在左端补R个0
     - **算术右移：在左端补R个==最高有效位的值==**。
     - **C语言标准**并**没有明确定义对于==有符号数==应该==使用哪种类型的右移==**一一算术右移或者逻辑右移都可以。这就意味着任何假设一种或者另一种右移形式的代码都可能会遇到可移植性问题。然而，实际上，几乎所有的编译器/机器组合都对有符号数使用算术右移。
     
   - 对一个由`w`位组成的数据类型，如果要**移动R$\geq$W位时**
   
     ```c++
     int avle = 0xfedcba98>>36;
     unsigned uval = 0xfedcba98>>40;
     int lval = 0xfedcba98<<32;
     ```
   
     - 在许多机器上，当移动一个`w`位的值时，移位指令只考虑位移量的低 $log_2w$位,因此实际上位移量就是通过计算R mod w得到的。例如，当w=32时，上面三个移位运算分别是移动0、4和8位**。这种行为对于C程序来说是没有保证的，所以应该保持位移量小于待移位值的位数**。

##### 整数表示

<img style="width: 1300px;height:500px" src="Image\整数数据于算术操作.png ">

1. 无符号数的编码

   - 假设有一个整数数据类型**有`w`位**。我们可以将位向量写成$\vec{x}$，表示整个向量，或者写成[X~w-1~，X~w-2~，…，X~0~]，表示向量中的每一位。把$\vec{x}$看做一个二进制表示的数，就获得了$\vec{x}$的无符号表示。在这个编码中，每个位x~i~,都取值为0或1，后一种取值意味着数值2^i^应为数字值的一部分。我们用一个函数B2U~W~(Binary to Unsigned的缩写，长度为w)来表示：

     <img style="width: 1300px;height:100px" src="Image\无符号数原理.png ">

   - $UMAX_w \doteq\sum_{i=0}^{w-1} 2^i=2^w-1$

   - 无符号编码的唯一性：函数`B2U`~w~将每一个长度位`w`的位向量都映射为`0~2^w^-1`之间的一个唯一值。

2. 补码编码：将字的**最高有效位解释为负权**

   <img style="width: 1300px;height:100px" src="Image\补码编码.png ">

   - $TMin_w \doteq-2^{w-1}$
   - $TMax_w\doteq\sum_{i=0}^{w-2} 2^i=2^{w-1}-1$

   <img style="width: 1300px;height:400px" src="Image\重要数字.png ">

   - 补码的范围是不对称的：$|TMin|=|TMax|+1$，$TMin$没有与之对应的正数。最大的无符号数值刚好比补码的最大值的两倍大一点：$UMax_w=2TMax_w+1$，**补码表示中所有表示负数的位模式在无符号中都变成了正数**。**$-1$和$UMax$有同样的位表示----一个全1的串**。

   - **C语言标准并没有要求要用补码形式来表示有符号整数**，但是几乎所有的机器都是这么做的。程序员如果希望==**代码具有最大可移植性**==，能够在所有可能的机器上运行，**那么除了图2-11所示的那些范围之外**，我们不应该假设任何可表示的数值范围，也不应该假设有符号数会使用何种特殊的表示方式。

   - 有符号数的其它表示方式

     <img style="width: 1300px;height:200px" src="Image\反码和原码.png ">

     - 这两种表示方法都有一个奇怪的属性，对于数值0有两种不同的编码方式。这两种表示方法，把[00...0]都解释为+0，而值-0在原码中表示为[10...0]，在反码表示为[11...1]。

3. 有符号数和无符号数之间的转换

   - 

