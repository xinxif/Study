### 链接

#### 编译器驱动程序

- 编译步骤

  - `g++ -E main.cxx`进行**预处理**
    - `g++ -E main.cxx -o main.i` 进行预处理并生成`main.i`文件


  - `g++ -S main.i -o main.s`翻译成一个ASCII汇编文件
    - `-S`选项告诉编译器将输入文件**编译为汇编代码**
    - `-o`指定输出文件为`main.s`


  - `g++ -c main.s -o main.o`
    - 翻译成**可重定向目标文件**


  - `g++ main.o sum.o -o program`
    - 链接

#### 静态链接

- ==**链接器必须完成的两个主要任务**==

  - **符号解析**
    - 目标文件定义和引用符号，**每个符号**对应于一个**函数**、一个**全局变量**或一个**静态变量**。==符号解析的目的是将每个符号引用正好和一个符号定义关联起来。==
  - **重定向**
    - 编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条目的详细指令，不加甄别地执行这样的重定位。

  - 链接器的一些基本事实
    - ==**目标文件纯粹是字节块的集合**==。这些**块中**，**有些包含程序代码**,**有些包含程序数据**，而其他的则包含**引导链接器和加载器的数据结构**。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。==**链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。**==

- 目标文件

  - **可重定位目标文件**。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。
  - **可执行目标文件**。包含二进制代码和数据，其形式可以被直接复制到内存并执行。
  - **共享目标文件**。一种特殊类型的可重定位目标文件，可以**在加载或者运行时**被动态地加载进内存并链接。
  - **编译器和汇编器**生成可重定向目标文件（包括共享目标文件），**连接器**生成可执行目标文件

- ==**可重定向目标文件**==

  - ==**ELF头**==        `readelf -h main.o`

  - | Magic                                  | *7f 45 4c 46 02 01 01 00 00* 00 00 00 00 00 00 00 | 用于标识文件为ELF格式                          |
    | -------------------------------------- | ------------------------------------------------- | ---------------------------------------------- |
    | **Class:**                             | **ELF64**                                         | **表示这是一个64位文件**                       |
    | **Data:**                              | **2's complement,little endian**                  | **数据编码，表示这是一个小端序文件**           |
    | **Version:**                           | **1 (current)**                                   | **ELF版本，目前版本为1**                       |
    | **OS/ABI:**                            | **UNIX - system v**                               | **操作系统/ABI标识**                           |
    | **ABI Version:**                       | **0**                                             | **ABI版本号**                                  |
    | **Type:**                              | **REL (Relocatable file)**                        | **文件类型，表示这是一个可重定位文件**         |
    | **Machine:**                           | **Advanced Micro Devices x86-64**                 | **机器架构，表示这是一个AMD x86-64架构的文件** |
    | **version:**                           | **0x1**                                           | **ELF文件版本**                                |
    | **Entry point address:**               | **0x0**                                           | **入口点地址，为0x0**                          |
    | **start of program headers:**          | **0 (bytes into file)**                           | **程序头部的起始位置**                         |
    | **start of section headers:**          | **2016 (bytes into file)**                        | **节头部的起始位置，为2016字节**               |
    | **Flags:**                             | **0x0**                                           | **标志，为0x0**                                |
    | **size of this header:**               | **64 (bytes)**                                    | **头部大小，为64字节**                         |
    | **size  of program headers**           | **0 (bytes)**                                     | **程序头部的大小，为0字节**                    |
    | **number of program headers:**         | **0**                                             | **程序头部的数量，为0**                        |
    | **size of section headers:**           | **64  (byte)**                                    | **节头部的大小，为64字节**                     |
    | **Number of section headers:**         | **21 **                                           | **段头部的数量，为21**                         |
    | **Section header string table index:** | **20**                                            | **段头部字符串表索引，为20**                   |

  - `.text`**已编译程序的机器代码**

  - `.rodata`**只读数据**

  - `.data`**已经初始化的全局和静态C变量**

  - `.bss`**未初始化的全局和静态C变量，已经所有被初始化为0的全局或静态变量**

  - `.symtab`**一个符号表，它存放在程序中==定义和引用的函数和全局变量==的信息。**

  - `.rel.text`**一个.text节中位置的列表，当链接器把这个日标文件和其他文件组合时，需要修改这些位置。**

  - `.rel.data`**被模块==引用或定义==的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。**

  - `.debug`一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。

  - `.line`原始C源程序中的行号的`.text`节中机器指令之间的映射

  - `.strtab`一个字符串表，其内容包括`.symtab`和`.debug`节中的符号表，以及节头部中的节名字。

  - ==**不同节的位置和大小是由节头部表描述的**==

#### 符号和符号

- 每个可重定位目标模块`m`都有一个符号表，它包含m定义和引用的符号的信息。在链接器的上下文中，有**三种不同的符号**:

  - 由**模块`m`定义并能被其他模块引用的==全局符号==**。全局链接器符号对应于非静态的`C`函数和全局变量。
  - 由**==其他模块定义==并被模块`m`引用的全局符号。这些符号称为==外部符号==**，对应于在其他模块中定义的非静态`C`函数和全局变量。
  - **只被模块`m`定义和引用的==局部符号==。它们对应于带`static`属性的`C`函数和全局变量**。这些符号在模块`m`中任何位置都可见，但是不能被其他模块引用。

- ==**符号表**==：由**汇编器**构造，使用编译器输出到汇编语言`.s`文件中的符号，**这张符号表包含一个条目的数组**了。

  ```c
  typedef strcut
  {
      int name;		//String table offset
      char type:4,	//Function of data
      	bining:4;	//Local or globle
      char reserved;	//Unused
      short section;	//Section header index
      long value;		//Section offset or absolute address
      long size;		//Object size in bytes
  }ELF64_Symbol;
  ```

  - `name`：字符串表中的字节偏移，指向符号的以`null`结尾的字符串名字

  - `section`：每个符号都被分配到目标文件的某个节，**该字段也是一个到节头部表的索引**

    - **三个伪节：节头部表中没有条目**
      - ABS不该被重定位的符号
      - UNDEF代表未定义的符号
      - COMMON表示还**未被分配位置的未初始化**的数据目标
        - 对于COMMON符号：`value`字段给出对齐要求，`size`给出最小的大小。
        - COMMON为初始化的全局变量

  - | Num  | Value               | Size | Type   | Bind   | Vis     | Ndx  | Name  |
    | ---- | ------------------- | ---- | ------ | ------ | ------- | ---- | ----- |
    | 8:   | 0000 0000 0000 0000 | 24   | FUNC   | GLOBAL | DEFAULF | 1    | main  |
    | 9:   | 0000 0000 0000 0000 | 8    | OBJECT | GLOBAL | DEFAULF | 3    | array |

    - 在这个例子中，我们看到全局符号`main`定义的条目，它是一个位于`.text `节中偏移量为`0`(即 `value`值)处的`24`字节函数。其后跟随着的是全局符号 `array`的定义，它是一个位于`.data`节中偏移量为`0`处的`8`字节目标。
    - `Ndx=1`表示`.text`节，`Ndx=3`表示`.data`节

#### 符号解析

- 链接器**解析符号引用**的方法是将每个**引用**与它**输人的可重定位目标文件**的符号表中的一个确定的符号定义关联起来。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。
  不过，对全局符号的引用解析就棘手得多。当**==编译器遇==到一个不是在当前模块中定义的符号(变量或函数名)时**，会==**假设该符号是在其他某个模块中定义**==的，**生成一个链接器符号表条目**，并把它**交给链接器处理**。如果链接器在它的任何输人模块中都找不到这个被引用符号的定义，就输出一条(通常很难阅读的)错误信息并终止。
  - `C++和Java`方法重载
    - **编译器将每个唯一的==方法==和==参数列表组合==编码成一个对连接器来说唯一的名字，这种编码过程叫做==重整==，相反的过程叫做==恢复==**
    - 被重整的类名是**由名字中**字符的**整数数量**，**后面**加原始名字。**方法**被编码为原始方法**后加__**，加上被重整的类名。
- **==链接器==**如何解析多重定义的全局符号
  - 链接器的==**输入**==是一组可重定位目标模块，每个模块定义一组符号，有些是局部的，有些是全局的。**多个模块定义同名的全局符号，会发生什么？**
    - ==**编译器**==向**汇编器**输出**每个全局符号**，或是**强**或者是**弱**。
    - **汇编器**把这个信息隐含地编码在**可重定向目标文件地符号表里**
      - **函数**和已经**初始化**的**全局变量**是强符号。**未初始化**的全局变量是**弱符号**
        - `__attribute__((weak))` GCC声明为弱符号
    - `Linux`**链接器**处理规则
      - **==不允许有多个同名的强符号==**
      - ==**如果有一个强符号和多个弱符号同名，那么选择强符号。**==
      - ==**如果有多个弱符号同名，那么从这些弱符号中任意选择一个。**==
      - `gcc -fno-common` 在遇到多个重定义的全局符号时，触发一个错误
- 与静态库链接
  - **静态库**：用做链接器的输入。当链接器构造一个输出的可执行文件时，它只**复制静态库里==被应用程序引用==的目标模块**。
  - 在`Linux`系统中，静态库以一种称为**存档(archive)**的特殊格式存放在磁盘中，**存档文件**是**一组连接起来的可重定位目标文件的集合**，==**有一个头部用来描述每个成员目标文件的大小和位置**==。存档文件名由后缀`.a`标识。
    - `ar rcs name 1.o 2.o`构建静态链接库
    - `g++ -static -o name main.o ./libvector.a`
  - ***==静态链接库解析引用==***
    - 在**符号解析阶段**，链接器**从左到右**按照他们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。（驱动程序自动将命令行中所有的.c文件翻译位.o文件。）
    - 在这次扫描中：初始时`E`，`U`和`D`均为空
      - 链接器维护**一个可重定位目标文件的集合`E`**(这个集合中的文件会被合并起来形成可执行文件)
      - 一个**未解析的符号**(即引用了但尚未定义的符号)**集合`U`**
      - 以及一个==**在前面输入文件中已经定义的符号集合`D`**==
    - 对于命令行上的**每个输入文件**`f`，链接器会判断`f`是**一个目标文件**还是一个**存档文件**。**如果`f`是一个目标文件**，那么链接器把`f`添加到E，修改`U`和`D`来反映`f`中的符号定义和引用，并继续下一个输入文件。
    - **如果`f`是一个存档文件**，那么链接器就**尝试匹配`U`中未解析的符号和由存档文件成员定义的符号**。如果某个存档文件成员`m`，定义了一个符号来解析`U`中的一个引用，那么就将`m`加到`E`中，并且链接器修改`U`和`D`来反映`m`中的符号定义和引用。对存档文件中所有的成员目标文件都依次进行这个过程，直到`U`和`D`都不再发生变化。此时，任何不包含在`E`中的成员目标文件都简单地被丢弃，而链接器将继续处理下一个输人文件。
    - 如果当链接器完成对命令行上输人文件的扫描后，`U`是非空的，那么链接器就会输出一个错误并终止。否则，它会合并和重定位`E`中的目标文件，构建输出的可执行文件。
    - **==这种算法会导致一些令人困扰的连接时错误，因为命令行上的库和目标文件的顺序非常重要==**
      - 如果**定义一个符号的库**出现在**引用这个符号的目标文件之前**，引用就不能被解析，链接会失败。
      - 关于库的**一般准则是将它们放在命令行的结尾**。**如果各个库的成员是相互独立的**(也就是说没有成员引用另一个成员定义的符号)。
      - 另一方面，如果库不是相互独立的，那么必须对它们排序，使得对于每个被存档文件的成员外部引用的符号`s`，在命令行中至少有一个`s` 的定义是在对`s`的引用之后的。
        - 比如，假设`foo.c`调用`libx.a`和 `libz.a`中的函数，而这两个库又调用`liby.a`中的函数。那么，在命令行中`libx.a`和`libz.a`必须处在`liby.a`之前。
      - 如果需要满足依赖需求，==**可以在命令行上重复库**==。比如，假设`foo.c`调用`libx.a`中的函数，该库又调用`liby.a`中的函数，而`liby.a`又调用`libx.a`中的函数。那么`libx.a`必须在命令行上重复出现。
        - 另一种方法是，我们可以将`libx.a`和`liby.a`**合并成一个单独的存档文件**
