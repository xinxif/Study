### 绪论

1. 数据结构的基本概念
   - **数据**：数据是**信息的载体**，是描述客观事物属性的数、字符及所有**能输入到计算机中并被计算机程序识别和处理的符号的集合。**数据是计算机程序加工的原料。
   - **数据元素**：**数据元素是数据的基本单位**，通常作为一个整体进行考虑和处理。
   - **数据项**：一个数据元素可以有若干数据项组成，**数据项是构成数据元素的不可分割的最小单位**。
   - **数据结构**：是相互之间存在**一种或多种特定关系**的数据元素的集合。
   - **数据对象**：是具有**相同性质**的数据元素的集合，是数据的一个子集。
2. 数据的逻辑机构
   - 集合：各个元素同属于一个集合，别无其它关系
   - **线性结构**：数据元素之间是一对一的关系。除了第一个元素，所有元素都有唯一的前驱；除了追后一个元素，所有元素都有唯一后继。
   - **树形结构**：数据元素之间是一对多的关系。
   - **图形结构**：数据元素之间是多对多的关系。
3. 数据的物理结构
   - **顺序存储**：把**逻辑上相邻的元素存储在物理位置上也相邻的存储单元中**，元素之间的关系有存储单元的邻接关系来体系。
   - **链式存储**：**逻辑上相邻的元素在物理位置上可以不相邻**，借助指示元素存储地址的指针来表示元素之间的逻辑关系。
   - **索引存储**：在**存储元素信息的同时，还建立附加的索引表**。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址)
   - **散列存储**：散列存储。根据元素的关键字直接计算出该元素的存储地址，又称哈希( Hash）存储
4. 数据的运算：施加在数据上的运算包括运算的定义和实现。**运算的定义是针对楼辑结构的**，指出运算的功能;**运算的实现是针戏存储结构的**，指出运算的具体操作步骤。
5. 数据类型，抽象数据类型
   - 原子类型：其值不可再分的数据类型。
   - 结构类型：其值可以再分解为若干个成分的数据类型。
   - 抽象数据类型是抽象数据组织及与之相关的操作。
6. 算法
   - 算法（Algorithm）**是对特定问题求解步骤的一种描述**，它是指令的有限序列，其中的每条指令表示一个或多个操作
   - 算法的五个特性
     - **有穷性**：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。
     - **确定性**：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。
     - **可行性**：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。
     - **输入**：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。
     - **输出**：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。
   - “好“算法的特性
     - 正确性：能正确的解决问题
     - 可读性：对算法的描述要让其他人也看得懂
     - 健壮性：算法能处理一些异常状况
     - 高效率与底存储量需求：
       - 算法执行省时，省内存
       - 时间复杂度底，空间复杂度底
7. 算法效率的度量
   1. ==**时间复杂度**==
      - 事前预估算法**时间开销T**(n)与**问题规模**n的关系（T=time)
      - T(n)=O(n)，**大O表示“同阶”，同等数量级**。即：当n-->∞时，二者之比为常数。
      - **O(1)<O(log~2~n)<O(n)<O(nlog~2~n)<O(N^2^)<O(N^3^)<O(2^n^)<O(n!)<O(n^n^)** ==常对幂指阶==
        - **最坏时间复杂度：**考虑输入数据“最坏”的情况
        - **平均时间复杂度：**考虑所有输入数据都相等概率出现的情况
        - 最好时间复杂度：考虑输入数据“最好”的情况
   2. 空间复杂度
      - 无论问题规模怎么变，算法运行所需的内存空间都是固定的常量，算法空间复杂度为S(n)=O(1)，算法**原地工作**--算法所需内存空间为常量。
        - 普通程序
          - 找到所占空间大小与问题规模相关的变量
          - 分析所占空间X与问题规模n的关系x=f(n)
          - x的数量级O(x)就是算法空间复杂度s(n)
        - 递归程序
          - 找到递归调用的深度x与问题规模n的关系x=f(n)
          - x的数量积O(x)就是算法空间复杂度S(n)
          - 注：有的算法各层函数所需储存空间不同，分析方法略有区别

### 线性表

1. 线性表的定义和基本操作

   1. 线性表的定义

      - 线性表是具有**相同**数据类型的`n (n>0）`个数据元素的**有限序列**，其中**n为表长**，当n = O时线性表是一个**空表**。若用L命名线性表，则其一般表示为：L=(a~1~,a~2~.....a~i~,a~i+1~....a~n~)

      - a~i~是线性表中的“第i个”元素线性表中的**位序**

      - a~1~是**表头元素**a~n~是**表尾元素**。

      - 除第一个元素外，每个元素有且仅有**一个直接前驱**;除最后一个元素外，每个元素有且仅有**一个直接后继**

   2. 线性表的基本操作

      - `InitList(&L)`:**初始化**表。构造一个空的线性表L，分配内存空间。

      - `DestroyList(&L)`:**销毁**操作。销毁线性表，并释放线性表L所占用的内存空间。

      - `Listlnsert(&L,i,e)`:**插入**操作。在表L中的第i个位置上插入指定元素e

      - `ListDelete(&L,i,&e)`:**删除**操作。删除表L中第i个位置的元素，并用e返回删除元素的值。

      - `LocateElem(L,e)`:**按值查找**操作。在表L中查找具有给定关键字值的元素。

      - `GetElem(L,i)`:**按位查找**操作。获取表L中第i个位置的元素的值。

        - 其他常用操作:
          - `Length(L)`:求表长。返回线性表L的长度，即L中数据元素的个数。
          - `PrintList(L)`:输出操作。按前后顺序输出线性表L的所有元素值。
          - `Empty(L)`:判空操作。若L为空表，则返回true，否则返回false。

        

2. 顺序表

   - 顺序表――用**顺序存储**的方式实现线性表顺序存储。把**逻辑上相邻**的元素存储在**物理位置上也相邻的存储单元中**，元素之间的关系由存储单元的邻接关系来体现。

3. 单链表

   - 用“链式存储”（存储结构实现了“线性结构”（逻辑结构））

   - 一个节点存储一个数据

   - 各节点的先后关系用一个指针表示

   - ```c
     typedef struct LNode
     {
         ElemType data;
         struct LNode *next;
     }LNode,*LinkList;
     ```

   - 两种实现

     - 不带头节点
       - 空表判断：L==NULL，写代码不方便（在**第一个位置插入元素**需特殊处理）
     - 带头节点
       - 空表判断：L->next==NULL，写代码方便

   - 双链表

     - `void InsertNextDNode(DNode*p,DNode*s)`：在p节点之后插入s节点
       - 如果**p节点**是最后一个节点`p->next->prior=s`会报错
     - 插入（后插）
       - 边界情况：**新插入节点**在最后一个位置，需要特殊处理
     - 删除（后删）
     - 边界情况：如果**被删除节点**是最后一个数据节点，需要特殊处理
     - 遍历
       - 从一个给定节点开始，后向遍历，前向遍历的实现（循环的终止条件）
       - 链表不具备随机存储特性，查找操作只能通过遍历链表实现。

   - ```c
     #define MAXSIZE 10U
     typedef struct
     {
         ElemType data;//存取数据元素
         int next//下一个元素的数组下标
     }SLinkList[MAXSIZE];
     ```

   - 静态链表：用数组方式实现的链表

   - ==**链表的链接语句一定要注意顺序，头节点和尾节点有时需要特殊处理**==

4. 顺序表与链表的比较

   - 简答题模板

     - 顺序表和链表的**逻辑结构**都是线性结构，都属于线性表。

     - 但是二者的**存储结构**不同，顺序表采用顺序存储..(特点，带来的优点缺点);链表采用链式存储.. (特点、导致的优缺点)。

     - 由于采用不同的存储方式实现，因此**基本操作**的实现效率也不同。当初始化时..当插入- - 个数据元素.当删除--个数据元素时.当查找一个数据元素时...

### 栈和队列

#### 栈

1. 基本概念
   - 栈（stack）是只允许在一端进行插入和删除操作的线性表(First in Last out FILO)
   - 重要术语：栈顶，栈底，空栈
   - 卡特兰数：$\frac{1}{n+1}C\binom{n}{2n}$

#### 队列

1.    基本概念
   - 一种操作受限的线性表，只能**在尾插入**，在**对头删除**（先进先出FIFO)
2. 注意事项
   - <img style="width: 1300px;height:400px" src="Image\队列的判断.png ">
   - 队列元素个数计算：==**(rear+MaxSize-front)%MaxSize;**==
3. ==**重要考点**==
   - 如何初始化，入队，出队
   - 如何 **判空，判满**
   - 如何计算队列的长度
4. 分析思路
   - 确定`front`，`rear`指针的指向
     - `rear`指向队尾元素的最后一个元素
     - `rear`指向队尾元素
   - 确定判空的方法
     - 牺牲一个存储单元
     - 增加`size`变量记录队列长度
     - 增加`tag=0/1`用于标记最后一次操作是 **出队**/**入队**
5. 队列的链表实现
   - 带头结点/不带头结点
   - 入队：==**注意第一个元素入队**==
   - 出队：==**注意最后一个元素出队**==
6. 双端队列
   - <img style="width: 1100px;height:500px" src="Image\双端队列.png ">

#### 栈和队列的应用

1. 栈在括号匹配中的应用
   - 遇到左括号就入栈，遇到右括号，就消耗一个左括号
   - <img style="width: 1100px;height:500px" src="Image\括号匹配.png ">
