### 计算机系统概述

1. 计算机硬件

   ![img](file:///D:/Project/VSCode/Computer%20Organization/image/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC.png?lastModify=1747465693)

   - 在计算机系统中软件和硬件在逻辑上是等效的。
     - 对于乘法运算，可以设计一个专门的硬件电路实现乘法运算。也可以用软件的方式，执行多次加法运算来实现

   ![img](file:///D:/Project/VSCode/Computer%20Organization/image/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84.png?lastModify=1747465693)

   - **主机**：两部分（CPU和主存储器）

2. 各个硬件的工作原理

   1. 主存储器

      ![img](file:///D:/Project/VSCode/Computer%20Organization/image/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8.png?lastModify=1747465693)

      - **存储单元**:每个存储单元存放一串二进制代码
      - 存储**字**(word):存储单元中二进制代码的组合
      - 存储**字长**:存储单元中二进制代码的位数
      - 存储元:即存储二进制的电子元件，每个存储元可存1bit
        - MAR=4位→总共有166个存储单元
        - MDR=16位→每个存储单元可存放16bit,1个字(word) = 16bit

#### 数据表示和运算

1. 复合逻辑运算

   <img style="width: 1300px;height:400px" src="Image\与非.png ">

   <img style="width: 1300px;height:400px" src="Image\或非.png ">

   <img style="width: 1300px;height:500px" src="Image\异或.png ">

   <img style="width: 1300px;height:500px" src="Image\同或.png ">

2. 多路选择器

   - 注:有的多路选择器可能会预留一个控制信号，用于拦截所有输入。

   <img style="width: 1300px;height:500px" src="Image\多路选择器.png ">

3. 三态门

   <img style="width: 1300px;height:500px" src="Image\三态门.png ">

4. 无符号减法

   <img style="width: 1300px;height:500px" src="Image\无符号减法.png ">

   

   - 手算判断溢出的方法: n bit无符号整数表示范围0~2n-1，超出此范围则溢出
   - 计算机判断溢出的方法:
     - 无符号数加法的溢出判断:最高位产生的进位=1时，发生溢出，否则未溢出。
     - **无符号数减法的溢出判断**:减法变加法，最高位产生的进位=0时，发生益出，否则未溢出。

5. 原码乘法

   <img style="width: 1300px;height:500px" src="Image\原码乘法.png ">

   <img style="width: 1300px;height:500px" src="Image\手算原码加法.png ">

6. 无符号数乘法

   <img style="width: 1300px;height:500px" src="Image\无符号数乘法.png ">

7. 补码乘法

   <img style="width: 1300px;height:500px" src="Image\补码乘法.png ">

   <img style="width: 1300px;height:500px" src="Image\补码乘法3.png ">

   <img style="width: 1300px;height:300px" src="Image\溢出判断.png ">

   - ==**带符号数和无符号数**==用OF标准位检查是否溢出
     - ==**无符号数的CF也会同时置为是1**==

   <img style="width: 1300px;height:500px" src="Image\补码乘法2.png ">

8. 阵列乘法器

   <img style="width: 1300px;height:500px" src="Image\阵列乘法器.png ">

9. 比较

   1. **阵列乘法器**（快速乘法器中的一种)的运算速度最快——可1个时钟内完成运算·
   2. **由ALU、移位器、寄存器、控制逻辑组成的乘法电路运算速度较快**—通常需多个时钟才能完成运算
   3. **可以使用移位运算、加/减运算等效实现乘法，但运算速度最慢**

10. 浮点数

   - ==**非IEEE754标准的浮点数**==

     <img style="width: 1300px;height:500px" src="Image\浮点数.png ">

     <img style="width: 1300px;height:500px" src="Image\非标准浮点数规格化.png ">

     <img style="width: 1300px;height:500px" src="Image\非标准浮点数加减.png ">

### 存储系统

#### 主存储器的基本组成

1. 基本半导体元件及原理
   - <img style="width: 1300px;height:400px" src="Image\存储器实现原理.png ">
   - <img style="width: 1300px;height:400px" src="Image\存储芯片实现原理.png ">
   - <img style="width: 1300px;height:400px" src="Image\存储器实现原理2.png ">
     - MOS管可理解为一种电控开关，输入电压到某个阈值时，MOS管就可以接通。
     - **头上划线表示该信号低电平有效**
     - ==**片选线**==用来确定当前的存储芯片是否可用。例如一个内存条上可能包含多块存储芯片，我门只读其中的一块芯片，就需要把其它的芯片屏蔽掉。
2. 寻址
   - <img style="width: 1300px;height:400px" src="Image\寻址.png ">
   - 8*8位的存储芯片：`2^3*8bit`
   - **常见的考题**：芯片会有多少引脚？地址线与数据线分别有多少根，片选线，读写控制线有几根。相加=芯片会有多少引脚

#### 存储器的层次结构

1. <img style="width: 1300px;height:500px" src="Image\存储器的层次结构.png ">
   - 高数缓存和主存可**直接被CPU读写**
2. 按存取方式分类
   - <img style="width: 1300px;height:500px" src="Image\按存取方式分类.png ">
3. 按信息的可更改性
   - 读写存储器（Read/Write Memory)——即可读、也可写(如:磁盘、内存、Cache)
   - 只读存储器（Read Only Memory)——只能读，不能写(如:实体音乐专辑通常采用CD-ROM，实体电影采用蓝光光碟，BIOS通常写在ROM中)
     - 事实上很多ROM也可多次读写，只是比较麻烦
4. 按信息的可保存性
   - 断电后，存储信息消失的存储器――易失性存储器（主存、Cache)
   - 断电后，存储信息依然保持的存储器――非易失性存储器（磁盘、光盘)
   - 信息读出后，原存储信息被破坏――**破坏性读出**（如**DRAM芯片**，读出数据后要进行重写)
   - 信息读出后，原存储信息不被破坏――**非破坏性读出**（如**SRAM芯片**、磁盘、光盘)

#### 主存储器

1. DRAM芯片

   <img style="width: 1300px;height:500px" src="Image\DRAM芯片.png ">

2. 栅极电容与双稳态触发器

   <img style="width: 1300px;height:500px" src="Image\栅极电容与双稳态触发器.png ">

   - 表示1：A高电平B低
   - 表示0：A低电平B高
   - 
     双稳态触发器：只要不断电，触发器的状态就不会改变。
   - 电容内的电荷只能维持2ms。即便不断电2ms后信息也会消失，2ms之内必须刷新一次（给电容充电）。

   

   <img style="width: 1300px;height:500px" src="Image\SRAM与DRAM区别.png ">

   <img style="width: 1300px;height:500px" src="Image\DRAM刷新.png ">
   
   <img style="width: 1300px;height:500px" src="Image\行列地址.png ">

#### ROM

1. MROM(Mask Read-Only Memory) ——**掩模式只读存储器**厂家按照客户需求，在芯片生产过程中直接写入信息，**之后任何人不可重写**（只能读出)可靠性高、灵活性差、生产周期长、只适合批量定制

2. PROM (Programmable Read-Only Memory）—―**可编程只读存储器**用户可用专门的PROM写入器写入信息，写**一次之后就不可更改**

3. EPROM(Erasable Programmable Read-Only Memory)——**可擦除可编程只读存储器**允许用户写入信息，之后用某种方法擦除数据，**可进行多次重写**

4. UVEPROM (ultraviolet rays) ——用紫外线照射8~20分钟，擦除所有信息

5. EEPROM（也常记为E^2^PROM，第一个E是Electrically)——**可用“电擦除”的方式,擦除特定的字**

6. Flash Memory ——**闪速存储器**（注:U盘、SD卡就是闪存)

   - 每个存储元只需单个MOS管，位密度比RAM高
   - 在EEPROM基础上发展而来，断电后也能保存信息，且可进行多次快速擦除重写注意:由于闪存需要先擦除在写入，因此闪存的“写”速度要比“读”速度更慢。

7. SSD ( Solid State Drives） ——固态硬盘

   - 由**控制单元+存储单元**（Flash芯片）构成，与闪速存储器的核心区别在于控制单元不一样，但存储介质都类似，可进行多次快速擦除重写。SSD速度快、功耗低、价格高。目前个人电脑上常用SSD取代传统的机械硬盘
   - 拓:手机辅存也使用Flash芯片，但相比SSD使用的芯片集成度高、功耗低、价格贵

8. 主板上的**BIOS芯片（ROM）** ,存储了“**自举装入程序**”，负责引导装入操作系统（开机)

   <img style="width: 1300px;height:500px" src="Image\BIOS.png ">

   ​	很多ROM芯片虽然名字是“Read-Only”，但很多ROM也可以“写”。闪存的写速度一般比读速度更慢，因为写入前要先擦除。RAM芯片是易失性的，ROM芯片是非易失性的。很多ROM也具有“随机存取”的特性

#### 多体并行存储器

<img style="width: 1300px;height:500px" src="Image\多提并行存储器.png ">

<img style="width: 1300px;height:500px" src="Image\体.png ">

<img style="width: 1300px;height:500px" src="Image\差异.png ">

#### 主存储器与CPU的连接

1. **位扩展**

   - MAR，MDR通常集成在CPU内部。存储芯片内只需要一个普通的寄存器（暂存输入，输出数据）

     <img style="width: 1300px;height:500px" src="Image\位扩展.png ">

     <img style="width: 1300px;height:300px" src="Image\位扩展2.png ">

2. 字扩展

   <img style="width: 1300px;height:500px" src="Image\字扩展1.png ">

   <img style="width: 1300px;height:500px" src="Image\字扩展2.png ">

   - **蓝色的数字表示的是A14的值，这里的A14无论是何值都没影响。**
- 选择读写哪个芯片
   - 线选法
   
     - n条线->n个选片信号
       - 电路简单
       - 地址空间不连续
   
   - 译码片选发
   
     - n条线->2^n^个选片信号
       - 电路复杂
   
     - 地址空间可连续 

3. 字位同时扩展法

   <img style="width: 1300px;height:500px" src="Image\字位同时扩展法.png ">

4. 译码器

   <img style="width: 1300px;height:500px" src="Image\译码器.png ">

#### 磁盘存储器

1. 外存储器

   - 计算机的外存储器又称为辅助存储器，目前主要使用**磁表面**存储器。
   - 所谓“**磁表面存储**”，是指把某些**磁性材料**薄薄地**涂**在**金属铝或塑料表面上**作为载磁体来存储信息。
     - **磁盘存储器**、**磁带存储器**和**磁鼓存储器**均属于磁表面存储器。
   - 磁表面存储器的优点:
     ①存储容量大，位价格低;②记录介质可以重复使用;
     ③记录信息可以长期保存而不丢失，甚至可以脱机存档;④非破坏性读出，读出时不需要再生。
   - 磁表面存储器的缺点:
     ①存取速度慢;②机械结构复杂;
     ③对工作环境要求较高。

2. 磁盘设备的组成

   - 存储区域

     - 一块硬盘含有若干个**记录面**，每个==**记录面**==划分为若干条==**磁道**==，而每条**磁道**又划分为若干个==**扇区**==，**扇区**（也称块）是**磁盘读写的最小单位**，也就是说磁盘按块存取。

   - 硬盘存储器

     - 硬盘存储器由**磁盘驱动器**，**磁盘控制器**和**盘片**组成。

   - 磁盘驱动器:核心部件是**磁头组件**和**盘片组件**，温彻斯特盘是一种可移动头固定盘片的硬盘存储器

   - 磁盘控制器:是**硬盘存储器和主机的接口**，主流的标准有IDE、SCSI、SATA等。

     <img style="width: 1300px;height:150px" src="Image\磁盘.png ">

3. **==磁盘的性能指标==**

   - 磁盘的容量:一个磁盘所能**存储的==字节==总数**称为磁盘容量。磁盘容量**有非格式化容量**和**格式化容量**之分。

     - 非格式化容量是指磁记录表面可以利用的磁化单元总数。
     - 格式化容量是指按照某种特定的记录格式所能存储信息的总量

   - 记录密度:记录密度是指盘片单位面积上记录的二进制的信息量，通常以道密度、位密度和面密度表示。

     - ==**道密度**==是沿磁盘半径方向单位长度上的**磁道数**;
     - ==**位密度**==是**磁道**单位长度上**能记录的二进制代码位数**;
     - 面密度是**位密度**和**道密度**的**乘积**。
     - 注意:**磁盘所有==磁道==记录的信息量一定是相等的**，并不是圆越大信息越多，故每个磁道的位密度都不同。
     - <img style="width: 1300px;height:250px" src="Image\磁盘性能指标.png ">

   - 平均存取时间

     <img style="width: 1300px;height:500px" src="Image\平均存取时间.png ">

   - 数据传输速率

     - 数据传输率:磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。
     - 假设磁盘转数为`r`(转/秒)，每条磁道容量为`N`个字节，则数据传输率为D~r~=rN（理论最大速率）

4. 磁盘工作原理

   - 磁盘地址

     - 主机向磁盘控制器发送**寻址信息**，磁盘的**地址**一般如图所示:

     | 驱动器号 | 柱面（磁道）号 | 盘面号 | 扇区号 |
     | -------- | -------------- | ------ | ------ |

     - 若系统中有**4**个驱动器，每个驱动器带一个磁盘，每个**磁盘256个磁道**、**16个盘面**，每个**盘面划分为16个扇区**，则每个扇区地址要18位二进制代码;

     | 驱动器号（2bit) | 柱面（磁道）号(8bit) | 盘面号(4bit) | 扇区号(4bit) |
     | --------------- | -------------------- | ------------ | ------------ |

5. 硬盘的工作过程

   - 硬盘的主要操作是**寻址**、**读盘**、**写盘**。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。
   - 硬盘属于机械式部件，**其读写操作是串行的，不可能在同一时刻既读又写**，也不可能在同一时刻读两组数据或写两组数据。

6. 磁盘阵列

   - RAID ( Redundant Array of lnexpensive Disks，廉价冗余磁盘阵列）是将**多个独立的物理磁盘组成一个独立的逻辑盘**，**数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性**。
   - RAID的分级如下所示。在RAID1～RAID5的几种方案中，无论何时有磁盘损坏，都可以随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏。
     - RAID0:无冗余和无校验的磁盘阵列
       - RAIDO把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度，但RAID0没有容错能力。
     - RAID1:镜像磁盘阵列。
       - RAID1是为了提高可靠性，使两个磁盘同时进行读写，互为备份，如果一个磁盘出现故障，可从另一磁盘中读出数据。两个磁盘当一个磁盘使用，意味着容量减少一半。
     - RAID2:采用纠错的海明码的磁盘阵列。
     - RAID3:**位**交叉奇偶校验的磁盘阵列。
     - RAID4:**块**交叉奇偶校验的磁盘阵列。
     - RAID5:无独立校验的奇偶校验磁盘阵列。

#### SSD固态硬盘

1. 组成

   <img style="width: 1300px;height:500px" src="Image\SSD组成.png ">

   - 闪存翻译层——负责翻译逻辑块号，找到对应页(Page)
   - 存储介质:多个闪存芯片(Flash Chip)—每个芯片包含多个块(block)——每个块包含多个页(page)

2. 读写性能特征

   - 以==**页(page)为单位读/写**==─相当于磁盘的"扇区"
   - 以==**块(block)为单位"擦除"**==，擦干净的块，其中的每页都可以写一次，读无限次
   - 支持随机访问，系统给定一个逻辑地址，闪存翻译层可通过电路迅速定位到对应的物理地址
   - 读快、写慢。要写的页如果有数据，则不能写入，需要将块内其他页全部复制到一个新的(擦除过的）块中，再写入新的页

3. 与机械硬盘相比的特点

   - SSD读写速度快，随机访问性能高，用电路控制访问位置;机械硬盘通过移动磁臂旋转磁盘控制访问位置，有寻道时间和旋转延迟
   - SSD安静无噪音、耐摔抗震、能耗低、造价更贵
   - SSD的一个"块"被擦除次数过多(重复写同一个块)可能会坏掉，而机械硬盘的扇区不会因为写的次数太多而坏掉

4. 磨损均衡技术

   - 思想:将"擦除"平均分布在各个块上，以提升使用寿命
   - 动态磨损均衡——写入数据时，优先选择累计擦除次数少的新闪存块
   - 静态磨损均衡——SSD监测并自动进行数据分配、迁移，让老旧的闪存块承担以读为主的储存任务，让较新的闪存块承担更多的写任务

#### Cache

1. 局部性原理

   <img style="width: 1300px;height:500px" src="Image\局部性原理.png ">

   - 将主存的**存储空间“分块”**，如:每1KB为一块。主存与Cache之间以“块”为单位进行数据交换。

   <img style="width: 1300px;height:400px" src="Image\局部性原理2.png ">

2. ==**性能分析**==

   - 设**t~c~**为访问一次**Cache**所需时间,
   - **t~m~**为访问一次**主存**所需时间
   - 命中率**H**:CPU欲访问的信息已在Cache中的比率
     - 缺失（未命中）率**M**= 1-H
   - Cache—主存系统的**平均访问时间**t为
     - t = Ht~c~+(1-H)(t~c~ + t~m~)。先访问Cache，若Cache未命中再访问主存
     - t = Htc+(1- H )t~m~。同时访问Cache和主存，若Cache命中则立即停止访问主存

3. CPU与主存的映射方式

   - 全相连映射：随便放
     - <img style="width: 1300px;height:400px" src="Image\全相联映射.png ">
   - 直接映射
     - <img style="width: 1300px;height:500px" src="Image\直接映射.png ">
   - 组相联映射
     - <img style="width: 1300px;height:500px" src="Image\组相联映射.png ">

4. Cache替换算法

   - **随机算法**（RAND,Random) ――若cache已满，则随机选择一块替换。
     - 随机算法―—实现简单，但完全没考虑局部性原理，命中率低，实际效果很不稳定。
     - <img style="width: 1300px;height:300px" src="Image\随机算法.png ">
   - **先进先出算法**（FIFO, First ln First Out）——若Cache已满，则替换最先被调入cache的块
     - 先进先出算法――实现简单，最开始按#0#1#2#3放入Cache，之后轮流替换#0#1#2#3FIFO依然没考虑局部性原理，最先被调入Cache的块也有可能是被频繁访问的
   - **==近期==最少使用算法**（LRU, Least Recently Used ) -―为每一个Cache块设置一个“**计数器**”，用于记录每个Cache块已经有**多久没被访问了**。当Cache满后**替换“计数器”最大的**
     - 命中时，所命中的行的计数器清零，比其低的计数器加1，其余不变;
     - 未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1;
     - 未命中且无空闲行时，计数值最大的行的信息块被淘汰，新装行的块的计数器置0，其余全加1。
     - Cache块的总数=2n，则计数器只需n位。且Cache装满后所有计数器的值一定不重复
     - <img style="width: 1300px;height:300px" src="Image\近期最少使用算法.png ">
     - LRU算法――基于“局部性原理”，近期被访问过的主存块，在不久的将来也很有可能被再次访问，因此淘汰最久没被访问过的块是合理的。LRU算法的实际运行效果优秀，cache命中率高。
     - 若被频繁访问的主存块数量**大于**Cache行的数量，则有可能发生“抖动”，如:1，2，3，4，5，1，2，3，4，5
   - **最不经常使用算法**(LFU, Least Frequently Used )——为每一个Cache块设置一个“计数器”，用于记录每个cache块被访问过几次。当Cache满后替换“计数器”最小的‘
     - LFU算法――**曾经被经常访问的主存块在未来不一定会用到(**如:微信视频聊天相关的块),并没有很好地遵循局部性原理，因此实际运行效果不如LRU
     - <img style="width: 1300px;height:300px" src="Image\最不经常使用算法.png ">

5. Cache写策略

   1. 写命中

      1. **写回法**(write-back)
         - 当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存
           减少了访存次数，但**存在数据不一致的隐患**。
         - <img style="width: 1300px;height:400px" src="Image\写回法.png ">

      2. **全写法**（写直通法）

         - 当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一**般使用写缓冲**(write buffer)
           - 使用写缓冲，CPU写的速度很快，若写操作不频繁，则效果很好。若写操作很频繁，可能会因为写缓冲饱和而发生阻塞

         - 访存次数增加，速度变慢，但更能保证数据一致性

         - <img style="width: 1300px;height:400px" src="Image\全写法.png ">

   2. 写不命中

      1. 写分配法
         - 当CPU对Cache写不命中时，把主存中的块调入Cache，在Cache中修改。**通常搭配写回法使用**。
      2. 非写分配法
         - 当CPU对Cache写不命中时只写入主存，不调入Cache。搭配全写法使用。

   3. 多级Cache

      - <img style="width: 1300px;height:300px" src="Image\多级Cache.png ">

#### 虚拟存储器

1. 相关概念和基本工作原理
   - 可将**虚拟存储器**看作是主存和辅存构成的、单一的、可供CPU直接访问的超大容量主存。
   - 程序员在进行编程时，面向的是虚拟存储器，相应地，使用的是**虚拟地址VA**。
   - 为了实现虚拟存储器，需要增加相应的软硬件:
     - 软件:**操作系统OS**
     - 硬件:**存储器管理单元MMU**
     -  CPU通过==**MMU**==将指令中的**虚拟地址VA**==转换==为主存的**物理地址PA**。
     - 在地址转换过程中，MMU会检查是否发生了数据缺失(即访问信息不在主存)或地址越界、访问越权或越级等存储保护错误。
       - **若数据缺失**，则由操作系统将数据从辅存调入到主存。
       - 若**出现存储保护错误**，则由操作系统进行相应的异常处理。
   - **虚拟存储器**利用**程序的局部性原理**，从辅存调入程序到主存时，并不是将程序的全部代码和相关数据调入主存,通常只需要加载很小一部分即可，以提高主存的利用率。
     - 这与cache技术类似，**尽可能将辅存中经常被访问的程序和相关数据的副本调入到主存中**。当主存满时，需要将主存中最不经常访问的程序和相关数据进行淘汰。
   - **虚拟存储器由==操作系统==和==相关硬件共同==协作实现**，涉及操作系统部分的内容（例如进程、存像者器管理、虚拟地址空间、缺页处理等)，会在操作系统课程中深入讨论，本课程主要介绍虚拟存储器所涉及到的硬件部分。
   - <img style="width: 400px;height:600px" src="Image\虚拟存储器组织结构.png ">
2. 页式虚拟存储器概述
   - 与cache技术将cache作为主存的缓存相似，虚拟存储器技术是**将主存作为辅存的缓存**。因此，要实现虚拟存储器就需要考虑所交换**数据块的大小问题、地址映射问题、数据块替换问题、(写入时的)数据一致性问题等**。
   - 可将**虚拟存储器**看作是**主存和辅存构成**的、单一的、可供CPU直接访问的超大容量主存。
   - 对于**==页式==虚拟存储器**，其==**地址空间**==被**划分**成若干个固定大小的**页面**(page) ，简称页，==**主存与辅存之间按页交换信息**==。
     - 虚拟地址空间中的页称为**虚拟页**(Virtual Page，VP)，简称**虚页也称为逻辑页**。
     - 主存空间中的页称为==**物理页**==(Physical Page，PP)，简称**==实页==也称为==页框==（==页帧==)**。
   - 页式虚拟存储器采用“**请求分页**”的思想:
     - 将进程中**活跃的页面**(包含有当前访问的指令或数据)**从辅存调入主存**，而不活跃的页面保留在辅存中。
     - 当**访问某个信息(指令或数据)时**，若该信息所在页面**不在主存中时发生缺页异常**，此时从**辅存将缺失页面调入主存**。
   - <img style="width: 1400px;height:400px" src="Image\页式虚拟存储器概述.png ">
     - 页式虚拟存储器的**缺页处理代价远大于cache数据缺失**（未命中)**的处理代价**因此,通常将页式虚拟存储器中主存与辅存之间交换的**页面的大小设置得比较大**，常见的**页面大小为4KB**,也有更大容量的页面。
     - 由于缺页处理的代价较大，因此，**==主存==与==辅存==之间采用==全相联映射==方式**，**以提高命中率**。由于辅存的访问速度远小于主存的访问速度，因此在**进行==写操作==时**，应采取的**写入策略为==写回法==**,而不是写穿法。
3. 地址映射和页表
   - <img style="width: 1400px;height:400px" src="Image\页表.png ">
   - 对于**每个进程**，都需要建立进程中**各个虚拟页**与所存放的**主存物理页**或**磁盘上存储位置之间的关系**，通常采用==**页表**==(Page Table，PT)来记录这种对应关系。
   - ==**页表**==采用==**虚拟页号作为索引**==进行访问（VP0,VP1,VP3.....)
   - ==**有效位**===1，表明该虚拟页已从辅存调入主存有效位=0，表明该虚拟页没有被调入主存
   - ==**若存放位置**===null，表明该虚拟页为没有内容的页面
     - 若存放位置≠null，存放位置给出了该虚拟页在磁盘上的起始地址
   - ==**脏位**==用来指明页面是否被修改过。
     - 由于虚拟存储器采用写回法，因此，在需要进行页面替换时，可根据脏位来判断是否需要将主存中被替换的页面写回辅存。
     - ==**磁盘的交换分区**==用于存放主存中替换出的动态修改数据的页面。
   - ==**替换控制位**==
     - 与具体替换算法结合使用
   - **==方位权限位==**用来指明页面的访问权限（用于存储保护)
     - 可读可写
     - 只读
     - 只可执行
   - <img style="width: 1400px;height:400px" src="Image\地址映射.png ">
4. 页式虚拟存储器的访问流程
   - <img style="width: 1400px;height:200px" src="Image\页式虚拟存储器的访问流程.png ">
   - <img style="width: 1400px;height:200px" src="Image\页式虚拟存储器的访问流程2.png ">
   - <img style="width: 1400px;height:200px" src="Image\页式虚拟存储器的访问流程3.png ">
   - 结合Cache的页式虚拟存储器的访问流程
     - <img style="width: 1400px;height:400px" src="Image\页式虚拟存储器结合Cache.png ">
     - <img style="width: 1400px;height:400px" src="Image\页式虚拟存储器结合Cache2.png ">
5. 使用块表加数地址转换
   - 为了加快MMU进行虚拟地址到物理地址转换的速度，现代处理器内部都包含有一个**转换后备缓冲器**(Translation Lookaside Buffer，==**TLB**==)，**==专门用于缓存==经常访问的==页表项==**。
   - 可将TLB看作是一个容量较小的cache(只不过**仅用于缓存**经常访问的**页表项)**，由于TLB的访问速度远高于主存，因此通常将**TLB表称为==快表==**，相应地将**主存中的页表称为慢表**。
   - 为了提高查找速度，TLB一般采用==**全相联**==或==**组相联**==方式，出现TLB缺失时常采用==**随机替换算法**==。
   - ==**全相联下的地址划分**==
     - <img style="width: 1400px;height:400px" src="Image\全相联下的地址划分.png ">
   - ==**组相联下的地址划分**==
     - <img style="width: 1400px;height:400px" src="Image\组相联下的地址划分.png ">
   - 基于块表的访问过程
     - <img style="width: 1400px;height:400px" src="Image\基于块表的访问过程.png ">
6. 基于TLB，cache的访问流程
   - <img style="width: 1400px;height:450px" src="Image\TLB访问流程.png ">
   - <img style="width: 1400px;height:300px" src="Image\TLB命中.png ">
   - ==**cache缺失处理由硬件完成**。==
   - **缺页处理**由**操作系统**通过**缺页异常处理程序来完成**，即由软件完成。
   - **TLB缺失处理，==既可以用硬件==也可以==用软件==来完成**。若用软件完成，则操作系统通过专门的TLB缺失异常处理程序来完成。

### 指令系统

#### 寻址

1. 数据寻址
   - ==**直接寻址**==
     - <img style="width: 1400px;height:100px" src="Image\直接寻址.png ">
     - <img style="width: 1400px;height:200px" src="Image\直接寻址2.png ">
     - 直接寻址:指令字中的**形式地址A**就**是**操作数的**真实地址EA**，即EA=A。
     - 一条指令的执行:取指令访存1次执行指令访存1次暂不考虑存结果共访存2次
     - 优点:简单，指令执行阶段仅访问一次主存,不需专门计算操作数的地址。
     - 缺点:A的位数决定了该指令操作数的寻址范围。操作数的地址不易修改。
   - ==**间接寻址**==
     - <img style="width: 1400px;height:300px" src="Image\间接寻址.png ">
     - 间接寻址:指令的地址字段给出的==**形式地址不是操作数的真正地址**==，而是==**操作数有效地址所在的存储单元的地址**==，也就是操作数地址的地址，即EA=(A)。
     - 优点:可扩大寻址范围(**有效地址EA的位数大于形式地址A的位数**)。
     - 缺点:指令在执行阶段要多次访存(一次间址需两次访存，多次寻址需根据存储字的最高位确定几次访存)。
   - 寄存器寻址
     - <img style="width: 1400px;height:400px" src="Image\寄存器间接寻址.png ">
   - 寄存器间接寻址
     - <img style="width: 1400px;height:400px" src="Image\寄存器间接寻址2.png ">
     - 寄存器间接寻址:寄存器R,中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA=(R~i~)
     - 一条指令的执行:取指令访存1次执行指令访存1次暂不考虑存结果共访存2次
     - 特点:与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存(因为操作数在主存中)。
   - 隐含寻址
     - <img style="width: 1400px;height:300px" src="Image\隐含寻址.png ">
     - 隐含寻址:不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。
     - 优点:有利于缩短指令字长。
     - 缺点:需增加存储操作数或隐含地址的硬件。
   - 立即寻址
     - **形式地址A就是操作数本身，又称为==立即数==**，**一般采用补码形式**。#表示立即寻址特征。、
     - 一条指令的执行:取指令访存1次执行指令访存0次暂不考虑存结果共访存1次
     - 优点:指令执行阶段不访问主存，指令执行时间最短
     - 缺点:A的位数限制了立即数的范围。
2. 偏移寻址
   - ==**基址寻址**==
     - <img style="width: 1400px;height:300px" src="Image\基址寻址.png ">
     - 基址寻址:将CPU中**基址寄存器（BR）Base address register**的内容**加**上指令格式中的**形式地址A**，而形成操作数的有效地址，**即EA=(BR)+A**。
     - 注:基址寄存器是**面向操作系统**的，其**内容由操作系统或管理程序确定**。在程序执行过程中，基址寄存器的内容不变（作为基地址)，形式地址可变（作为偏移量)。当采用通用寄存器作为基址寄存器时，可由**用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定。**
     - 优点:可扩大寻址范围（基址寄存器的位数大于形式地址A的位数)﹔用户不必考虑自己的程序存于主存的哪一空间区域，故有利于多道程序设计，以及可用于编制浮动程序(整个程序在内存里边的浮动）。
   - ==**变址寻址**==
     - 变址寻址:有效地址**EA**等于指令字中的**形式地址A**与**变址寄存器lX（Index register）**的内容**相加之和**，即**EA=(IX)+A**，其中IX可为变址寄存器（专用），也可用通用寄存器作为变址寄存器。
     - 注:变址寄存器是面向用户的，在程序执行过程中，**变址寄存器的内容可由用(作为偏移量），形式地址A不变（作为基地址)**
     - 优点:在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器Ix的内容，便可很容易形成数组中任一数据的地址，特别**适合编制循环程序**。
     - <img style="width: 1400px;height:500px" src="Image\变址寻址.png ">
     - ==**基址寻址和变址寻址可以混合使用，且各种寻址都可以混合使用**==
   - ==**相对寻址**==
     - 相对寻址:把**程序计数器PC**的内容**加**上指令格式中的**形式地址A**而形成操作数的有效地址，即**EA=(PC)+A**，其中A是相对于PC所指地址的位移量，可正可负，==**补码表示**==。
     - 优点:操作数的地址不是固定的，它随着PC值的变化而变化，并且与指令地址之间总是相差一个固定值，因此便于程序浮动(一段代码在程序内部的浮动)。相对寻址广泛应用于转移指令。
     - <img style="width: 1400px;height:500px" src="Image\相对寻址.png ">
     - ==**注意:取出当前指令后,PC会指向下一条指令相对寻址是相对于下一条指令的偏移**==
     - <img style="width: 1400px;height:500px" src="Image\cmp指令.png ">
   - ==**堆栈寻址**==
     - <img style="width: 1400px;height:500px" src="Image\堆栈寻址.png ">
   - 差异
     - <img style="width: 1400px;height:450px" src="Image\数据寻址差异.png ">

#### 代码的机器级表示

1. 汇编语言差异

   - <img style="width: 1400px;height:450px" src="Image\汇编格式.png ">
   - Intel x86处理器中程序计数器PC通常被称为==**IP**==

2. cmp指令实现原理

   - <img style="width: 1400px;height:450px" src="Image\cmp指令实现原理.png ">

3. loop指令

   - ```c++
     for(int i = 500;i>0;i--)
     {
        	//做某些处理
     }
     mov ecx 500
     looptop:			 #用ecx作为循环计数器
     ...					 #循环的开始
     做某些处理
     ...
     loop looptop #ecx--，若ecx!=0，跳转到Looptop
     ```

   - 理论上，能用`loop`指令实现的功能一定能用条件转移指令实现

     - 使用loop指令可能会使代码更清晰简洁补充: loopx指令―—如 `loopnz`,` loopz`
     - `loopnz`—当`ecx!=0 && ZF==0`时，继续循环`loopz`—当`ecx!=0 && ZF==1`时，继续循环
     - ==loop指令指定ecx寄存器==

4. 函数调用指令

   - <img style="width: 1400px;height:400px" src="Image\函数调用栈的修改.png ">
   - 切换函数调用栈
     - <img style="width: 1400px;height:400px" src="Image\函数调用.png ">
     - <img style="width: 1400px;height:500px" src="Image\函数返回.png ">
   - 参数传递
     - <img style="width: 1400px;height:500px" src="Image\参数传递.png ">

#### CISC&RISC

<img style="width: 1400px;height:500px" src="Image\CISCRISC.png ">

<img style="width: 1400px;height:500px" src="Image\CISCRISC2.png ">

### 中央处理器

#### CPU的功能和基本结构

1. CPU的功能

   - <img style="width: 1400px;height:500px" src="Image\CPU.png ">
   - **指令控制**。完成取指令、分析指令和执行指令的操作，即程序的顺序控制。
   - **操作控制**。一条**指令的功能往往是由若干操作信号的组合来实现的**。CPU管理并**产生由内存取出的每条指令的操作信号**，把各种**操作信号送往相应的部件**,从而**控制这些部件按指令的要求进行动作**。
   - **时间控制**。对各种操作加以时间上的控制。**时间控制要为每条指令按==时间顺序==提供应有的控制信号**。
   - **数据加工**。对数据进行算术和逻辑运算。
   - **中断处理**。对计算机运行过程中出现的异常情况和特殊请求进行处理。

2. 运算器

   - ==**算术逻辑单元**==:主要功能是进行算术/逻辑运算。

   - ==**通用寄存器组**==:如AX、BX、CX、DX、SP等，用于存放操作数（包括源操作数、目的操作数及中间结果)和各种地址信息等。
     - SP是堆栈指针，用于指示栈顶的地址。
   - ==**暂存寄存器**==:用于暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏其原有内容。
   - ==**累加寄存器**==:它是一个通用寄存器，用于暂时存放ALU运算的结果信息，用于实现加法运算。
   - ==**程序状态字寄存器**==:保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如溢出标志(OP)、符号标志(SF)、零标志（ZF）、进位标志(CF）等。PSW中的这些位参与并决定微操作的形成。
   - ==**移位器**==:对运算结果进行移位运算。
   - **==计数器==**:**控制乘除运算的操作步数**。

3. 控制器

   - ==**程序计数器**==:用于指出下一条指令在主存中的存放地址。CPU就是根据PC的内容去主存中取指令的。因程序中指令（通常）是顺序执行的，所以Pc有自增功能。
   - ==**指令寄存器**==:用于保存当前正在执行的那条指令。
   - ==**指令译码器**:==仅对操作码字段进行译码，向控制器提供特定的操作信号。
   - **==微操作==信号发生器**:根据**IR**（**==指令寄存器==存放当前执行的指令**）的内容（指令)、PSW的内容（状态信息）及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种。
   - **==时序系统==**:用于产生各种时序信号，它们都是由统一时钟(CLOCK）分频得到。
   - ==**存储器地址寄存器**==:用于存放所要访问的主存单元的地址。

4. <img style="width: 1400px;height:500px" src="Image\CPU内部总线.png ">

#### 指令执行过程

1. 指令周期
   - 指令周期:CPU从主存中每**取出**并**执行**一条**指令**所需的**全部时间**。
   - **指令周期**常常用若干**机器周期**来表示，机器周期又叫**CPU周期**。
     - 一个机器周期又包含若干**时钟周期**（也称为**节拍**、**T周期**或**CPU时钟周期**，它是CPU操作的最基本单位)。
     - **每个指令周期内机器周期数可以不等，每个==机器周期内的节拍数也可以不等==**
   - <img style="width: 1400px;height:300px" src="Image\指令周期.png ">
   - <img style="width: 1400px;height:400px" src="Image\指令周期2.png ">
   - <img style="width: 1400px;height:400px" src="Image\指令周期3.png ">
2. 执行周期数据流
   - <img style="width: 1400px;height:400px" src="Image\取指周期.png ">
   - <img style="width: 1400px;height:400px" src="Image\间址周期.png ">
   - **执行周期**的任务是根据**IR**中的指令字的**操作码和操作数**通过ALU操作产生执行结果。不**同指令的==执行周期操作不同==，因此没有统一的数据流向。**
   - <img style="width: 1400px;height:400px" src="Image\中断周期.png ">
3. 指令执行方案
   - 单指令周期
     - 对**所有指令**都选用**相同的执行时间**来完成。
     - **指令之间串行执行**;**指令周期取决于执行时间最长的指令的执行时间**。
     - 对于那些本来可以在更短时间内完成的指令，要使用这个较长的周期来完成，会降低整个系统的运行速度。
   - 多指令周期
     - 对**不同类型的指令选用不同的执行步骤**来完成。
     - **指令之间串行执行**;可选用不同个数的时钟周期来完成不同指令的执行过程。
     - 需要更复杂的硬件设计。
   - 流水线方案
     - **在每一个时钟周期启动一条指令，尽量让多条指令同时运行**，但各自处在不同的执行步骤中。指令之间**并行**执行。

#### ==**数据通路**==

1. 单总线结构
   - 多个部件共享总线，同一时刻只能有一个部件使用
   - CPU内部多总线方式：多个部件共享多个总线
   - 专用数据通路方式：有些部件之间会有专用数据通路
   - <img style="width: 1400px;height:500px" src="Image\取址操作.png ">
   - <img style="width: 600px;height:250px" src="Image\间址周期2.png ">
   - <img style="width: 600px;height:250px" src="Image\执行周期.png ">
2. 专用数据通路
   - <img style="width: 1400px;height:400px" src="Image\专用数据通路.png ">
   - ==在大题中描述各阶段的微操作序列和控制信号==出题比较固定

#### 控制器的功能和工作原理

1. <img style="width: 1400px;height:550px" src="Image\控制器设计.png ">
2. 硬布线控制器
   - <img style="width: 1400px;height:550px" src="Image\硬布线控制器.png ">
   - 分析每个阶段的微操作序列
     - <img style="width: 1400px;height:450px" src="Image\硬布线控制器设计.png ">
     - <img style="width: 1400px;height:550px" src="Image\分析每个阶段的微操作序列.png ">
   - 安排微操作时序
     - <img style="width: 1400px;height:350px" src="Image\安排微操作时序.png ">
   - 电路设计
     - 取指阶段操作时间表
     - <img style="width: 1400px;height:450px" src="Image\取指阶段操作时间表.png ">
     - 间指周期操作时间表
     - <img style="width: 1400px;height:350px" src="Image\间指周期操作时间表.png ">
     - 执行周期操作时间表
     - <img style="width: 1400px;height:450px" src="Image\执行周期操作时间表.png ">
     - 根据操作时间表写出微操作命令的最简表达式
       - 逻辑表达式
       - <img style="width: 1400px;height:450px" src="Image\逻辑表达式.png ">
       - <img style="width: 1400px;height:450px" src="Image\逻辑图.png ">
3. ==微程序控制器==
   - 基本概念
     - <img style="width: 1400px;height:400px" src="Image\微程序控制器的设计思路.png ">
     - 采用“存储程序”的思想，CPU出厂前将所有指令的“微程序”存入“控制器存储器”中
     - **指令**是对**程序执行步骤**的描述
     - **微指令**是对**指令执行步骤**的描述
     - **微命令**与**微操作**一一对应
     - **微指令**中可能包含多个微命令
   - 基本结构
     - **微地址形成部件**：产生初始微地址和后续微地址继微地址，以保证微形成部件指令的连续执行。
     - **CMAR**：别名: uPC，微地址寄存器，接收微地址形成部件送来的微地址，为在CM中读取微指令作准备。
     - **地址译码**：将地址码转化为存储单元控制信号。
     - **CMDR**：别名:ulR，用于存放从CM中取出的微指令，它的位数同微指令字长相等。
     - **控制存储器CM**：用于存放各指令对应的微程序，控制存储器可用只读存储器ROM构成。
     - ==**取指周期微程序**==通常是公用的，
       - 故如果某指令系统中有n条机器指令，则CM中微程序的个数至少是n+1个
       - 一些早期的CPU、物联网设备的CPU**可以不提供间接寻址和中断功能**,因此这类CPU可以不包含间址周期、中断周期的微程序段
     - ==**Tips**:==物理上，**取指周期、执行周期看起来像是两个微程序，但逻辑上应该把它们看作一个整体**。因此，“一条指令对应一个微程序”的说法是正确的
     - <img style="width: 1400px;height:500px" src="Image\微程序控制器工作原理.png ">
   - 微指令的设计
      - 微指令的格式
         - <img style="width: 1400px;height:500px" src="Image\微指令格式.png ">
      - 微指令编码方式
         - <img style="width: 1400px;height:500px" src="Image\微指令编码方式.png ">
         - <img style="width: 1400px;height:200px" src="Image\字段间接编码方式.png ">
      - 微指令地址形成方式
         - <img style="width: 1400px;height:400px" src="Image\微指令地址形成方式.png ">
      - 微程序控制单元的设计
         - <img style="width: 1400px;height:400px" src="Image\微操作控制序列.png ">
         - <img style="width: 1400px;height:400px" src="Image\微程序控制器取值周期节拍.png ">
         - <img style="width: 1400px;height:400px" src="Image\微程序控制器设计.png ">
         - <img style="width: 600px;height:400px" src="Image\微程序设计分类.png ">
   - <img style="width: 1400px;height:400px" src="Image\微程序控制器与硬布线控制器比较.png ">

#### 指令流水线

1. 定义
   - <img style="width: 1400px;height:400px" src="Image\指令流水线.png ">
   - <img style="width: 1400px;height:400px" src="Image\时空图过程图.png ">
2. 流水线性能指标
   - ==吞吐率==
     - <img style="width: 1400px;height:400px" src="Image\流水线吞吐率.png ">
   - 加速比
     - <img style="width: 1400px;height:400px" src="Image\指令流水线加速比.png ">
   - 效率
     - <img style="width: 1400px;height:400px" src="Image\指令流水线效率.png ">
3. 指令流水线的影响因数和分类
   - 结构相关（资源冲突）
     - <img style="width: 1400px;height:400px" src="Image\资源冲突.png ">
   - 数据相关（数据冲突）
     - <img style="width: 1400px;height:400px" src="Image\数据相关.png ">
   - 控制相关（控制冲突）
     - <img style="width: 1400px;height:400px" src="Image\控制相关.png ">
4. 流水线的分类
   - 根据流水线使用的级别的不同，流水线可分为部件**功能级流水线**、**处理机级流水线**和**处理机间流水线**。
     - **部件功能级流水**就是将**复杂的算术逻辑运算组成流水线工作方式**。例如，可将浮点加法操作分成求阶差、对阶、尾数相加以及结果规格化等4个子过程。
     - **处理机级流水**是把一条指令解释过程分成多个子过程，如**前面提到的取指、译码、执行、访存及写回5个子过程**。
     - **处理机间流水**是一种宏流水，其中每**一个处理机**完成**某一专门任务**，各个处理机所得到的结果需存放在与下一个处理机所共享的存储器中。
   - 按流水线可以完成的功能，流水线可分为单功能流水线和多功能流水线。
     - **单功能流水线**指只能实现一种固定的专门功能的流水线;
     - **多功能流水线**指通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线。
   - 按同一时间内各段之间的连接方式，流水线可分为静态流水线和动态流水线。
     - **静态流水线**指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。
     - **动态流水线**指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。
   - 按流水线的**各个功能段之间是否有反馈信号**，流水线可分为线性流水线与非线性流水线。
     - **线性流水线**中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路。
     - **非线性流水线**存在反馈回路，从输入到输出过程中，某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算。
5. 流水线的多发技术
   - <img style="width: 800px;height:500px" src="Image\超标量技术.png ">
   - <img style="width: 800px;height:500px" src="Image\超流水技术.png ">
   - <img style="width: 800px;height:500px" src="Image\超长指令字.png ">
6. ==**五段式指令流水线**==
   - <img style="width: 1000px;height:400px" src="Image\运算类指令.png ">
   - <img style="width: 1000px;height:400px" src="Image\LOAD指令.png ">
   - <img style="width: 1300px;height:400px" src="Image\STORE指令.png ">
   - <img style="width: 1300px;height:400px" src="Image\条件跳转指令.png ">
   - <img style="width: 1300px;height:400px" src="Image\无条件跳转指令.png ">



#### 多处理机的基本概念

1. 硬件多线程
   - <img style="width: 1300px;height:450px" src="Image\硬件多线程.png ">

### 总线

1. 系统总线
   - 系统总线是计算机系统内各功能部件（CPU、主存、l/o接口）之间相互连接的总线。按系统总线传输信息内容的不同，又可分为3类:数据总线、地址总线和控制总线。
     - **数据总线**用来传输各功能部件之间的数据信息，它是双向传输总线，其**位数**与机器字长、存储字长有关。
     - **地址总线**用来指出数据总线上的源数据或目的数据所在的主存单元或I/O端口的地址,它是单向传输总线，地址总线的**位数**与**主存地址空间**的大小有关。
     - **控制总线**传输的是控制信息，包括CPU送出的控制命令和主存（或外设）返回CPU的反馈信号。
   - <img style="width: 1300px;height:450px" src="Image\总线的性能指标.png ">
   - <img style="width: 1300px;height:450px" src="Image\总线性能指标2.png ">
   - <img style="width: 1300px;height:550px" src="Image\总线性能指标.png ">

​	

### 输入输出系统

#### IO接口

1. IO接口的作用
   - ·数据缓冲:通过数据缓冲寄存器（DBR）达到主机和外设工作速度的匹配
   - 错误或状态监测:通过状态寄存器反馈设备的各种错误、状态信息，供CPU
   - 查用控制和定时:接收从控制总线发来的控制信号、时钟信号
   - 数据格式转换:串-并、并-串等格式转换
   - 主机和设备通信:实现主机一I/O接口—I/O设备之间的通信
   - <img style="width: 1300px;height:500px" src="Image\IO接口.png ">
   - <img style="width: 1300px;height:400px" src="Image\IO设备.png ">
2. IO端口及其编址
   - <img style="width: 1300px;height:400px" src="Image\IO端口及其编址.png ">
   - **统一编址**
     - 把l/O端口当做存储器的单元进行地址分配，用统一的访存指令就可以访问I/O端口，又称存储器映射方式。靠不同的地址码区分内存和I/O设备，I/O地址要求相对固定在地址的某部分。
     - 优点:
       - 不需要专门的输入/输出指令，所有访存指令都可直接访问端口,程序设计灵活性高
       - 端口有较大的编址空间
       - 读写控制逻辑电路简单
     - 缺点:
       - 端口占用了主存地址空间，使主存地址空间变小外设寻址时间长(地址位数多，地址译码速度慢)
   - **独立编址**
     - I/O端口地址与存储器地址无关，独立编址CPU需要设置专门的输入/输出指令访问端口，又称I/O映射方式。靠不同的指令区分内存和I/O设备。
     - 优点:
       - 使用专用I/O指令，程序编制清晰I/O端口地址位数少，地址译码速度快I/O端口的地址不占用主存地址空间
     - 缺点:
       - I/O指令类型少，一般只能对端口进行传送操作，程序设计灵活性差
       - 需要CPU提供存储器读/写、I/O设备读/写两组控制信号，增加了控制逻辑电路的复杂性
3. IO接口类型
   - 按**数据传送方式**可分为
     - 并行接口:一个字节或一个字所有位同时传送。
     - 串行接口:一位一位地传送。
   - 按**主机访问I/O设备的控制方式**可分为
     - 程序查询接口
     - 中断接口
     - DMA接口
   - 按**功能选择的灵活性**可分为
     - 可编程接口
     - 不可编程接口



#### 中断

1. 中断的作用和原理
   1. 中断的基本概念
      - <img style="width: 1300px;height:400px" src="Image\中断的基本概念.png ">
      - <img style="width: 1300px;height:200px" src="Image\中断信号.png ">
      - <img style="width: 1300px;height:500px" src="Image\中断判优.png ">
   2. 中断处理过程
      - <img style="width: 1300px;height:400px" src="Image\中断处理过程.png ">
      - <img style="width: 1300px;height:500px" src="Image\硬件向量法.png ">
      - **中断服务程序**的主要任务:
        - **保护现场**保存通用寄存器和状态寄存器的内容（eg:保存ACC寄存器的值），以便返回原程序后可以恢复CPU环境。可使用堆栈，也可以使用特定存储单元。
        - **中断服务**(设备服务)：主体部分，如通过程序控制需打印的字符代码送入打印机的缓冲存储器中(eg:中断服务的过程中有可能修改Acc寄存器的值)
        - **恢复现场**通过出栈指令或取数指令把之前保存的信息送回寄存器中(eg:把原程序算到一般的Acc值恢复原样)
        - **中断返回**通过中断返回指令回到原程序断点处。
   3. 多重中断
      - 中断屏蔽技术主要用于多重中断，CPU要具备多重中断的功能，须满足下列条件。
        - 在中断服务程序中提前设置开中断指令。
        - 优先级别高的中断源有权**中断优先级**别低的中断源。
      - 每个**中断源**都有**一个屏蔽触发器**，1表示屏蔽该中断源的请求，0表示可以正常申请，所有屏蔽触发器组合在一起，便构成一个**屏蔽字寄存器**，屏蔽字寄存器的内容称为**屏蔽字**。
      - 屏蔽字设置的规律:
        - 一般用1'表示屏蔽，'0表示正常申请。
        - **每个中断源对应一个屏蔽字**(在处理该中断源的中断服务程序时，屏蔽寄存器中的内容为该中断源对应的屏蔽字)。
        - 屏蔽字中1'越多、优先级越高。每个屏蔽字中至少有一个1(**至少要能屏蔽自身的中断**)。
      - <img style="width: 1300px;height:500px" src="Image\多重中断.png ">
      - <img style="width: 700px;height:400px" src="Image\多重中断优先级.png ">
      - <img style="width: 1200px;height:400px" src="Image\中断屏蔽技术.png ">

#### IO设备控制方式

1. 程序查询方式

   - <img style="width: 1300px;height:100px" src="Image\程序查询方式1.png ">
     - CPU一旦启动I/O，必须停止现行程序的运行，并在现行程序中插入一段程序。主要特点:CPU有“踏步”等待现象，CPU与I/O串行工作。
     - 优点:接口设计简单、设备量少。
     - 缺点:CPU在信息传送过程中要花费很多时间用于查询和等待，而且如果采用独占查询,则在一段时间内只能和一台外设交换信息，效率大大降低。
     - ==**独占查询**==:CPU 100%的时间都在查询I/O状态，完全串行
     - ==**定时查询**==:在保证数据不丢失的情况下，每隔一段时间CPU就查询一次I/O状态。查询的间隔内CPU可以执行其他程序
   - <img style="width: 1300px;height:500px" src="Image\程序查询方式.png ">
   - <img style="width: 1300px;height:500px" src="Image\程序查询方式例题.png ">

2. 中断控制方式

   <img style="width: 1300px;height:500px" src="Image\中断控制方式.png ">

3. DMA方式

   - <img style="width: 1300px;height:500px" src="Image\DMA方式.png ">
   - <img style="width: 1300px;height:500px" src="Image\DMA冲突.png ">
   - <img style="width: 1300px;height:500px" src="Image\DMA数据连接.png ">
   - <img style="width: 700px;height:400px" src="Image\DMA与中断方式对比.png ">

   

