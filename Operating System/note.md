### 计算机系统概述

#### 操作系统的运行环境

1. 内核态用户态的切换
   - **内核态→用户态**:执行一条**特权指令**――**修改PSW的标志位为“用户态”**，这个动作意味着操作系统将主动让出CPU使用权
   - **用户态→内核态**:由“**中断**”引发，**硬件自动完成变态过程**，触发中断信号意味着操作系统将强行夺回CPU的使用权
2. 虚拟机
   - <img style="width: 1300px;height:450px" src="image\虚拟机.png ">

### 进程与线程

#### 进程的概念

1. 程序:是静态的，就是个存放在**磁盘里的可执行文件**，就是一系列的指令集合。
2. 进程(Process) :是动态的，是程序的一次执行过程。
   - 同一个程序多次执行会对应多个进程
   - 当**进程被创建**时,操作系统会为该进程分配一个唯一的、不从复的“身份证号”-— PID （Process ID，**进程ID**)
   - <img style="width: 1300px;height:400px" src="image\进程的PCB.png ">
   - <img style="width: 1300px;height:400px" src="image\进程的程序段数据段.png ">
   - 一个==**进程实体**（**进程映像**）==由PCB、程序段、数据段组成。
     - **进程是动态的**，**进程实体**（进程映像）是静态的。
     - 进程实体反应了进程在某一时刻的状态（如:x++后，x=2)
3. **进程的特征**
   - 动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的
     - 动态性是进程==**最基本的特征**==
   - 并发性：内存中有多个进程实体，各进程可并发执行
   - 独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位
   - 异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供"进程同步机制"来解决异步问题
     - 异步性会导致并发程序执行结果的不确定性。具体会在“进程同步”相关小节进行学习
   - 结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成

#### 进程的状态与转换

1. <img style="width: 1300px;height:400px" src="image\进程的状态与切换.png ">
2. <img style="width: 1300px;height:400px" src="image\进程的状态.png ">
3. <img style="width: 1300px;height:400px" src="image\进程的索引.png ">**链式方式**
4. <img style="width: 1300px;height:400px" src="image\索引方式.png ">**索引方式**

#### 进程控制

1. 进程控制相关的**==原语==**
   - **进程的创建**
     - <img style="width: 1100px;height:300px" src="image\进程的创建.png ">
   - **进程的终止**
     - <img style="width: 1100px;height:350px" src="image\进程的终止.png ">
   - **进程的阻塞和唤醒**
     - <img style="width: 1300px;height:350px" src="image\进程的阻塞和唤醒.png ">
   - **进程的切换**
     - <img style="width: 700px;height:350px" src="image\进程的切换.png ">

#### 进程通信

1. 进程是分配系统资源的单位（包括内存地址空间)，因此各进程拥有的内存地址空间相互独立。
   - 为了保证安全，一个进程不能直接访问另一个进程的地址空间。
2. **共享存储**
   - **基于==数据结构的共享==**:比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一钟**低级通信**方式
     - 操作系统在内存的划分出来的
   - **基于==存储区的共享==**:操作系统在**内存中划出一块共享存储区**，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种**==高级通信==**方式。
   - 为避免出错，**各个进程对共享空间的访问应该是互斥的**。
   - 注:通过“增加页表项/段表项”即可将同一片共享内存区映射到各个进程的地址空间中（第三章内容)
3. 消息传递
   - <img style="width: 1300px;height:220px" src="image\消息传递.png ">
   - <img style="width: 1300px;height:450px" src="image\直接通信方式.png ">
   - <img style="width: 1300px;height:450px" src="image\间接通信.png ">
4. 管道通信
   - <img style="width: 1300px;height:550px" src="image\管道通信.png ">
   - 写进程往管道写数据，即便管道没被写满，只要管道没空，读进程就可以从管道读数据
   - 读进程从管道读数据，即便管道没被读空，只要管道没满，写进程就可以往管道写数据
5. 信号：**实现进程间通信**
   - **用于通知进程某个特定事件已经发生**。进程收到一个信号后，对该信号进行处理。
   - <img style="width: 1300px;height:550px" src="image\信号的发送与保存.png ">**信号的发送与保存**
   - <img style="width: 1300px;height:450px" src="image\信号的处理.png ">**信号的处理**
   - <img style="width: 1300px;height:450px" src="image\信号处理.png ">
6. **信号**与**异常**的区别
   - “信号”可以作为“异常”的配套机制，让**进程对操作系统的异常处理进行补充**。在进程运行过程中，某些特殊事件可能引发“异常”，操作系统内核负责捕获并处理异常，有些异常可以由内核完成全部处理（如:缺页异常），此时就不必再使用信号机制。
     - **有些异常无法由内核完成全部处理，可能还需要用户进程配合**，此时就可以用“信号机制”与“异常机制”相互配合（如:在Linux中，发生除以0异常时，内核的异常处理程序会向用户进程发送SIGFPE信号。SIGFPE信号的默认处理程序会将进程终止并转储内存;当然进程可以自定义SIGFPE信号处理程序。
     - 假如:你开发了一个计算器应用，每当用户输入除以0，你的应用就闪退崩溃。这种体验如何?
     - 解决方法:你可以自定义SIGFPE信号处理程序，按照实际需求去决定如何处理
   - **有些信号既不能被用户自定义处理函数，也不能被阻塞**。如:Linux的SIGKILL、SIGSTOP信号

#### 线程

1. 概念与特点
   - **线程**是一个**基本的CPU执行单元**，也是**程序执行流的最小单位**。**引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发**，从而进一步提升了系统的并发度，使得**一个==进程内==也可以==并发处理各种任务==**（如QQ视频、文字聊天、传文件)
     **引入线程后**，**进程只作为除CPU之外的系统资源的分配单元**（如打印机、内存地址空间等都是分配给进程的）。
     - 资源分配、调度
       - **传统**进程机制中，进程是资源分配、调度的基本单位
       - **引入==线程后==**，进程是资源分配的基本单位，线程是调度的基本单位
     - 并发性
       - 传统进程机制中，只能进程间并发 
       - 引入线程后，各线程间也能并发，提升了并发度
     - 系统开销 
       -  传统的进程间并发，需要切换进程的运行环境，系统开销很大 
       -  线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小
       -  引入线程后，并发所带来的系统开销减小
     - 线程的属性
       - ==**线程是处理机调度的单位**==
       - 多CPU计算机中，各个线程可占用不同的CPU
       - 每个线程都有一个**线程ID**、**线程控制块**（TCB)
       - 线程也有**就绪、阻塞、运行**三种基本状态
       - 线程几乎不拥有系统资源
       - 同一进程的不同线程间共享进程的资源
       - 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
       - 同一进程中的线程切换，不会引起进程切换
       - 不同进程中的线程切换，会引起进程切换
       - 切换同进程内的线程，系统开销很小
       - 切换进程，系统开销较大
2. 实现方式
   - <img style="width: 1300px;height:400px" src="image\用户级线程.png ">
     - 用户级线程由**应用程序通过线程库实现**，所有的**线程管理工作都由应用程序负责**（包括线程切换)
     - 用户级线程中，**线程切换可以在用户态下即可完成**，无需操作系统干预。
     - 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“用户级线程”就是“从用户视角看能看到的线程”
     - 优缺点
       - 优点:用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
       - 缺点:当一个**用户级线程被阻塞后，整个进程都会被阻塞**，并发度不高。多个线程不可在多核处理机上并行运行。
   - <img style="width: 1300px;height:400px" src="image\内核级线程.png ">
3. 多线程模型
   - <img style="width: 1300px;height:400px" src="image\一对一模型.png ">
   - <img style="width: 1300px;height:400px" src="image\多对一模型.png ">
   - <img style="width: 1300px;height:500px" src="image\多对多模型.png ">
4. 线程的状态与切换
   - <img style="width: 500px;height:300px" src="image\线程的切换.png ">
   - <img style="width: 1500px;height:400px" src="image\进程的转换.png ">
   - **与进程使用类似的方式控制和调度**

#### 调度

1. 调度的三个层次
   - <img style="width: 1500px;height:400px" src="image\高级调度.png ">
   - <img style="width: 1500px;height:400px" src="image\低级调度.png ">
   - <img style="width: 1500px;height:400px" src="image\中级调度.png ">
   - <img style="width: 700px;height:300px" src="image\三成调度对比.png ">
2. 调度的七状态模型
   - <img style="width: 1500px;height:400px" src="image\调度的七状态模型.png ">
3. 进程调度
   - <img style="width: 1500px;height:400px" src="image\进程调度.png ">
   - <img style="width: 1500px;height:400px" src="image\临界区临界资源.png ">
   - 非剥夺调度方式，
     - **又称非抢占方式**。即，**只允许进程主动放弃处理机**。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。
       - 实现简单,系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统
   - 剥夺调度方式，
     - **又称抢占方式**。当一个进程正在处理机上执行时，如果**有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程**。
       - 可以优先处理更紧急的进程,也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统
     - “**狭义的进程调度**”与“进程切换”的区别
       - 狭义的进程调度指的是从就绪队列中选中一个要运行的进程。(**这个进程可以是刚刚被暂停执行的进程**，**也可能是另一个进程，后一种情况就需要进程切换**)
       - 进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。
       - **广义的进程调度**包含了**选择一个进程和进程切换**两个步骤。
     - 进程切换的过程主要完成了:
       - 原来运行进程各种数据的保存
       - 对新的进程各种数据的恢复
         - (如:程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般==**保存在进程控制块**==
4. 调度器
   - <img style="width: 1500px;height:400px" src="image\调度器.png ">
   - 不支持内核级线程的操作系统，调度程序的处理对象是进程
   - **支持内核级线程**的操作系统，**调度程序的处理对象是内核线程**
   - ==闲逛程序==
     - 没有其他就绪进程时，运行闲逛进程( idle)
     - 闲逛进程的特性:优先级最低，可以是0地址指令，占一个完整的指令周期（指令周期末尾例行检查中断)，能耗低。

#### 调度算法

1. 调度算法的评价指标
   - ==**CPU利用率**== $ = \frac{T_{\text{busy}}}{T_{\text{total}}}$
   - ==**系统吞吐量**==：单位时间内完成作业的数量
     - 系统吞吐量 $ = \frac{总共完成了多少道作业}{总共花了多少时间}$
   - ==**周转时间**==，是指从**作业被提交给系统开始，到作业完成为止的这段时间间隔**。
     - 作业在外存后备队列上**等待作业调度**〈高级调度）的时间
     - 进程在就绪队列上**等待进程调度**（低级调度）的时间
     - 进程在CPU上**执行**的时间
     - 进程**等待I/O操作**完成的时间。
     - **后三项在一个作业的整个处理过程中，==可能发生多次==。**
     - $T_{\text{turnaround}} = T_{\text{completion}} - T_{\text{submission}}$
     - **平均周转时间** $T = \frac{各作业周转时间之和}{作业数}$
     - **带权周转时间$T = \frac{作业周转时间}{作业实际运行时间}$**
     - **平均带权周转时间$T = \frac{各作业带权周转时间之和}{作业数}$**
   - <img style="width: 1500px;height:200px" src="image\等待时间.png ">
     - 对于**进程**来说，==**等待时间**==就是指**进程建立后**等待被服务的时间之和，在等待I/O**完成**的**期间**其实**进程也是在被服务的**，所以不计入等待时间。
       对于**作业**来说，不仅要**考虑建立进程后的等待时间**，**还要加上作业在外存后备队列中等待**的时间。
     - **平均等待时间**：
   - ==**响应时间**==：指从用户**提交请求**到**首次产生响应**所用的时间。

2. 先来先服务(FCFS, First Come First Serve)

   - 算法思想
     - 主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子)
   - 算法规则
     - 按照作业/进程到达的先后顺序进行服务
   - 用于**作业/进程**调度
     - 用于**作业调度时**，考虑的是哪个作业先到达后备队列;用于进程调度时，考虑的是哪个进程先到达就绪队列
   - 是否可抢占?
     - 非抢占式的算法
   - 优缺点
     - 优点:公平、算法实现简单
     - 缺点:排在长作业(进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对短作业不利（Eg :排队买奶茶...)
   - 是否会导致**饥饿**（**某进程/作业长期得不到服务**）
     - 不会
   - <img style="width: 1500px;height:450px" src="image\先来先服务算法.png ">

3. 短作业优先（SJF，Shortest Job First）

   - <img style="width: 1500px;height:450px" src="image\非抢占式段作业优先算法.png ">
   - ==**抢占式**==的短作业优先算法
     - <img style="width: 1500px;height:450px" src="image\抢占式短作业优先算法.png ">
   - 算法思想
     - 追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间
   - 算法规则
     - 最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短)
   - 用于**作业/进程**调度
     - **即可用于作业调度，也可用于进程调度**。用于进程调度时称为“短进程优先（( SPF, Shortest Process First）算法”
   - 是否可抢占?
     - 非抢占式的算法
   - 优缺点
     - 优点:“最短的”平均等待时间、平均用转时间
     - 缺点:不公平。对短作业有利，对长作业不利。==**可能产生饥饿现象**==。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先
   - 是否会导致**饥饿**（**某进程/作业长期得不到服务**）
     - 会
   - 注意几个==**小细节**==:
     - 如果题目中未特别说明，所提到的“短作业/进程优先算法”**默认是非抢占式的**
     - 很多书上都会说“SJF调度算法的平均等待时间、平均周转时间最少”
       - 严格来说，这个表述是错误的，不严谨的。之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少
       - 应该加上一个条件“在所**有进程同时可运行时**，采用SJF调度算法的平均等待时间、平均周转时间最少”;
       - 或者说“**在所有进程都几乎同时到达时**，采用SIF调度算法的平均等待时间、平均周转时间最少”;
         - 所有进程同时可运行：进程都在就绪队列中等待分配处理器
     - 如果**不加上述前提条件**，则应该说“**抢占式的短作业/进程优先调度算法**（最短剩余时间优先, SRNT算法）的平均等待时间、平均周转时间最少”
       - 虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如 FCFS)，SJF依然可以获得较少的平均等待时间、平均周转时间
       - **如果选择题中遇到“SJF算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误**，如果没有更合适的选项，那也应该选择该选项

4. ==**高响应比优先**==（HRRN）

   - <img style="width: 1500px;height:450px" src="image\高响应比优先.png ">
   - <img style="width: 1500px;height:450px" src="image\高响应比优先2.png ">

5. 区别

   - <img style="width: 1500px;height:350px" src="image\区别与特点.png ">
   - 注:这几种算法**主要关心对用户的公平性**、**平均周转时间**、**平均等待时间等评价系统整体性能的指标**，但是**==不关心==“响应时间”，也并不区分任务的紧急程度**，因此对于用户来说，交互性很糟糕。**因此这三种算法一般适合用于早期的批处理系统**，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。而适合用于交互式系统的调度算法将在下个小节介绍

6. 时间片轮转==（**RR**）==

   - 算法思想
     - 公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应
   - ==**算法规则**==
     - 按照各进程到达就绪队列的顺序，**轮流让各个进程执行一个时间片**（如100ms)。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。
   - 用于**作业/进程**调度
     - 用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)
   - 是否可抢占?
     - 若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到
   - 优缺点
     - 优点:公平;响应快，适用于分时操作系统;
     - 缺点:由于高频率的进程切换，因此有一定开销;不区分任务的紧急程度。
     - **太大或太小分别有什么影响?**
   - 是否会导致**饥饿**
     - 不会

7. **优先级调度算法**

   - 算法思想
     - 随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序
   - ==**算法规则**==
     - 调度时选择优先级最高的作业/进程
   - 用于**作业/进程**调度
     - 既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I/O调度中
   - 是否可抢占?
     - ==**抢占式、非抢占式都有**==。做题时的区别在于:**非抢占式只需在进程主动放弃处理机时进行调度即可**，**而抢占式还需在就绪队列变化时，检查是否会发生抢占。**
   - 优缺点
     - 优点:用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。
     - 缺点:若源源不断地有高优先级进程到来，则可能导致饥饿
   - 是否会导致**饥饿**
     - 会
   - <img style="width: 1500px;height:400px" src="image\优先级调度算法.png ">
   - <img style="width: 1500px;height:400px" src="image\优先级调度算法补充.png ">

8. **==多级反馈队列调度算法==**

   - <img style="width: 1500px;height:400px" src="image\多级反馈队列调度算法.png ">
   - <img style="width: 1500px;height:400px" src="image\多级反馈队列调度算法1.png ">

9. 差异

   - <img style="width: 1500px;height:300px" src="image\调度算法差异.png ">
   - **==适用于交互式系统==**

10. 多级队列调度算法

    - <img style="width: 500px;height:250px" src="image\多级队列调度算法.png ">
    - 系统中按**进程类型**设置**多个队列**，**进程创建成功后插入某个队列**
    - 队列之间可采取**固定优先级**，或**时间片划分**
      - 固定优先级:高优先级空时低优先级进程才能被调度
      - 时间片划分:如三个队列分配时间50%、40%、10%
    - **各队列可采用不同的调度策略**，如:
      - 系统进程队列采用优先级调度
      - 交互式队列采用RR
      - 批处理队列采用FCFS

11. 多处理机调度

    - ![img](file:///D:/Project/VSCode/Operating%20System/image/%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6.png?lastModify=1754146213)
    - <img style="width: 1500px;height:400px" src="image\公共就绪队列.png ">
    - <img style="width: 1500px;height:400px" src="image\私有就绪队列.png ">
      - 负载均衡
        - **推迁移(Push）策略**:**一个特定的系统程序==周期性==检查==每个==处理器的负载**，如果负载不平衡，就从忙碌CPU的就绪队列中“推”一些就绪进程到空闲CPU的就绪队列。推迁移=有一个包工头专门负责派活
        - **拉迁移( pull）策略**:**每个CPU运行调度程序时，==周期性==检查==自身负载与其他CPU负载==**。如果一个CPU负载很低，就从其他高负载CPU的就绪队列中“拉”一些就绪进程到自己的就绪队列
      - **私有就绪队列天然地实现了“处理机亲和性”**。

#### 同步与互斥

1. 同步

   - <img style="width: 1500px;height:400px" src="image\同步.png ">

2. 互斥

   - 我们把**一个时间段内只允许一个进程使用**的资源称为**临界资源**。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。
   - 对临界资源的访问，必须**互斥**地进行。互斥，亦称**间接制约关系**。**进程互斥**指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。
   - <img style="width: 700px;height:300px" src="image\临界资源的访问.png ">
   - 为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则:
     - **空闲让进**。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区;
     - **忙则等待**。当已有进程进入临界区时，其他试图进入临界区的进程必须等待;
     - **有限等待**。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）;
     - **让权等待**。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。

3. 进程互斥的==**软件实现**==方法

   - 单标志法
     - <img style="width: 800px;height:400px" src="image\单标志法.png ">
     - 个进程**轮流的使用互斥资源**，不遵循“空闲让进”原则。
   - 双标志先检查法
     - <img style="width: 900px;height:500px" src="image\双标准先检查法.png ">
   - 双标志后检查法
     - <img style="width: 900px;height:500px" src="image\双标志后检查法.png ">
   - Peterson算法
     - <img style="width: 900px;height:500px" src="image\皮特森算法.png ">

4. 进程互斥的==**硬件实现**==方法

   - 中断屏蔽方法
     - 利用“**开/关中断指令**”实现（与原语的实现思想相同，即在**某进程开始访问临界区到结束访问为止都不允许被中断**，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况)
     - 优点:简单、高效
     - 缺点:**不适用于==多处理机==**;只适用于操作系统内核进程，**不适用于用户进程**（因为==**开/关中断指令只能运行在内核态**==，这组指令如果能让用户随意使用会很危险）
   - TestAndSet指令
     - <img style="width: 900px;height:500px" src="image\TSL指令.png ">
   - Swap指令
     - <img style="width: 900px;height:500px" src="image\XCHG指令.png ">

5. 互斥锁

   - 解决临界区最简单的工具就是**互斥锁**( mutex lock)。一个进程在进入临界区时应获得锁;在退出临界区时释放锁。函数acquire()获得锁，而函数release()释放锁。

   - 每个互斥锁有一个布尔变量 available，表示锁是否可用。如果锁是可用的，调用acqiure()会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。

     - ```c++
       acquire()
       {	
           while(!available)
               ;				//忙等待
           available = false;	//获得锁
       }
       release ()
       {
       	available = true;	//释放锁
       }
       ```

   - acquire()或release()的执行**必须是原子操作**，因此==**互斥锁通常采用硬件机制来实现**==。互斥锁的主要**缺点是忙等待**，当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用acquire()。当多个进程共享同一CPU时，就浪费了CPU周期。因此，互斥锁通常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行

   - **需要==连续循环忙等==的互斥锁**，都可称为**自旋锁**(spin lock)，如TSL指令、swap指令、单标志法

   - <img style="width: 900px;height:500px" src="image\互斥锁特性.png ">

#### 信号量

1. 信号量机制

   - 用户进程可以通过使用操作系统提供的**一对==原语==**来对**==信号量进行操作==**，从而很方便的==**实现了进程互斥、进程同步**==。
   - **信号量**其实就是一个变量（**可以是一个==整数==**，**也可以是更复杂的==记录型变量==**)，可以用一个信号量来表示系统中某种资源的数量，
     - 比如:系统中只有一台打印机，就可以设置一个初值为1的信号量
   - 原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。
   - **一对原语**: wait(S)原语和signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号里的**信号量S**其实就是**函数调用时传入的一个参数**。
   - wait、signal原语常简称为==**P、V操作**==（来自荷兰语proberen和verhogen)。因此，做题的时候常把wait(S)、signal(S)两个操作分别写为P(S)、v(S)
   - <img style="width: 900px;height:500px" src="image\整形信号量.png ">
   - <img style="width: 900px;height:500px" src="image\记录型信号量.png ">
2. 进程互斥

   - <img style="width: 900px;height:500px" src="image\进程互斥.png ">
3. 进程同步

   - <img style="width: 900px;height:400px" src="image\进程同步.png ">
   - <img style="width: 900px;height:500px" src="image\进程同步2.png ">
   - 生产者-消费者

     - <img style="width: 900px;height:500px" src="image\生产者消费者.png ">

     - ==**实现互斥的P操作一定要在实现同步的P操作之后**==。**V操作不会导致进程阻塞，因此两个V操作顺序可以交换。**
   - 多生产者-多消费者
   
     - <img style="width: 900px;height:400px" src="image\多生产者多消费者.png ">
     - 原因在于:本题中的缓冲区大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此在任何时刻,最多只有一个进程的P操作不会被阻塞,并顺利地进入临界区。
   - 读者写者
   
     - <img style="width: 900px;height:400px" src="image\读者写者.png ">
   - 哲学家就餐
   
     - <img style="width: 900px;height:400px" src="image\哲学家就餐.png ">
     - 可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。
     - 要求奇数号哲学家先拿左边的筷子,然后再拿右边的筷子,而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭,那么只会有其中一个可以拿起第一只筷子,另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。
     - 仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。
4. 管程

   - 定义
     - 管程是一种特殊的**软件模块**，有这些部分组成:局部于管程的**共享数据结构**说明，对该数据结构进行操作的**一组过程**，对**局部于管程的共享数据设置初始值的语句**，管程有一个名字。
   - 特征:
     - **局部于管程的数据只能被局部于管程的过程所访问;**
     - 一个进程只有**通过调用管程内的过程**才能进入管程访问共享数据;
     - 每次仅允许一个进程在管程内执行某个内部过程。
     - 引入管程的目的无非就是要更方便地实现进程==**互斥和同步。**==
       - 需要在管程中定义共享数据（如生产者消费者问题的缓冲区)
       - 需要在管程中定义用于访问这些共享数据的“入口”，其实就是一些函数（如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品）只有**通过这些特定的“入口”才能访问共享数据**
       - 管程中有很多“入口”，但是**每次只能开放其中一个“入口”，并且只能让一个进程或线程进入**（如生产者消费者问题中，各
       - 进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。==**注意:这种互斥特性是由编译器负责实现的，程序员不用关心)**==
       - 可在管程中**设置条件变量及等待/唤醒操作以解决同步问题**。可以让一个进程或线程在条件变量上等待（**此时，该进程应先释放管程的使用权，也就是让出“入口”)**;可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。
     - <img style="width: 1000px;height:500px" src="image\管程生产者消费者.png ">

#### 死锁

1. 概念
   - 死锁：死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那**至少有两个或两个以上的进程同时发生死锁**。另外，发生死锁的进程一定处于阻塞态。
   - 饥饿：**可能只有一个进程发生饥饿**。发生饥饿的进程既可能是阻塞态(如长期得不到需要的I/O设备)，也可能是就绪态(长期得不到处理机)
   - 死循环：**可能只有一个进程发生死循环。**死循环的进程可以上处理机运行（可以是运行态），只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。**死锁和饥饿是管理者（操作系统）的问题，死循环是被管理者的问题。**
     - 共同点：都是进程无法顺利向前推进的现象(故意设计的死循环除外)
2. 死锁产生的条件
   - 产生死锁**必须同时满足一下==四个条件==**，只要其中任一条件不成立，死锁就不会发生。
   - **互斥条件**:只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。
   - **不剥夺条件**:进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。
   - **请求和保持条件**:进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞,但又对自己已有的资源保持不放。
   - **循环等待条件**:存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。
   - ==**发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件)**==
   - ==**总之，对不可剥夺资源的不合理分配，可能导致死锁。**==
3. 死锁处理
   - **不允许死锁发生**
     - ==**静态**==策略：**预防死锁**
       - 破坏互斥条件
       - 破坏不剥夺条件
       - 破坏请求和保持条件
       - 破坏循环等待条件
     - ==**动态**==策略：避免死锁
   - 允许死锁发生
     - 死锁的检测和解除
   - **破坏互斥条件**
     - <img style="width: 1000px;height:500px" src="image\破坏互斥条件.png ">
   - **破坏不剥夺条件**
     - **不剥夺条件**:进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。
     - 破坏不剥夺条件:
       - 方案一:当某个进程**请求新的资源得不到满足时**，它**必须立即释放保持的所有资源**，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。
       - 方案二:当某个进程**需要的资源被其他进程所占有的时候**，可以**由操作系统协助，将想要的资源强行剥夺**。这种方式一般需要考虑各进程的优先级（比如:剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用)
       - 该策略的缺点:
         - 实现起来比较复杂。
         - 释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。
         - 反复地申请和释放资源会增加系统开销，降低系统吞吐量。
         - 若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。
   - **破坏请求和保持条件**
     - **请求和保持条件**:进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。
     - 可以采用静态分配方法，即**进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行**。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。
     - 该策略实现起来简单，但也有明显的缺点:
       - 有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。
   - **破坏循环等待条件**
     - <img style="width: 1000px;height:400px" src="image\破坏循环等待条件.png ">
   - ==**避免死锁**==
     - 所谓**安全序列**，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是**安全状态**。当然，**安全序列可能有多个**。
     - 如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了**不安全状态**。这就意味着之后**可能**所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，**那系统也有可能重新回到安全状态**，不过我们在分配资源之前总是要考虑到最坏的情况。
     - 如果系统处于==**安全状态，就一定不会发生死锁**==。如果系统进入==**不安全状态**，就**可能发生死锁**（==处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态)
     - 因此可以在**资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求**。这也是“银行家算法”的核心思想。
     - 银行家算法
       - <img style="width: 1000px;height:400px" src="image\银行家算法.png ">
       - <img style="width: 1000px;height:400px" src="image\银行家算法2.png ">
       - <img style="width: 1000px;height:400px" src="image\银行家算法3.png ">
       - 数据结构:
         - 长度为m的一维数组Available表示还有多少可用资源
         - `n*m`矩阵Max表示各进程对资源的最大需求数
         - `n*m`矩阵Allocation表示已经给各进程分配了多少资源
         - Max-Allocation = Need矩阵表示各进程最多还需要多少资源
         - 用长度为m的一位数组Request表示进程此次申请的各种资源数
       - 银行家算法步骤:
         - 检查此次申请是否超过了之前声明的最大需求数
         - 检查此时系统剩余的可用资源是否还能满足这次请求
         - 试探着分配，更改各数据结构
         - 用安全性算法检查此次分配是否会导致系统进入不安全状态
       - 安全性算法步骤:
         - 检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。
         - 不断重复上述过程，看最终是否能让所有进程都加入安全序列。
   -  检测和解除
     - <img style="width: 1000px;height:400px" src="image\死锁检测1.png ">
     - <img style="width: 1000px;height:400px" src="image\死锁的检测2.png ">
     - <img style="width: 1000px;height:500px" src="image\死锁的解除.png ">

### 内存管理

#### 基础知识

1. 装入的三种方式
   - 绝对装入
     - <img style="width: 1000px;height:500px" src="image\绝对装入.png ">
   - 静态重定位
     - <img style="width: 1000px;height:500px" src="image\静态重定位.png ">
   - 动态重定位
     - <img style="width: 1000px;height:500px" src="image\动态重定位.png ">
2. 链接的三种方式
   - <img style="width: 1000px;height:400px" src="image\链接.png ">
3. 内存管理概念
   - 内存的分配与回收
   - 内存空间的扩充（实现虚拟性）
   - 地址转换
     - 操作系统负责实现逻辑地址到物理地址的转换
     - 实现方式为：绝对装入，静态重定位，动态重定位
   - 存储保护
     - <img style="width: 1000px;height:400px" src="image\内存保护.png ">
     - <img style="width: 1000px;height:400px" src="image\内存保护2.png ">
4. **进程的内存映像**
   - <img style="width: 1000px;height:400px" src="image\进程的内存映像.png ">
5. 内存空间的扩充
   - 解决程序大小超过实际内存的大小
   - ==**覆盖技术**==的思想:**将程序分为多个段**（多个模块)。常用的段常驻内存，不常用的段在需要时调入内存。
     - 内存中分为一个“**固定区**”和若干个“**覆盖区**”。
     - 需要常驻内存的段放在“固定区”中，调入后就不再调出(除非运行结束)
     - 不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存
     - <img style="width: 1000px;height:350px" src="image\覆盖技术.png ">
     - **必须由程序员声明覆盖结构**，操作系统完成自动覆盖。缺点:==**对用户不透明**==，增加了用户编程负担。
     - ==**覆盖技术只用于早期的操作系统中，现在已成为历史。**==
   - ==交换技术==
     - 交换（对换）技术的设计思想:内存空间紧张时，系统将**内存中某些==进程==暂时换出外存**，把**外存中某些已具备运行条件的进程换入内存**（进程在内存与磁盘间动态调度)
     - 暂时换出外存等待的进程状态为**挂起状态**（挂起态，suspend)
       - 挂起态又可以进一步细分为**就绪挂起**、**阻塞挂起**两种状态
     - <img style="width: 1000px;height:400px" src="image\交换技术.png ">
   - **==覆盖与交换==**的区别
     - 覆盖是在同一个程序或进程中的
     - 交换是在不同进程(或作业)之间的

#### 内存空间的分配与回收

1. ==**连续**==分配管理方式
   - **单一连续分配**
     - 在单一连续分配方式中，内存被分为**系统区**和**用户区**。系统区通常位于内存的低地址部分，用于存放操作系统相关数据;**用户区用于存放用户进程相关数据。内存中只能有一道用户程序**，用户程序独占整个用户区空间。
     
     - 优点:实现简单;**无外部碎片**;**可以采用覆盖技术扩充内存**;**不一定需要采取内存保护**（eg:早期的PC操作系统MS-DOS) 。
     
     - 缺点:只能用于单用户、单任务的操作系统中;有内部碎片;存储器利用率极低。
       - 分配给某进程的内存区域中，如果有些部分没有用上，就是“==**内部碎片**==”
     
   - **固定分区分配**
     - 20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个**用户空间划分**为若干个**固定大小的分区**，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。
       - **分区大小相等**:缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合（比如:钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序)
       - **分区大小不等**:增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分(比如:划分多个小分区、适量中等分区、少量大分区)
     - <img style="width: 1000px;height:400px" src="image\固定分区分配.png ">
   - **动态分区分配**
     - 又称为**可变分区分配**。这种分配方式**不会预先划分内存分区**，而是在进程装入内存时，**根据进程的大小动态地建立分区**，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。（eg:假设某计算机内存大小为64MB，系统区8MB，用户区共56 MB...)
     - <img style="width: 1000px;height:400px" src="image\空闲分区.png ">
     - **内存空间回收**
       - 内存空间回收后有一些空间是相邻的，则进行合并。如果前后都不相邻则新增一个表项。
     - <img style="width: 900px;height:300px" src="image\动态分区分配.png ">
   - 动态分区分配算法
     - 首次适应算法
       - 算法思想:每次都从**低地址开始查找**，找到**第一个**能满足大小的空闲分区。
       - 如何实现:空闲分区以**地址递增**的次序排列。每次**分配内存时**顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。
       - **==效果最好==**
     - 最佳适应算法
       - 算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。
       - 如何实现:空闲分区按**容量递增次序链接**。**每次分配内存时顺序查找**空闲分区链（或空闲分区表），找到**大小能满足要求的第一个空闲分区**。
       - <img style="width: 1000px;height:300px" src="image\最佳适应算法.png ">
     - 最坏适应算法（最大适应算法）
       - **算法思想**:为了解决最佳适应算法的问题――即留下太多难以利用的小碎片，可以在每次分配时**优先使用最大的连续空闲区**，这样分配后剩余的空闲区就不会太小，更方便使用。
       - **如何实现**:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。
       - **缺点**:每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。
     - 邻近适应算法
       - 算法思想:首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。
       - **如何实现**:空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时**从上次查找结束的位置开始查找空闲分区链（或空闲分区表)**，找到大小能满足要求的第一个空闲分区。
       - 优点：不用每次都从低地址的小分区开始检索**算法开销小**
       - 缺点：会使高地址的大分区也被用完
   
2. **==非连续分配管理方式==**

   - 分页存储
     - 将**内存空间分为一个个大小相等的分区**（比如:每个分区4KB），每个分区就是一个==**“页框”(页框=页帧=内存块=物理块=物理页面)**==。每个**页框**有一个==**编号**==，即“页框号”(页框号=页帧号=内存块号=物理块号=物理页号)，页框号从0开始。
     - 将**进程**的**逻辑地址空间**也**分为**与**页框大小相等**的一个个部分，每个部分称为一个“==**页**==”或“==**页面**==”。每个**页面**也有一个==**编号**==即“**页号”**，页号也是从0开始。
     - 操作系统以**页框为单位**为各个进程**分配内存空间**。进程的每个页面分别放入一个页框中。也就是说，**进程的页面与内存的页框有一一对应的关系**。
     - 各个**页面不必连续存放**，可以放到不相邻的各个页框中。
   - ==**页表**==
     - <img style="width: 1000px;height:400px" src="image\页表.png ">
     - <img style="width: 1000px;height:480px" src="image\页表大小.png ">
   - ==**地址转换**==
     - <img style="width: 1000px;height:450px" src="image\地址转换.png ">
     - <img style="width: 1000px;height:450px" src="image\地址转换2.png ">
     - <img style="width: 1000px;height:350px" src="image\逻辑地址结构.png ">
     - ==**Tips:有些奇葩题目中页面大小有可能不是2的整数次幂，这种情况还是得用最原始的方法计算。**==
   - ==**基本地址变换机构**==
     - <img style="width: 1000px;height:450px" src="image\基本地址变化机构.png ">
     - <img style="width: 1000px;height:450px" src="image\页表的存储.png ">
     - ==**页式管理中的地址是一维的**==
   - 具有块表的地址变换机构
     - <img style="width: 1000px;height:450px" src="image\具有块表的地址变换机构.png ">
     - <img style="width: 1000px;height:450px" src="image\块表访存.png ">
   
   - **==两级页表==**
   
     - **==页目录表，顶级页表，外层页表==**
     - <img style="width: 1000px;height:450px" src="image\二级页表.png ">
     - <img style="width: 1000px;height:450px" src="image\二级页表2.png ">
     - <img style="width: 1000px;height:450px" src="image\二级页表3.png ">
     - <img style="width: 1000px;height:450px" src="image\二级页表4.png ">
   
   - **==基本分段存储管理方式==**
   
      - 分段
   
         - 进程的地址空间:按照程序**自身的逻辑**关系**划分为若干个段**，每个段都有一个段名(在低级语言中，程序员使用段名来编程），**每段从0开始编址**
         - 内存分配规则:以段为单位进行分配，**每个段在内存中占据连续空间，但各段之间可以不相邻**。
         - <img style="width: 1000px;height:350px" src="image\分段.png ">
         - <img style="width: 1000px;height:100px" src="image\分段1.png ">
   
         - **段号的位数决定了每个进程最多可以分几个段，段内地址位数决定了每个段的最大长度是多少。**
   
      - 段表 
   
         - 每个段对应一个段表项，其中记录了**该段**在内存中的**起始位置**（又称“**基址**”）和段的长度。
         - **各个段表项的长度是相同的**。例如:某系统按字节寻址，采用分段存储管理，逻辑地址结构为（段号16位,段内地址16位），因此用16位即可表示最大段长。物理内存大小为4GB（**可用32位表示整个物理内存地址空间**)。因此，可以让每个段**表项占16+32= 48位**，即6B。由于段表项长度相同，因此段号可以是隐含的，不占存储空间。若段表存放的**起始地址为M**，**则K号段**对应的段表项存放的地址为M+K*6
         - <img style="width: 1000px;height:350px" src="image\段表.png ">
   
      - 地址转换
   
         - <img style="width: 1000px;height:550px" src="image\分段地址转换.png ">
         - **==可引入块表==**
   
   - 分页，分段管理的对比
   
      - **页**是**信息的物理单位**。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，**对用户是不可见的**。
      - **段**是**信息的逻辑单位**。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。**分段对用户是可见的**，用户编程时需要显式地给出段名。
      - 页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。
      - 分页的用户进程**地址空间是==一维的==**，程序员只需给出一个记忆符即可表示个地址。
      - 分段的用户进程**地址空间是==二维的==**，程序员在标识一个地址时，既要给出段名，也要给出段内地址。
      - **分段**比分页**更容易实现信息的共享和保护**。
         - 不能被修改的代码称为**纯代码**或**可重入代码**（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的
      - 访问一个逻辑地址需要几次访存?
         - 分页（单级页表)︰第一次访存――查内存中的页表，第二次访存――访问目标内存单元。总共两次访存
         - 分段:第一次访存――查内存中的段表，第二次访存――访问目标内存单元。总共两次访存与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。
      - <img style="width: 1000px;height:400px" src="image\分段共享.png ">
      - <img style="width: 1000px;height:400px" src="image\段表共享2.png ">
      
   - 段页式管理方式
   
      - <img style="width: 1000px;height:400px" src="image\段页式管理.png ">
      - <img style="width: 1000px;height:100px" src="image\段页管理.png ">
      - **段号**的位数决定了每个进程最多可以分几个段
      - **页号位数**决定了每个段最大有多少页
      - **页内偏移量**决定了页面大小、内存块大小是多少
         - 在上述例子中，若系统是按字节寻址的，则
         - 段号占16位，因此在该系统中，每个进程最多有2^16^= 64K个段
         - 页号占4位，因此每个段最多有2^4^=16页
         - 页内偏移量占12位，因此每个页面，内存块大小为2^12^= 4096=4KB
      - <img style="width: 1000px;height:500px" src="image\段页地址转换.png ">
      - <img style="width: 1000px;height:500px" src="image\段页管理地址转换.png ">

#### 虚拟内存

1. 定义与特征

   - 基于**局部性原理**，在程序装入时，可以将程序中**很快会用到的部分装入内存**，**暂时用不到的部分留在外存**，就可以让程序开始执行。

   - 在程序执行过程中，当所**访问的信息不在内存时**，由**操作系统负责将所需信息从外存调入内存**，然后继续执行程序。

   - 若**内存空间不够**，由**操作系统负责将内存中暂时用不到的信息换出到外存**。

   - 在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是**虚拟内存**

   - 虚拟内存有一下**三个主要特征**:
     - **多次**性:无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。
     - **对换**性:在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。
     - **虚拟**性:从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。
2. 虚拟内存技术的实现

   - 虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，==**虚拟内存的实现**==需要建立在**离散分配**的内存管理方式基础上。
   - 请求分页存储管理
   - 请求分段存储管理
   - 请求段页式存储管理
3. 请求分页管理方式

   - 与基本分页管理相比，请求分页管理中，为了实现“==**请求调页**”==，操作系统需要知道每个页面是否已经调入内存;如果还没调入，那么**也需要知道该页面在外存中存放的位置**。
   - 当内存空间不够时，要实现“==**页面置换**==”，操作系统需要通过某些指标来决定到底换出哪个页面;有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。
     - <img style="width: 1000px;height:250px" src="image\请求分页页表.png ">
   - **缺页中断机制**
     - <img style="width: 1000px;height:450px" src="image\缺页中断机构.png ">
     - <img style="width: 1000px;height:400px" src="image\缺页中断.png ">
   - 地址变化机构
     - 新增步骤1:请求调页(查到页表项时进行判
     - 新增步骤2:页面置换（需要调入页面，但没有空闲内存块时进行)
     - 新增步骤3:需要修改请求页表中新增的表项
     - <img style="width: 1000px;height:500px" src="image\地址变换机构.png ">
     - <img style="width: 1000px;height:500px" src="image\地址变换机构2.png ">
4. 页面置换算法
   - 最佳置换算法
     - 最佳置换算法（**OPT**，Optimal):每次选择淘汰的页面将是**以后永不使用**，或者在**最长时间内不再被访问的页面**，这样可以保证最低的缺页率。
     - 最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，==**最佳置换算法是无法实现的**==。
   - 先进先出置换算法
     - 每次淘汰的页面是最早进入内存的页面
     - ==**Belady异常**==——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象
     - 只有**FIFO**算法会产生Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差
     - <img style="width: 1000px;height:200px" src="image\先进先出置换算法.png ">
   - 最近最久未使用置换算法（LRU）
     - <img style="width: 1000px;height:500px" src="image\最近最久未使用置换算法.png ">
   - 时钟置换算法（CLOCK算法，最近未用算法NRU）
     - 简单的CLOCK算法实现方法:为**每个页面设置一个访问位**，再将内存中的页面都通过**链接指针**链接成一个**循环队列**。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若**第一轮扫描中所有页面都是1**，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此**简单的CLOCK算法**选择一个淘汰页面**最多会经过两轮扫描**)
     - <img style="width: 1000px;height:200px" src="image\时钟置换算法.png ">
   - 改进型时钟置换算法
     - 简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。**只有被淘汰的页面被修改过时，才需要写回外存**。
     - 因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。**在其他条件都相同时，应优先淘汰没有修改过的页面**，避免I/O操作。这就是改进型的时钟置换算法的思想。修改位=0，表示页面没有被修改过;修改位=1，表示页面被修改过。为方便讨论，用（访问位，修改位）的形式表示各页面状态。如(1，1）表示一个页面近期被访问过，且被修改过。
     - 算法规则:将所有可能被置换的页面排成一个循环队列
       - 第一轮:从当前位置开始扫描到第一个(0,0)的帧用于替换。本轮扫描不修改任何标志位
         - 第一优先级:最近**没访问**,且**没修改**的页面
       - 第二轮:若第一轮扫描失败，则重新扫描，查找第一个(0,1)的帧用于替换。本轮将所有扫描过的帧==**访问位设为0**==
         - 第二优先级:最近**没访问**,但**修改**过的页面
       - 第三轮:若第二轮扫描失败，则重新扫描，查找第一个(0,0)的帧用于替换。本轮扫描不修改任何标志位
         - 第三优先级:最近**访问**过,但**没修改**的页面
       - 第四轮:若第三轮扫描失败，则重新扫描，查找第一个(0,1)的帧用于替换。
         - 第四优先级:最近**访问过**,且**修改过**的页面
       - 由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择一个**淘汰页面最多会进行四轮扫描**
5. 页面分配策略
   - ==**驻留集**==:指请求分页存储管理中给进程分配的物理块的集合。
     - 在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。
     - 若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少;
     - 驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。
   - **固定分配**:操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，**驻留集大小不变**
   - **可变分配**:先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，**驻留集大小可变**
   - **局部置换**:发生缺页时**只能选进程自己的物理块**进行置换。
   - **全局置换**:可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。
   - **抖动（颠簸）现象**：页面频繁换入换出的现象。主要原因是分配给进程的物理块不够
     - 固定分配局部置换
     - 可变分配全局置换
       - 只要缺页就给分配新物理块
     - 可变分配局部置换
       - 要根据发生缺页的频率来动态地增加或减少进程的物理块
   - 何时调入页面
     - **预调页策略**
       - 根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故**这种策略主要用于进程的首次调入**，由程序员指出应该先调入哪些部分。
     - **请求调页策略**
       - 进程**在运行期间发现缺页时才将所缺页面调入内存**。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大。
   - 从何处调入内存
     - <img style="width: 1000px;height:450px" src="image\从何处调入内存.png ">
     - <img style="width: 1000px;height:350px" src="image\工作集.png ">
6. 内存映射文件
   - <img style="width: 1000px;height:350px" src="image\内存映射文件.png ">
   - <img style="width: 1000px;height:370px" src="image\内存映射文件2.png ">



### 文件管理

#### 文件系统基础

1. **文件的属性**
   - **文件名**:由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件。
   - **标识符**:**一个系统内的各文件标识符唯一**，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。
   - **类型**:指明文件的类型
   - **位置**:文件存放的路径（让用户使用）、在外存中的地址(操作系统使用，对用户不可见)
   - **大小**:指明文件大小
   - 创建时间、上次修改时间文件所有者信息
   - **保护信息**:对文件进行保护的访问控制信息
2. 文件内部数据的组织
   - <img style="width: 1000px;height:350px" src="image\文件数据的组织.png ">
3. 文件之间的组织
   - <img style="width: 1000px;height:350px" src="image\文件之间的组织.png ">
4. 操作系统向上提供的功能
   - 创建文件(create系统调用)
   - 删除文件(delete系统调用)
   - 读文件(read系统调用)
   - 写文件(write系统调用)
   - 打开文件(open系统调用)
   - 关闭文件(close系统调用)
5. 有结构文件
   - 无结构文件:文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件”。如:Windows操作系统中的.txt文件。
   - ==**有结构文件**==:由一组相似的记录组成，又称“**记录式文件**”。**每条记录**又若干个**数据项**组成。如:数据库表文件。一般来说，每条记录有一个数据项可作为**关键字**。根据各条记录的长度（占用的存储空间）是否相等，又可分为**定长记录**和**可变长记录两种**。
     - <img style="width: 1000px;height:300px" src="image\可变长记录.png ">
     - **顺序文件**
       - 文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。
       - **串结构**： 记录之间的顺序与关键字无关
         - 通常按照记录**存入的时间决定记录的顺序**
       - **顺序结构**： **记录之间的顺序按关键字顺序==排列==**
       - <img style="width: 1000px;height:400px" src="image\顺序文件.png ">
     - **索引文件**
       - <img style="width: 1000px;height:400px" src="image\索引文件.png ">
     - **索引顺序文件**
     - <img style="width: 1000px;height:300px" src="image\索引顺序文件.png ">
     - 若采用**索引顺序文件**结构，可把10000个记录分为v10000 = 100组，每组100个记录。则需要先顺序查找索引表找到分组（共100个分组，因此索引表长度为100，平均需要查50次)，找到分组后，再在分组中顺序查找记录（每个分组100个记录，因此平均需要查50次）。可见，采用索引顺序文件结构后，**平均查找次数减少为50+50= 100 次**。
     - <img style="width: 1000px;height:400px" src="image\多级索引查找.png ">



#### 目录

1. **文件控制块**FCB
- <img style="width: 1000px;height:500px" src="image\文件目录.png ">
2. 目录结构

   - **单级目录结构**
     - <img style="width: 1000px;height:400px" src="image\单级目录结构.png ">
   - **两级目录结构**
     - <img style="width: 1000px;height:500px" src="image\两级目录结构.png ">
   - **多级目录结构（树型目录结构）**
     - 用户(或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级目录之间用“/”隔开。**从根目录出发**的路径称为**绝对路径**。
       - 例如:自拍.jpg的绝对路径是“/照片/2015-083/自拍.jpg”
     - 每次都从根目录开始查找，是很低效的。因此可以设置一个“**当前目录”**。例如，此时已经打开了“照片”的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为“当前目录”。当用户想.要访问某个文件时，可以使用**从当前目录出发**的“**相对路径**”。
       - 在Linux中，“.”表示当前目录，因此如果“照片”是当前目录，则"自拍.jpg"的相对路径为:“./2015-08/自拍.jpg”。
     - **树形目录结构**可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构==**不便于实现文件的共享**==。为此，提出了“无环图目录结构”。
   - **无环图目录结构**
     - <img style="width: 1000px;height:300px" src="image\无环图目录结构.png ">
     - 可以用不同的文件名指向同一个文件，甚至可以指向同一个目录(共享同一目录下的所有内容）。
     - 需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享结点。
     - 只有共享计数器减为0时，才删除结点。
     - 注意:共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。
3. 索引节点（FCB的改进）

   - <img style="width: 1000px;height:500px" src="image\索引节点.png ">
4. 文件的物理结构（文件的分配方式）

   - 文件块，磁盘块
     - <img style="width: 1000px;height:500px" src="image\文件块.png ">
   - 连续分配
     - <img style="width: 1000px;height:400px" src="image\连续分配.png ">
     - 优点:支持顺序访问和直接访问（即随机访问)﹔连续分配的文件在顺序访问时速度最快
     - 缺点:不方便文件拓展;存储空间利用率低，会产生磁盘碎片
   - 链接分配
     - **隐士链接**（==默认==）
       - 除文件的最后一个盘块之外，每个盘块中都存有**指回下一个块的指针**。**文件目录包括文件第一块的指针和最后一块的指针**。
       - 优点:很方便文件拓展，不会有碎片问题，外存利用率高。
       - 缺点:只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。
       - <img style="width: 1000px;height:400px" src="image\隐士链接.png ">
     - 显士连接
       - <img style="width: 1000px;height:400px" src="image\显士链接.png ">
       - 优点:很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。
       - 缺点:文件分配表的需要占用一定的存储空间。
   - 索引分配
     - 索引分配允许文件**离散地**分配在各个磁盘块中，系统会为**每个文件**建立**一张==索引表==**，索引表中**记录了文件的各个==逻辑块对应的物理块==**。索引表存放的磁盘块称为==**索引块**==。文件数据存放的磁盘块称为==**数据块**==。
     - 注:**在显式链接的链式分配方式中，==文件分配表FAT==是一个磁盘对应一张。而索引分配方式中，索引表是一个文件对应一张。**
     - 可以用固定的长度表示物理块号（如:假设磁盘总容量为1TB=2^40^B，磁盘块大小为1KB，则共有2^30^个磁盘块，则可用4B表示磁盘块号），因此，索引表中的“**逻辑块号**”**可以是隐含的**。
     - <img style="width: 1000px;height:300px" src="image\索引分配.png ">
       - ==**链接方案**==：如果**索引表**太大，一个**索引块装不下**、那么可以==**将多个索引块链接起来存放**==。
       - 假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256个索引项。
         若一个文件大小为$256*256$KB =65,536 KB = 64MB，该文件共有$256*256$个块，也就对应$256*256$个索引项，也就需要256个索引块来存储，这些索引块用链接方案连起来。若想要访问文件的最后一个逻辑块,就必须找到最后一个索引块（第256个索引块），而各个索引块之间是用指针链接起来的，因此必须先顺序地读入前255个索引块。
         - **多层索引**
           - <img style="width: 1000px;height:400px" src="image\多层索引.png ">
         - **混合索引**
           - <img style="width: 1000px;height:400px" src="image\混合索引.png ">
           - ==**要会根据多层索引、混合索引的结构计算出文件的最大长度(Key:各级索引表最大不能超过一个块)**==
           - ==**要能自己分析访问某个数据块所需要的读磁盘次数（Key:FCB中会存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块。每次读入下一级的索引块都需要一次读磁盘操作。另外，要注意题目条件――顶级索引块是否已调入内存)**==
   - <img style="width: 1000px;height:400px" src="image\文件的物理结构总结.png ">

#### 文件存储空间管理

1. 存储空间的划分与初始化
   - 为磁盘分区，存储空间的划分：将物理磁盘划分为一个个**文件卷（逻辑卷，物理卷）**
   - <img style="width: 1000px;height:400px" src="image\磁盘初始化.png ">
2. 存储空间管理
   - ==**空闲表法**==
     - <img style="width: 1000px;height:400px" src="image\空闲表法.png ">
     - **适用于连续分配**
   - **空闲链表法**
     - ==空闲盘**块**链==
       - <img style="width: 1000px;height:330px" src="image\空闲链表法.png ">
     - ==空闲盘**区**链==
       - <img style="width: 1000px;height:330px" src="image\空闲链表法2.png ">
   - ==**位示图法**==
     - <img style="width: 1000px;height:400px" src="image\位示图法.png ">
     - 位示图:每个二进制位对应一个盘块。在本例中，“0”代表盘块空闲，“1”代表盘块已分配。
     - 如何分配:若文件需要K个块，①顺序扫描位示图，找到K个相邻或不相邻的“0”;②根据字号、位号算出对应的盘块号，将相应盘块分配给文件;③将相应位设置为“1”。
     - 如何回收:①根据回收的盘块号计算出对应的字号、位号;②将相应二进制位设为“0”
   - **成组链接法**
     - 文件卷的目录区中专门用**一个磁盘块作为“超级块”**，**当系统启动时需要将超级块读入内存**。并且要保证内存与外存中的“超级块”数据一致。
     - <img style="width: 700px;height:300px" src="image\超级块.png ">
     - <img style="width: 1000px;height:400px" src="image\成组链接法.png ">
3. ==**文件的基本操作**==
   - 创建文件
     - 进行Create系统调用时，需要提供的几个主要参数:
       - 所需的**外存空间大小**（如:一个盘块，即1KB)
       - 文件存放**路径**（“D:/Demo”)
       - **文件名**（这个地方默认为“新建文本文档.txt”)
     - 操作系统在处理Create系统调用时，主要做了两件事:
       - **在外存中找到文件所需的空间**（结合上小节学习的空闲链表法、位示图、成组链接法等管理策略，找到空闲空间入
       - 根据**文件存放路径**的信息**找到该目录对应的目录文件**（此处就是D:/Demo目录），在目录中**创建该文件对应的目录项**。目录项中包含了文件名、文件在外存中的存放位置等信息。
   - 删除文件
     - 进行Delete系统调用时，需要提供的几个主要参数:
       - **文件存放路径**（“D:/Demo”)
       - **文件名**(“test.txt”)
     - 操作系统在处理Delete系统调用时，主要做了几件事:
       - 根据文件存放路径找到相应的目录文件，从目录中**找到文件名对应的目录项**。
       - 根据该目录项记录的文件在外存的存放位置、文件大小等信息，**回收文件占用的磁盘块**。(回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理)
       - 从目录表中**删除文件对应的目录项**
   - 打开文件
     - 在很多操作系统中，在对文件进行操作之前，要求用户先使用open系统调用“打开文件”，需要提供的几个主要参数:
       - **文件存放路径**（“D:/Demo”)
       - **文件名**( “test.txt”)
       - **要对文件的操作类型**（如:r只读;rw读写等)
     - 操作系统在处理open系统调用时，主要做了几件事:
       - 根据文件存放路径找到相应的目录文件，从目录中**找到文件名对应的的目录项**，并检查该用户是否有指定的操作权限。
       - **将目录项复制到内存中的“打开文件表”中**。并将对应表目的**编号返回给用**户。**之后用户使用打开文件表的编号来指明要操作的文件。**
     - <img style="width: 600px;height:350px" src="image\打开文件表.png ">
     - <img style="width: 600px;height:350px" src="image\打开文件表1.png ">
     - **系统打开文件表**
       - 可以方便实现某些文件管理的功能。例如:在Windows系统中，我们尝试删除某个txt文件，如果此时该文件已被某个“记事本”进程打开，则系统会提示我们“暂时无法删除该文件”。其实系统在背后做的事就是先检查了系统打开文件表，确认此时是否有进程正在使用该文件。
     - 访问权限：如果打开文件时声明的是“只读”，则该进程不能对文件进行写操作
     - 读写指针：记录该进程对文件的读写操作进行到的位置
     - **打开文件时并不会把文件数据直接读入内存。“索引号”也称“文件描述符”**
   - ==**关闭文件**==
     - 进程使用完文件后，要“关闭文件”操作系统在处理Close系统调用时，主要做了几件事:
     - 将进程的打开文件表相应表项删除
     - 回收分配给该文件的内存空间等资源
     - 系统打开文件表的打开计数器count 减1，若count =0，则删除对应表项。
   - 读文件
     - 进程使用read系统调用完成写操作。需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可)，还需要指明要读入多少数据（如:读入1KB）、指明读入的数据要放在内存中的什么位置。操作系统在处理read系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。
   - 写文件
     - 进程使用write 系统调用完成写操作，需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明要写出多少数据（如:写出1KB）、写回外存的数据放在内存中的什么位置操作系统在处理write系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。
4. 文件共享
   - 基于索引节点的共享方式（硬链接）
     - <img style="width: 800px;height:450px" src="image\硬链接.png ">
   - 基于符号链的共享方式（软链接）
     - <img style="width: 800px;height:450px" src="image\软连接.png ">
5. 文件保护
   - 口令保护
     - 为文件设置一个“口令”(如: abc112233)，用户请求访问该文件时必须提供“口令”。
       - 口令一般存放在文件对应的FCB或索引结点中。用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确，则允许该用户访问文件
     - 优点:保存口令的空间开销不多，验证口令的时间开销也很小。
     - 缺点:正确的“口令”存放在系统内部，不够安全。
   - 加密保护
     - <img style="width: 800px;height:450px" src="image\加密保护.png ">
   - 访问控制
     - 在**每个文件的FCB(或索引结点）中增加一个访问控制列表**(Access-Control List,ACL)，该表中记录了各个用户可以对该文件执行哪些操作。
     - <img style="width: 800px;height:250px" src="image\访问控制1.png ">
     - <img style="width: 800px;height:250px" src="image\访问控制2.png ">
6. 文件系统布局
   - <img style="width: 800px;height:150px" src="image\物理格式化.png ">
   - <img style="width: 800px;height:250px" src="image\逻辑格式化.png ">
   - 文件系统在内存中的结构
     - <img style="width: 800px;height:450px" src="image\文件系统在内存中的结构.png ">
7. 虚拟文件系统
   - <img style="width: 600px;height:350px" src="image\虚拟文件系统.png ">
   - <img style="width: 1200px;height:450px" src="image\文件系统挂载.png ">
   - 虚拟文件系统的特点:
     - 向上层用户进程提供统一标准的系统调用接口，屏蔽底层具体文件系统的实现差异
     - VFS要求下层的文件系统必须实现某些规定的函数功能，如: open/read/write。一个新的文件系统想要在某操作系统上被使用，就必须满足该操作系统VFS的要求
     - **每打开一个文件，VFS就在主存中新建一个vnode，用==统一的数据结构表示文件，无论该文件存储在哪个文件系统==**。
       - **vnodd只存在于主存中，而inode既会被调入主存，也会在外存中存储**
       - 打开文件后，**创建vnode，并将文件信息复制到vnode中**，vnode的功能指针指向具体文件系统的函数功能。
       - <img style="width: 600px;height:350px" src="image\虚拟文件系统2.png ">

### 输入/输出管理

#### 基本概念

1. I/O设备按使用特性分类

   - 存储设备
     - 移动硬盘，光盘（数据传输速度快）

   - 人机交互类外部设备
     - 鼠标键盘打印机（数据传输速度慢）

   - 网络通信设备
     - 调制解调器（数据传输介于两者之间）

2. <img style="width: 800px;height:250px" src="image\io设备分类方式.png ">

#### IO控制

1. IO控制器
   - <img style="width: 800px;height:450px" src="image\IO控制器.png ">
   - 值得注意的小细节:一个I/O控制器可能会对应多个设备;
     - 数据寄存器、控制寄存器、状态寄存器可能有多个（如:每个控制/状态寄存器对应一个具体的设备），且这些寄存器都要有相应的地址，才能方便CPU操作。
       - 有的计算机会让这些寄存器占用内存地址的一部分，称为**内存映像I/O**
       - 另一些计算机则采用I/O专用地址，即**寄存器独立编址**。
       - <img style="width: 800px;height:450px" src="image\内存映像IO.png ">
2. IO控制方式
   - 程序直接控制方式
     - <img style="width: 800px;height:450px" src="image\程序直接控制方式.png ">
   - 中断驱动方式
     - <img style="width: 800px;height:450px" src="image\中断驱动方式.png ">
     - 引入中断机制。由于I/O设备速度很慢，因此在CPU发出读/写命令后，可将等待I/O的进程阻塞，先切换到别的进程执行。当I/O完成后，控制器会向CPU发出一个中断信号，CPU检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。处理中断的过程中，CPU从I/O控制器读一个字的数据传送到CPU寄存器，再写入主存。接着，CPU恢复等待I/O的进程（或其他进程）的运行环境，然后继续执行。
   - DMA方式
     - <img style="width: 800px;height:450px" src="image\DMA.png ">
     - <img style="width: 800px;height:450px" src="image\DMA2.png ">
     - <img style="width: 800px;height:450px" src="image\DMA3.png ">
   - 通道控制方式
     - <img style="width: 800px;height:450px" src="image\通道通信方式.png ">
     - <img style="width: 800px;height:450px" src="image\通道通信.png ">
   - <img style="width: 800px;height:450px" src="image\IO控制方式.png ">
3. IO软件层次结构
   - <img style="width: 800px;height:450px" src="image\IO软件层次结构.png ">
   - 用户层软件
     - 用户层软件实现了与用户交互的接口，用户可直接使用该层提供的、与I/O操作相关的库函数对设备进行操作
     - 用户层软件将用户请求翻译成格式化的I/O请求，并通过“系统调用”请求操作系统内核的服务
     - Windows操作系统向外提供的一系列系统调用，但是由于系统调用的格式严格，使用麻烦，因此在用户层上封装了一系列更方便的库函数接口供用户使用(Windows API)
   - **设备独立性软件**
     - 又称**设备无关性软件**。与**设备的硬件特性无关**的功能几乎都在这一层实现。
     - **向上层提供统一的调用接口(如read/write系统调用)**
     - **设备的保护**
       - 原理类似与文件保护。**设备被看做是一种==特殊的文件==**，不同用户对各个文件的访问权限是不一样的，同理，**对设备的访问权限也不一样**。
       - **在UNIX系统中，设备被看做是一种特殊的文件，每个设备也会有对应的FCB**。当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。(参考“文件保护”小节)
     - **差错处理**
       - 设备独立性软件需要对一些设备的错误进行处理
     - **设备的分配与回收**
     - **数据缓存区管理**
     - **建立==逻辑设备名==到==物理设备名==的映射关系;根据设备类型选择调用相应的驱动程序**
       - 设备独立性软件需要通过**==逻辑设备表==**（LUT，Logical UnitTable)”来确定**逻辑设备对应的物理设备**，并找到该设备对应的**设备驱动程序**。
       - <img style="width: 500px;height:200px" src="image\设备独立性软件.png ">
       - 操作系统系统可以**采用两种方式管理逻辑设备表**（LUT) :
         - 第一种方式，整**个系统只设置一张LUT**，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。
         - 第二种方式，为**每个用户设置一张LUT**，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。
   - 设备驱动程序
     - 主要负责对硬件设备的具体控制，将上层发出的一系列命令（如read/write）转化成特定设备“能听得懂”的一系列操作。包括设置设备寄存器;检查设备状态等
   - 中断处理程序
     - <img style="width: 550px;height:300px" src="image\中断处理程序.png ">
   - 硬件
     - 不同的I/O设备有不同的硬件特性，具体细节只有设备的厂家才知道。因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序。
   - 理解并记住I/O软件**各个层次之间的顺序**，要能够推理判断某个处理应该是在哪个层次完成的（最常考的是**设备独立性软件**、**设备驱动程序这两层**。只需理解一个特点即可:直接涉及到硬件具体细节、且与中断无关的操作肯定是在设备驱动程序层完成的;**没有涉及硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层完成的**)
4. IO应用程序接口和驱动程序接口
   - <img style="width: 800px;height:450px" src="image\IO应用程序接口2.png ">
   - **用户层的应用程序无法用一个统一的系统调用接口来完成所有类型设备的l/O**
   - <img style="width: 800px;height:450px" src="image\socket.png ">
   - **阻塞l/O**:应用程序发出I/O系统调用，进程需转为阻塞态等待。
     - eg:字符设备接口――从键盘读一个字符get
   - **非阻塞I/O**:应用程序发出I/O系统调用，系统调用可迅速返回，进程无需阻塞等待。
     - eg:块设备接口――往磁盘写数据write
   - 程序驱动接口
     - <img style="width: 800px;height:450px" src="image\程序驱动接口.png ">
5. ==**IO核心子系统**==
   - 设备独立性软件，设备驱动程序，中断处理程序属于操作系统的内核部分即：IO系统或IO核心子系统
   - ==**Spooling（假脱机技术）**==
     - <img style="width: 800px;height:450px" src="image\假脱机技术.png ">
     - <img style="width: 800px;height:250px" src="image\共享打印机.png ">
     - 虽然系统中只有一个台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。SPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享设备。
   - ==设备的分配与回收==
     - 设备的固有属性
       - **独占设备**——一个时段只能分配给一个进程（如打印机）
       - **共享设备**――可同时分配给多个进程使用（如磁盘)，各进程往往是宏观上同时共享使用设备，而微观上交替使用。
       - **虚拟设备**――**采用SPOOLing技术将独占设备改造成虚拟的共享设备**，可同时分配给多个进程使用（如采用SPOOLing技术实现的共享打印机)
     - 设备分配算法
       - **先来先服务**
       - **优先级高者优先**
       - **短任务优先**
       - 从进程运行的**安全性**上考虑，设备分配有两种方式:
         - **安全分配方式**:为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒。(eg:考虑进程请求打印机打印输出的例子)
           - 一个时段内每个进程只能使用一个设备
           - 优点:破坏了“请求和保持”条件，不会死锁
           - 缺点:对于一个进程来说，CPU和I/O设备只能串行工作
         - **不安全分配方式**:进程发出I/O请求后，系统为其分配I/O设备，进程可继续执行，之后还可以发出新的I/O请求。只有某个l/O请求得不到满足时才将进程阻塞。
           - 一个进程可以同时使用多个设备
           - 优点:进程的计算任务和I/O任务可以并行处理，使进程迅速推进
           - 缺点:有可能发生死锁（死锁避免、死锁的检测和解除)
       - **静态分配**:进程运行前为其分配全部所需资源，运行结束后归还资源
       - **动态分配**:进程运行过程中动态申请设备资源
     - 设备分配管理中的数据结构
       - <img style="width: 800px;height:350px" src="image\通道.png ">
       - <img style="width: 800px;height:350px" src="image\设备控制表.png ">
       - <img style="width: 800px;height:350px" src="image\控制器控制表.png ">
       - <img style="width: 800px;height:350px" src="image\通道控制表.png ">
       - <img style="width: 800px;height:350px" src="image\系统设备表.png ">
     - 设备分配的步骤
       - 根据**进程请求的物理设备名查找SDT**（注:物理设备名是进程请求分配设备时提供的参数)
       - 根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。
       - 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。
       - 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。
       - 注∶只有==**设备、控制器、通道三者都分配成功时，这次设备分配才算成功**==，之后便可启动/O设备进行数据传送
       - 缺点:
         - 用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程
         - 若换了一个物理设备，则程序无法运行
         - 若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待
       - 改进
         - 根据进程请求的**逻辑设备名查找SDT**(注:用户编程时提供的逻辑设备名其实就是“设备类型”)
         - 查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在==**逻辑设备表(LUT)**==中新增一个表项。
         - 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。
         - 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。
         - <img style="width: 800px;height:350px" src="image\逻辑设备映射表.png ">
   - **==缓冲区管理==**
     - 缓冲区的作用
       - <img style="width: 800px;height:350px" src="image\缓冲区的作用.png ">
     - 单缓冲区
       - 假设某用户进程请求某种块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区（**若题目中没有特别说明，一个缓冲区的大小就是一个块)**。
       - 注意:当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出;当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。
       - <img style="width: 800px;height:250px" src="image\单缓冲.png ">
     - 双缓冲
       - 假设某用户进程请求某种块设备读入若干块的数据。若采用双缓冲的策略，操作系统会在主存中为其分配两个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块)
       - 双缓冲题目中，假设初始状态为:工作区空，其中一个缓冲区满，另一个缓冲区空
       - 结论:采用双缓冲策略，处理一个数据块的平均耗时为**Max (T,C+M)**
       - <img style="width: 800px;height:250px" src="image\双缓冲区.png ">
     - 循环缓冲区
       - <img style="width: 800px;height:350px" src="image\循环缓冲区.png ">
     - 缓冲池
       - 缓冲池由系统中共用的缓冲区组成。
       - 这些缓冲区按使用状况可以分为:**空缓冲队列**、**装满输入数据的缓冲队列**(输入队列)、**装满输出数据的缓冲队列**（输出队列)。
       - 另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了**四种工作缓冲区**:用于收容输入数据的工作缓冲区（hin)、用于提取输入数据的工作缓冲区（sin)、用于收容输出数据的工作缓冲区(hout） 、用于提取输出数据的工作缓冲区( sout)
       - <img style="width: 800px;height:250px" src="image\缓冲池.png ">

#### 磁盘

1. 硬件结构
   - <img style="width: 800px;height:400px" src="image\磁盘物理结构.png ">
2. 物理地址
   - <img style="width: 800px;height:400px" src="image\物理地址.png ">
3. 磁盘的分类
   - <img style="width: 800px;height:400px" src="image\磁盘的分类.png ">
   - 盘片可以更换的称为可换盘磁盘
   - 盘片不可更换的称为固定盘磁盘
4. 磁盘调度算法
   - <img style="width: 800px;height:400px" src="image\磁盘读写时间.png ">
   - 先来先服务算法
     - 根据进程请求访问磁盘的先后顺序进行调度。
     - 假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道
     - 按照FCFS的规则，按照请求到达的顺序，磁头需要依次移动到55、58、39、18、90、160、150、38、184号磁道
     - 磁头总共移动了45+3+19+21+72+70+10+112+146=498个磁道响应一个请求平均需要移动498/9 = 55.3个磁道（平均寻找长度)
     - 优点:公平;如果请求访问的磁道比较集中的话，算法性能还算过的去
     - 缺点:如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。
     - <img style="width: 800px;height:150px" src="image\磁盘先来先服务算法.png ">
   - 最短寻找时间优先
     - SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。（其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优)假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道
     - 磁头总共移动了(100-18)+(184-18)= 248个磁道
     - 响应一个请求平均需要移动248/9= 27.5个磁道（平均寻找长度)
     - 优点:性能较好，平均寻道时间短
     - 缺点:可能产生“饥饿”现象
     - <img style="width: 800px;height:150px" src="image\最短寻找时间优先.png ">
   - 扫描算法
     - SSTF算法会产生饥饿的原因在于:磁头有可能在一个小区域内来回来去地移动。为了防止这个问题，可以规定，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。这就是扫描算法(SCAN)的思想。由于磁头移动的方式很像电梯，因此也叫电梯算法。
     - 假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、
       184号磁道
     - <img style="width: 800px;height:50px" src="image\扫描算法.png ">
     - 磁头总共移动了(200-100)+ (200-18)= 282个磁道响应一个请求平均需要移动282/9 = 31.3个磁道（平均寻找长度)
     - 优点:性能较好，平均寻道时间较短，不会产生饥饿现象
     - 缺点:
       - 只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移劫磁头了。
       - SCAN算法对于各个位置磁道的响应频率不平均(如:假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离;而响应了184号磁道的请求之后，很快又可以再次响应184号磁道的请求了)
   - LOOK算法
     - 扫描算法(SCAN)中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。LOOK调度算法就是为了解决这个问题，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。(边移动边观察，因此叫LOOK)
     - <img style="width: 800px;height:250px" src="image\Look调度算法.png ">
   - 循环扫描算法（C-SCAN)
     - SCAN算法对于各个位置磁道的响应频率不平均，而c-SCAN算法就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。
     - <img style="width: 800px;height:250px" src="image\C-SCAN.png ">
   - C-LOOK调度算法
     - C-SCAN算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C-LOOK算法就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。
     - <img style="width: 800px;height:250px" src="image\C-LOOK调度算法.png ">
   - <img style="width: 1000px;height:350px" src="image\磁盘调度算法.png ">
5. 减少磁盘延迟的方法
   - <img style="width: 1000px;height:350px" src="image\减少磁盘延迟的方法.png ">
   - <img style="width: 1000px;height:350px" src="image\交替编号.png ">
   - <img style="width: 1000px;height:450px" src="image\磁盘地址结构.png ">
     - 读取地址连续的磁盘块时，采用(柱面号，盘面号，扇区号）的地址结构可以减少磁头移动消耗的时间
   - <img style="width: 1000px;height:450px" src="image\错位命名.png ">

6. 磁盘的管理

   - 磁盘初始化:
     - Step 1:进行低级格式化(物理格式化），将磁盘的各个磁道划分为扇区。一个扇区通常可分为头、数据区域（如512B大小）、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶校验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误)
     - Step 2:将磁盘分区，每个分区由若干柱面组成（即分为我们熟悉的c盘、D盘、E盘)
     - Step 3:进行逻辑格式化，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表)
   - <img style="width: 1000px;height:450px" src="image\引导快.png ">
   - 对于简单的磁盘，可以在逻辑格式化时（建立文件系统时）对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如:在FAT表上标明。（在这种方式中，坏块对操作系统不透明)
   - 对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。
   - 在磁盘出厂前进行低级格式化（物理格式化）时就将**坏块链**进行初始化。

   - 会保留一些“备用扇区”，用于替换坏块。这种方案称为扇区备用。且这种处理方式中，坏块对操作系统透明。

7. SSD固态硬盘

   - 与计算机组成原理相同



​	

